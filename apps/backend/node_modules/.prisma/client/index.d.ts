
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Subtask
 * 
 */
export type Subtask = $Result.DefaultSelection<Prisma.$SubtaskPayload>
/**
 * Model SubtaskDependency
 * 
 */
export type SubtaskDependency = $Result.DefaultSelection<Prisma.$SubtaskDependencyPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentMention
 * 
 */
export type CommentMention = $Result.DefaultSelection<Prisma.$CommentMentionPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model TaskLabel
 * 
 */
export type TaskLabel = $Result.DefaultSelection<Prisma.$TaskLabelPayload>
/**
 * Model TaskDependency
 * 
 */
export type TaskDependency = $Result.DefaultSelection<Prisma.$TaskDependencyPayload>
/**
 * Model TimeLog
 * 
 */
export type TimeLog = $Result.DefaultSelection<Prisma.$TimeLogPayload>
/**
 * Model AutomationRule
 * 
 */
export type AutomationRule = $Result.DefaultSelection<Prisma.$AutomationRulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model ProjectUser
 * 
 */
export type ProjectUser = $Result.DefaultSelection<Prisma.$ProjectUserPayload>
/**
 * Model ProjectPhase
 * 
 */
export type ProjectPhase = $Result.DefaultSelection<Prisma.$ProjectPhasePayload>
/**
 * Model Deliverable
 * 
 */
export type Deliverable = $Result.DefaultSelection<Prisma.$DeliverablePayload>
/**
 * Model ScopeHistory
 * 
 */
export type ScopeHistory = $Result.DefaultSelection<Prisma.$ScopeHistoryPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model SettingsChangeLog
 * 
 */
export type SettingsChangeLog = $Result.DefaultSelection<Prisma.$SettingsChangeLogPayload>
/**
 * Model ProjectSetting
 * 
 */
export type ProjectSetting = $Result.DefaultSelection<Prisma.$ProjectSettingPayload>
/**
 * Model ProjectSettingsChangeLog
 * 
 */
export type ProjectSettingsChangeLog = $Result.DefaultSelection<Prisma.$ProjectSettingsChangeLogPayload>
/**
 * Model UserSetting
 * 
 */
export type UserSetting = $Result.DefaultSelection<Prisma.$UserSettingPayload>
/**
 * Model UserSettingsChangeLog
 * 
 */
export type UserSettingsChangeLog = $Result.DefaultSelection<Prisma.$UserSettingsChangeLogPayload>
/**
 * Model ProjectNotification
 * 
 */
export type ProjectNotification = $Result.DefaultSelection<Prisma.$ProjectNotificationPayload>
/**
 * Model UrgentProjectAcknowledgement
 * 
 */
export type UrgentProjectAcknowledgement = $Result.DefaultSelection<Prisma.$UrgentProjectAcknowledgementPayload>
/**
 * Model ProjectNotificationPreference
 * 
 */
export type ProjectNotificationPreference = $Result.DefaultSelection<Prisma.$ProjectNotificationPreferencePayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model ProjectTeam
 * 
 */
export type ProjectTeam = $Result.DefaultSelection<Prisma.$ProjectTeamPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model ProjectType
 * 
 */
export type ProjectType = $Result.DefaultSelection<Prisma.$ProjectTypePayload>
/**
 * Model ProjectStatus
 * 
 */
export type ProjectStatus = $Result.DefaultSelection<Prisma.$ProjectStatusPayload>
/**
 * Model TaskStatus
 * 
 */
export type TaskStatus = $Result.DefaultSelection<Prisma.$TaskStatusPayload>
/**
 * Model StatSnapshot
 * 
 */
export type StatSnapshot = $Result.DefaultSelection<Prisma.$StatSnapshotPayload>
/**
 * Model ProductivitySnapshot
 * 
 */
export type ProductivitySnapshot = $Result.DefaultSelection<Prisma.$ProductivitySnapshotPayload>
/**
 * Model ForecastSnapshot
 * 
 */
export type ForecastSnapshot = $Result.DefaultSelection<Prisma.$ForecastSnapshotPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.subtask`: Exposes CRUD operations for the **Subtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtasks
    * const subtasks = await prisma.subtask.findMany()
    * ```
    */
  get subtask(): Prisma.SubtaskDelegate<ExtArgs>;

  /**
   * `prisma.subtaskDependency`: Exposes CRUD operations for the **SubtaskDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubtaskDependencies
    * const subtaskDependencies = await prisma.subtaskDependency.findMany()
    * ```
    */
  get subtaskDependency(): Prisma.SubtaskDependencyDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.commentMention`: Exposes CRUD operations for the **CommentMention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentMentions
    * const commentMentions = await prisma.commentMention.findMany()
    * ```
    */
  get commentMention(): Prisma.CommentMentionDelegate<ExtArgs>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs>;

  /**
   * `prisma.taskLabel`: Exposes CRUD operations for the **TaskLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLabels
    * const taskLabels = await prisma.taskLabel.findMany()
    * ```
    */
  get taskLabel(): Prisma.TaskLabelDelegate<ExtArgs>;

  /**
   * `prisma.taskDependency`: Exposes CRUD operations for the **TaskDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDependencies
    * const taskDependencies = await prisma.taskDependency.findMany()
    * ```
    */
  get taskDependency(): Prisma.TaskDependencyDelegate<ExtArgs>;

  /**
   * `prisma.timeLog`: Exposes CRUD operations for the **TimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeLogs
    * const timeLogs = await prisma.timeLog.findMany()
    * ```
    */
  get timeLog(): Prisma.TimeLogDelegate<ExtArgs>;

  /**
   * `prisma.automationRule`: Exposes CRUD operations for the **AutomationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationRules
    * const automationRules = await prisma.automationRule.findMany()
    * ```
    */
  get automationRule(): Prisma.AutomationRuleDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.projectUser`: Exposes CRUD operations for the **ProjectUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUsers
    * const projectUsers = await prisma.projectUser.findMany()
    * ```
    */
  get projectUser(): Prisma.ProjectUserDelegate<ExtArgs>;

  /**
   * `prisma.projectPhase`: Exposes CRUD operations for the **ProjectPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectPhases
    * const projectPhases = await prisma.projectPhase.findMany()
    * ```
    */
  get projectPhase(): Prisma.ProjectPhaseDelegate<ExtArgs>;

  /**
   * `prisma.deliverable`: Exposes CRUD operations for the **Deliverable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliverables
    * const deliverables = await prisma.deliverable.findMany()
    * ```
    */
  get deliverable(): Prisma.DeliverableDelegate<ExtArgs>;

  /**
   * `prisma.scopeHistory`: Exposes CRUD operations for the **ScopeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScopeHistories
    * const scopeHistories = await prisma.scopeHistory.findMany()
    * ```
    */
  get scopeHistory(): Prisma.ScopeHistoryDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs>;

  /**
   * `prisma.settingsChangeLog`: Exposes CRUD operations for the **SettingsChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SettingsChangeLogs
    * const settingsChangeLogs = await prisma.settingsChangeLog.findMany()
    * ```
    */
  get settingsChangeLog(): Prisma.SettingsChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.projectSetting`: Exposes CRUD operations for the **ProjectSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSettings
    * const projectSettings = await prisma.projectSetting.findMany()
    * ```
    */
  get projectSetting(): Prisma.ProjectSettingDelegate<ExtArgs>;

  /**
   * `prisma.projectSettingsChangeLog`: Exposes CRUD operations for the **ProjectSettingsChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSettingsChangeLogs
    * const projectSettingsChangeLogs = await prisma.projectSettingsChangeLog.findMany()
    * ```
    */
  get projectSettingsChangeLog(): Prisma.ProjectSettingsChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.userSetting`: Exposes CRUD operations for the **UserSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSetting.findMany()
    * ```
    */
  get userSetting(): Prisma.UserSettingDelegate<ExtArgs>;

  /**
   * `prisma.userSettingsChangeLog`: Exposes CRUD operations for the **UserSettingsChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettingsChangeLogs
    * const userSettingsChangeLogs = await prisma.userSettingsChangeLog.findMany()
    * ```
    */
  get userSettingsChangeLog(): Prisma.UserSettingsChangeLogDelegate<ExtArgs>;

  /**
   * `prisma.projectNotification`: Exposes CRUD operations for the **ProjectNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectNotifications
    * const projectNotifications = await prisma.projectNotification.findMany()
    * ```
    */
  get projectNotification(): Prisma.ProjectNotificationDelegate<ExtArgs>;

  /**
   * `prisma.urgentProjectAcknowledgement`: Exposes CRUD operations for the **UrgentProjectAcknowledgement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UrgentProjectAcknowledgements
    * const urgentProjectAcknowledgements = await prisma.urgentProjectAcknowledgement.findMany()
    * ```
    */
  get urgentProjectAcknowledgement(): Prisma.UrgentProjectAcknowledgementDelegate<ExtArgs>;

  /**
   * `prisma.projectNotificationPreference`: Exposes CRUD operations for the **ProjectNotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectNotificationPreferences
    * const projectNotificationPreferences = await prisma.projectNotificationPreference.findMany()
    * ```
    */
  get projectNotificationPreference(): Prisma.ProjectNotificationPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.projectTeam`: Exposes CRUD operations for the **ProjectTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTeams
    * const projectTeams = await prisma.projectTeam.findMany()
    * ```
    */
  get projectTeam(): Prisma.ProjectTeamDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.projectType`: Exposes CRUD operations for the **ProjectType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTypes
    * const projectTypes = await prisma.projectType.findMany()
    * ```
    */
  get projectType(): Prisma.ProjectTypeDelegate<ExtArgs>;

  /**
   * `prisma.projectStatus`: Exposes CRUD operations for the **ProjectStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStatuses
    * const projectStatuses = await prisma.projectStatus.findMany()
    * ```
    */
  get projectStatus(): Prisma.ProjectStatusDelegate<ExtArgs>;

  /**
   * `prisma.taskStatus`: Exposes CRUD operations for the **TaskStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskStatuses
    * const taskStatuses = await prisma.taskStatus.findMany()
    * ```
    */
  get taskStatus(): Prisma.TaskStatusDelegate<ExtArgs>;

  /**
   * `prisma.statSnapshot`: Exposes CRUD operations for the **StatSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatSnapshots
    * const statSnapshots = await prisma.statSnapshot.findMany()
    * ```
    */
  get statSnapshot(): Prisma.StatSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.productivitySnapshot`: Exposes CRUD operations for the **ProductivitySnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductivitySnapshots
    * const productivitySnapshots = await prisma.productivitySnapshot.findMany()
    * ```
    */
  get productivitySnapshot(): Prisma.ProductivitySnapshotDelegate<ExtArgs>;

  /**
   * `prisma.forecastSnapshot`: Exposes CRUD operations for the **ForecastSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForecastSnapshots
    * const forecastSnapshots = await prisma.forecastSnapshot.findMany()
    * ```
    */
  get forecastSnapshot(): Prisma.ForecastSnapshotDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Team: 'Team',
    Project: 'Project',
    Task: 'Task',
    Subtask: 'Subtask',
    SubtaskDependency: 'SubtaskDependency',
    Comment: 'Comment',
    CommentMention: 'CommentMention',
    Label: 'Label',
    TaskLabel: 'TaskLabel',
    TaskDependency: 'TaskDependency',
    TimeLog: 'TimeLog',
    AutomationRule: 'AutomationRule',
    Notification: 'Notification',
    ActivityLog: 'ActivityLog',
    ProjectUser: 'ProjectUser',
    ProjectPhase: 'ProjectPhase',
    Deliverable: 'Deliverable',
    ScopeHistory: 'ScopeHistory',
    Attachment: 'Attachment',
    SystemSetting: 'SystemSetting',
    SettingsChangeLog: 'SettingsChangeLog',
    ProjectSetting: 'ProjectSetting',
    ProjectSettingsChangeLog: 'ProjectSettingsChangeLog',
    UserSetting: 'UserSetting',
    UserSettingsChangeLog: 'UserSettingsChangeLog',
    ProjectNotification: 'ProjectNotification',
    UrgentProjectAcknowledgement: 'UrgentProjectAcknowledgement',
    ProjectNotificationPreference: 'ProjectNotificationPreference',
    TeamMember: 'TeamMember',
    ProjectTeam: 'ProjectTeam',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserRole: 'UserRole',
    ProjectType: 'ProjectType',
    ProjectStatus: 'ProjectStatus',
    TaskStatus: 'TaskStatus',
    StatSnapshot: 'StatSnapshot',
    ProductivitySnapshot: 'ProductivitySnapshot',
    ForecastSnapshot: 'ForecastSnapshot'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "team" | "project" | "task" | "subtask" | "subtaskDependency" | "comment" | "commentMention" | "label" | "taskLabel" | "taskDependency" | "timeLog" | "automationRule" | "notification" | "activityLog" | "projectUser" | "projectPhase" | "deliverable" | "scopeHistory" | "attachment" | "systemSetting" | "settingsChangeLog" | "projectSetting" | "projectSettingsChangeLog" | "userSetting" | "userSettingsChangeLog" | "projectNotification" | "urgentProjectAcknowledgement" | "projectNotificationPreference" | "teamMember" | "projectTeam" | "role" | "permission" | "rolePermission" | "userRole" | "projectType" | "projectStatus" | "taskStatus" | "statSnapshot" | "productivitySnapshot" | "forecastSnapshot"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Subtask: {
        payload: Prisma.$SubtaskPayload<ExtArgs>
        fields: Prisma.SubtaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findFirst: {
            args: Prisma.SubtaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          findMany: {
            args: Prisma.SubtaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[]
          }
          create: {
            args: Prisma.SubtaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          createMany: {
            args: Prisma.SubtaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubtaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          update: {
            args: Prisma.SubtaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          deleteMany: {
            args: Prisma.SubtaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubtaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>
          }
          aggregate: {
            args: Prisma.SubtaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtask>
          }
          groupBy: {
            args: Prisma.SubtaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskCountAggregateOutputType> | number
          }
        }
      }
      SubtaskDependency: {
        payload: Prisma.$SubtaskDependencyPayload<ExtArgs>
        fields: Prisma.SubtaskDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtaskDependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtaskDependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          findFirst: {
            args: Prisma.SubtaskDependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtaskDependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          findMany: {
            args: Prisma.SubtaskDependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>[]
          }
          create: {
            args: Prisma.SubtaskDependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          createMany: {
            args: Prisma.SubtaskDependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubtaskDependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          update: {
            args: Prisma.SubtaskDependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          deleteMany: {
            args: Prisma.SubtaskDependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtaskDependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubtaskDependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtaskDependencyPayload>
          }
          aggregate: {
            args: Prisma.SubtaskDependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtaskDependency>
          }
          groupBy: {
            args: Prisma.SubtaskDependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtaskDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtaskDependencyCountArgs<ExtArgs>
            result: $Utils.Optional<SubtaskDependencyCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentMention: {
        payload: Prisma.$CommentMentionPayload<ExtArgs>
        fields: Prisma.CommentMentionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentMentionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentMentionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          findFirst: {
            args: Prisma.CommentMentionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentMentionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          findMany: {
            args: Prisma.CommentMentionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>[]
          }
          create: {
            args: Prisma.CommentMentionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          createMany: {
            args: Prisma.CommentMentionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentMentionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          update: {
            args: Prisma.CommentMentionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          deleteMany: {
            args: Prisma.CommentMentionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentMentionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentMentionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentMentionPayload>
          }
          aggregate: {
            args: Prisma.CommentMentionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentMention>
          }
          groupBy: {
            args: Prisma.CommentMentionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentMentionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentMentionCountArgs<ExtArgs>
            result: $Utils.Optional<CommentMentionCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      TaskLabel: {
        payload: Prisma.$TaskLabelPayload<ExtArgs>
        fields: Prisma.TaskLabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findFirst: {
            args: Prisma.TaskLabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          findMany: {
            args: Prisma.TaskLabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>[]
          }
          create: {
            args: Prisma.TaskLabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          createMany: {
            args: Prisma.TaskLabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskLabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          update: {
            args: Prisma.TaskLabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          deleteMany: {
            args: Prisma.TaskLabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskLabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLabelPayload>
          }
          aggregate: {
            args: Prisma.TaskLabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLabel>
          }
          groupBy: {
            args: Prisma.TaskLabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLabelCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLabelCountAggregateOutputType> | number
          }
        }
      }
      TaskDependency: {
        payload: Prisma.$TaskDependencyPayload<ExtArgs>
        fields: Prisma.TaskDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskDependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskDependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findFirst: {
            args: Prisma.TaskDependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskDependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          findMany: {
            args: Prisma.TaskDependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[]
          }
          create: {
            args: Prisma.TaskDependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          createMany: {
            args: Prisma.TaskDependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          update: {
            args: Prisma.TaskDependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          deleteMany: {
            args: Prisma.TaskDependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskDependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskDependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>
          }
          aggregate: {
            args: Prisma.TaskDependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskDependency>
          }
          groupBy: {
            args: Prisma.TaskDependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskDependencyCountArgs<ExtArgs>
            result: $Utils.Optional<TaskDependencyCountAggregateOutputType> | number
          }
        }
      }
      TimeLog: {
        payload: Prisma.$TimeLogPayload<ExtArgs>
        fields: Prisma.TimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findFirst: {
            args: Prisma.TimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findMany: {
            args: Prisma.TimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          create: {
            args: Prisma.TimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          createMany: {
            args: Prisma.TimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          update: {
            args: Prisma.TimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          deleteMany: {
            args: Prisma.TimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          aggregate: {
            args: Prisma.TimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeLog>
          }
          groupBy: {
            args: Prisma.TimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TimeLogCountAggregateOutputType> | number
          }
        }
      }
      AutomationRule: {
        payload: Prisma.$AutomationRulePayload<ExtArgs>
        fields: Prisma.AutomationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findFirst: {
            args: Prisma.AutomationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          findMany: {
            args: Prisma.AutomationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>[]
          }
          create: {
            args: Prisma.AutomationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          createMany: {
            args: Prisma.AutomationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutomationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          update: {
            args: Prisma.AutomationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          deleteMany: {
            args: Prisma.AutomationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutomationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationRulePayload>
          }
          aggregate: {
            args: Prisma.AutomationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationRule>
          }
          groupBy: {
            args: Prisma.AutomationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationRuleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      ProjectUser: {
        payload: Prisma.$ProjectUserPayload<ExtArgs>
        fields: Prisma.ProjectUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          findFirst: {
            args: Prisma.ProjectUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          findMany: {
            args: Prisma.ProjectUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>[]
          }
          create: {
            args: Prisma.ProjectUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          createMany: {
            args: Prisma.ProjectUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          update: {
            args: Prisma.ProjectUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          deleteMany: {
            args: Prisma.ProjectUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUserPayload>
          }
          aggregate: {
            args: Prisma.ProjectUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectUser>
          }
          groupBy: {
            args: Prisma.ProjectUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectUserCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectUserCountAggregateOutputType> | number
          }
        }
      }
      ProjectPhase: {
        payload: Prisma.$ProjectPhasePayload<ExtArgs>
        fields: Prisma.ProjectPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          findFirst: {
            args: Prisma.ProjectPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          findMany: {
            args: Prisma.ProjectPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>[]
          }
          create: {
            args: Prisma.ProjectPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          createMany: {
            args: Prisma.ProjectPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          update: {
            args: Prisma.ProjectPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          deleteMany: {
            args: Prisma.ProjectPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPhasePayload>
          }
          aggregate: {
            args: Prisma.ProjectPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectPhase>
          }
          groupBy: {
            args: Prisma.ProjectPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectPhaseCountAggregateOutputType> | number
          }
        }
      }
      Deliverable: {
        payload: Prisma.$DeliverablePayload<ExtArgs>
        fields: Prisma.DeliverableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliverableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliverableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          findFirst: {
            args: Prisma.DeliverableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliverableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          findMany: {
            args: Prisma.DeliverableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>[]
          }
          create: {
            args: Prisma.DeliverableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          createMany: {
            args: Prisma.DeliverableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeliverableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          update: {
            args: Prisma.DeliverableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          deleteMany: {
            args: Prisma.DeliverableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliverableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliverableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliverablePayload>
          }
          aggregate: {
            args: Prisma.DeliverableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliverable>
          }
          groupBy: {
            args: Prisma.DeliverableGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliverableGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliverableCountArgs<ExtArgs>
            result: $Utils.Optional<DeliverableCountAggregateOutputType> | number
          }
        }
      }
      ScopeHistory: {
        payload: Prisma.$ScopeHistoryPayload<ExtArgs>
        fields: Prisma.ScopeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScopeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScopeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          findFirst: {
            args: Prisma.ScopeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScopeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          findMany: {
            args: Prisma.ScopeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>[]
          }
          create: {
            args: Prisma.ScopeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          createMany: {
            args: Prisma.ScopeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScopeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          update: {
            args: Prisma.ScopeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ScopeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScopeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScopeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScopeHistoryPayload>
          }
          aggregate: {
            args: Prisma.ScopeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScopeHistory>
          }
          groupBy: {
            args: Prisma.ScopeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScopeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScopeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ScopeHistoryCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      SettingsChangeLog: {
        payload: Prisma.$SettingsChangeLogPayload<ExtArgs>
        fields: Prisma.SettingsChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          findFirst: {
            args: Prisma.SettingsChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          findMany: {
            args: Prisma.SettingsChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>[]
          }
          create: {
            args: Prisma.SettingsChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          createMany: {
            args: Prisma.SettingsChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingsChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          update: {
            args: Prisma.SettingsChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.SettingsChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsChangeLogPayload>
          }
          aggregate: {
            args: Prisma.SettingsChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingsChangeLog>
          }
          groupBy: {
            args: Prisma.SettingsChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsChangeLogCountAggregateOutputType> | number
          }
        }
      }
      ProjectSetting: {
        payload: Prisma.$ProjectSettingPayload<ExtArgs>
        fields: Prisma.ProjectSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          findFirst: {
            args: Prisma.ProjectSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          findMany: {
            args: Prisma.ProjectSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>[]
          }
          create: {
            args: Prisma.ProjectSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          createMany: {
            args: Prisma.ProjectSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          update: {
            args: Prisma.ProjectSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingPayload>
          }
          aggregate: {
            args: Prisma.ProjectSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSetting>
          }
          groupBy: {
            args: Prisma.ProjectSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSettingCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingCountAggregateOutputType> | number
          }
        }
      }
      ProjectSettingsChangeLog: {
        payload: Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>
        fields: Prisma.ProjectSettingsChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSettingsChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ProjectSettingsChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSettingsChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          findMany: {
            args: Prisma.ProjectSettingsChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>[]
          }
          create: {
            args: Prisma.ProjectSettingsChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          createMany: {
            args: Prisma.ProjectSettingsChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectSettingsChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          update: {
            args: Prisma.ProjectSettingsChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSettingsChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSettingsChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectSettingsChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSettingsChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ProjectSettingsChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSettingsChangeLog>
          }
          groupBy: {
            args: Prisma.ProjectSettingsChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingsChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSettingsChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSettingsChangeLogCountAggregateOutputType> | number
          }
        }
      }
      UserSetting: {
        payload: Prisma.$UserSettingPayload<ExtArgs>
        fields: Prisma.UserSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findFirst: {
            args: Prisma.UserSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findMany: {
            args: Prisma.UserSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          create: {
            args: Prisma.UserSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          createMany: {
            args: Prisma.UserSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          update: {
            args: Prisma.UserSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          aggregate: {
            args: Prisma.UserSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSetting>
          }
          groupBy: {
            args: Prisma.UserSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingCountAggregateOutputType> | number
          }
        }
      }
      UserSettingsChangeLog: {
        payload: Prisma.$UserSettingsChangeLogPayload<ExtArgs>
        fields: Prisma.UserSettingsChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          findMany: {
            args: Prisma.UserSettingsChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>[]
          }
          create: {
            args: Prisma.UserSettingsChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          createMany: {
            args: Prisma.UserSettingsChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSettingsChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          update: {
            args: Prisma.UserSettingsChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsChangeLogPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettingsChangeLog>
          }
          groupBy: {
            args: Prisma.UserSettingsChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsChangeLogCountAggregateOutputType> | number
          }
        }
      }
      ProjectNotification: {
        payload: Prisma.$ProjectNotificationPayload<ExtArgs>
        fields: Prisma.ProjectNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          findFirst: {
            args: Prisma.ProjectNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          findMany: {
            args: Prisma.ProjectNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>[]
          }
          create: {
            args: Prisma.ProjectNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          createMany: {
            args: Prisma.ProjectNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          update: {
            args: Prisma.ProjectNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ProjectNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPayload>
          }
          aggregate: {
            args: Prisma.ProjectNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectNotification>
          }
          groupBy: {
            args: Prisma.ProjectNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotificationCountAggregateOutputType> | number
          }
        }
      }
      UrgentProjectAcknowledgement: {
        payload: Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>
        fields: Prisma.UrgentProjectAcknowledgementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UrgentProjectAcknowledgementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UrgentProjectAcknowledgementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          findFirst: {
            args: Prisma.UrgentProjectAcknowledgementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UrgentProjectAcknowledgementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          findMany: {
            args: Prisma.UrgentProjectAcknowledgementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>[]
          }
          create: {
            args: Prisma.UrgentProjectAcknowledgementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          createMany: {
            args: Prisma.UrgentProjectAcknowledgementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UrgentProjectAcknowledgementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          update: {
            args: Prisma.UrgentProjectAcknowledgementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          deleteMany: {
            args: Prisma.UrgentProjectAcknowledgementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UrgentProjectAcknowledgementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UrgentProjectAcknowledgementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UrgentProjectAcknowledgementPayload>
          }
          aggregate: {
            args: Prisma.UrgentProjectAcknowledgementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUrgentProjectAcknowledgement>
          }
          groupBy: {
            args: Prisma.UrgentProjectAcknowledgementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UrgentProjectAcknowledgementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UrgentProjectAcknowledgementCountArgs<ExtArgs>
            result: $Utils.Optional<UrgentProjectAcknowledgementCountAggregateOutputType> | number
          }
        }
      }
      ProjectNotificationPreference: {
        payload: Prisma.$ProjectNotificationPreferencePayload<ExtArgs>
        fields: Prisma.ProjectNotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectNotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectNotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.ProjectNotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectNotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.ProjectNotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.ProjectNotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.ProjectNotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectNotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          update: {
            args: Prisma.ProjectNotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.ProjectNotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectNotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectNotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectNotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.ProjectNotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectNotificationPreference>
          }
          groupBy: {
            args: Prisma.ProjectNotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectNotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectNotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      ProjectTeam: {
        payload: Prisma.$ProjectTeamPayload<ExtArgs>
        fields: Prisma.ProjectTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          findFirst: {
            args: Prisma.ProjectTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          findMany: {
            args: Prisma.ProjectTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>[]
          }
          create: {
            args: Prisma.ProjectTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          createMany: {
            args: Prisma.ProjectTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          update: {
            args: Prisma.ProjectTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTeamPayload>
          }
          aggregate: {
            args: Prisma.ProjectTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTeam>
          }
          groupBy: {
            args: Prisma.ProjectTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTeamCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTeamCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      ProjectType: {
        payload: Prisma.$ProjectTypePayload<ExtArgs>
        fields: Prisma.ProjectTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findFirst: {
            args: Prisma.ProjectTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          findMany: {
            args: Prisma.ProjectTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>[]
          }
          create: {
            args: Prisma.ProjectTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          createMany: {
            args: Prisma.ProjectTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          update: {
            args: Prisma.ProjectTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          deleteMany: {
            args: Prisma.ProjectTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTypePayload>
          }
          aggregate: {
            args: Prisma.ProjectTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectType>
          }
          groupBy: {
            args: Prisma.ProjectTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTypeCountAggregateOutputType> | number
          }
        }
      }
      ProjectStatus: {
        payload: Prisma.$ProjectStatusPayload<ExtArgs>
        fields: Prisma.ProjectStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          findFirst: {
            args: Prisma.ProjectStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          findMany: {
            args: Prisma.ProjectStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>[]
          }
          create: {
            args: Prisma.ProjectStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          createMany: {
            args: Prisma.ProjectStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          update: {
            args: Prisma.ProjectStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          deleteMany: {
            args: Prisma.ProjectStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusPayload>
          }
          aggregate: {
            args: Prisma.ProjectStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStatus>
          }
          groupBy: {
            args: Prisma.ProjectStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusCountAggregateOutputType> | number
          }
        }
      }
      TaskStatus: {
        payload: Prisma.$TaskStatusPayload<ExtArgs>
        fields: Prisma.TaskStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findFirst: {
            args: Prisma.TaskStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          findMany: {
            args: Prisma.TaskStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>[]
          }
          create: {
            args: Prisma.TaskStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          createMany: {
            args: Prisma.TaskStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          update: {
            args: Prisma.TaskStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          deleteMany: {
            args: Prisma.TaskStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskStatusPayload>
          }
          aggregate: {
            args: Prisma.TaskStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskStatus>
          }
          groupBy: {
            args: Prisma.TaskStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TaskStatusCountAggregateOutputType> | number
          }
        }
      }
      StatSnapshot: {
        payload: Prisma.$StatSnapshotPayload<ExtArgs>
        fields: Prisma.StatSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          findFirst: {
            args: Prisma.StatSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          findMany: {
            args: Prisma.StatSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>[]
          }
          create: {
            args: Prisma.StatSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          createMany: {
            args: Prisma.StatSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StatSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          update: {
            args: Prisma.StatSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.StatSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatSnapshotPayload>
          }
          aggregate: {
            args: Prisma.StatSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatSnapshot>
          }
          groupBy: {
            args: Prisma.StatSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<StatSnapshotCountAggregateOutputType> | number
          }
        }
      }
      ProductivitySnapshot: {
        payload: Prisma.$ProductivitySnapshotPayload<ExtArgs>
        fields: Prisma.ProductivitySnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductivitySnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductivitySnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          findFirst: {
            args: Prisma.ProductivitySnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductivitySnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          findMany: {
            args: Prisma.ProductivitySnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>[]
          }
          create: {
            args: Prisma.ProductivitySnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          createMany: {
            args: Prisma.ProductivitySnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductivitySnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          update: {
            args: Prisma.ProductivitySnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          deleteMany: {
            args: Prisma.ProductivitySnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductivitySnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductivitySnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductivitySnapshotPayload>
          }
          aggregate: {
            args: Prisma.ProductivitySnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductivitySnapshot>
          }
          groupBy: {
            args: Prisma.ProductivitySnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductivitySnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductivitySnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<ProductivitySnapshotCountAggregateOutputType> | number
          }
        }
      }
      ForecastSnapshot: {
        payload: Prisma.$ForecastSnapshotPayload<ExtArgs>
        fields: Prisma.ForecastSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForecastSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForecastSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          findFirst: {
            args: Prisma.ForecastSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForecastSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          findMany: {
            args: Prisma.ForecastSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>[]
          }
          create: {
            args: Prisma.ForecastSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          createMany: {
            args: Prisma.ForecastSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ForecastSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          update: {
            args: Prisma.ForecastSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.ForecastSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForecastSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForecastSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForecastSnapshotPayload>
          }
          aggregate: {
            args: Prisma.ForecastSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForecastSnapshot>
          }
          groupBy: {
            args: Prisma.ForecastSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForecastSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForecastSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<ForecastSnapshotCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    activityLogsPerformed: number
    activityLogsAffected: number
    activityLogs: number
    uploadedFiles: number
    createdRules: number
    comments: number
    commentMentions: number
    notifications: number
    projectNotificationPreferences: number
    projectNotifications: number
    projectSettingsUpdated: number
    projectSettingsChanged: number
    projectsManaged: number
    projectsMarkedUrgent: number
    settingsChanged: number
    createdSubtasks: number
    assignedSubtasks: number
    updatedSettings: number
    tasksCreated: number
    timeLogs: number
    userSettingsUpdated: number
    userSettings: number
    userSettingsChanged: number
    userSettingsChangeLogs: number
    assignedTasks: number
    teamsLed: number
    teamMemberships: number
    roles: number
    assignedRoles: number
    urgentAcknowledgements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogsPerformed?: boolean | UserCountOutputTypeCountActivityLogsPerformedArgs
    activityLogsAffected?: boolean | UserCountOutputTypeCountActivityLogsAffectedArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    uploadedFiles?: boolean | UserCountOutputTypeCountUploadedFilesArgs
    createdRules?: boolean | UserCountOutputTypeCountCreatedRulesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    commentMentions?: boolean | UserCountOutputTypeCountCommentMentionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    projectNotificationPreferences?: boolean | UserCountOutputTypeCountProjectNotificationPreferencesArgs
    projectNotifications?: boolean | UserCountOutputTypeCountProjectNotificationsArgs
    projectSettingsUpdated?: boolean | UserCountOutputTypeCountProjectSettingsUpdatedArgs
    projectSettingsChanged?: boolean | UserCountOutputTypeCountProjectSettingsChangedArgs
    projectsManaged?: boolean | UserCountOutputTypeCountProjectsManagedArgs
    projectsMarkedUrgent?: boolean | UserCountOutputTypeCountProjectsMarkedUrgentArgs
    settingsChanged?: boolean | UserCountOutputTypeCountSettingsChangedArgs
    createdSubtasks?: boolean | UserCountOutputTypeCountCreatedSubtasksArgs
    assignedSubtasks?: boolean | UserCountOutputTypeCountAssignedSubtasksArgs
    updatedSettings?: boolean | UserCountOutputTypeCountUpdatedSettingsArgs
    tasksCreated?: boolean | UserCountOutputTypeCountTasksCreatedArgs
    timeLogs?: boolean | UserCountOutputTypeCountTimeLogsArgs
    userSettingsUpdated?: boolean | UserCountOutputTypeCountUserSettingsUpdatedArgs
    userSettings?: boolean | UserCountOutputTypeCountUserSettingsArgs
    userSettingsChanged?: boolean | UserCountOutputTypeCountUserSettingsChangedArgs
    userSettingsChangeLogs?: boolean | UserCountOutputTypeCountUserSettingsChangeLogsArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    teamsLed?: boolean | UserCountOutputTypeCountTeamsLedArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    assignedRoles?: boolean | UserCountOutputTypeCountAssignedRolesArgs
    urgentAcknowledgements?: boolean | UserCountOutputTypeCountUrgentAcknowledgementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsPerformedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentMentionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectSettingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingsChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsMarkedUrgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSettingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSettingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSettingsChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsLedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUrgentAcknowledgementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UrgentProjectAcknowledgementWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    rules: number
    subtasks: number
    tasks: number
    users: number
    members: number
    projectTeams: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | TeamCountOutputTypeCountRulesArgs
    subtasks?: boolean | TeamCountOutputTypeCountSubtasksArgs
    tasks?: boolean | TeamCountOutputTypeCountTasksArgs
    users?: boolean | TeamCountOutputTypeCountUsersArgs
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    projectTeams?: boolean | TeamCountOutputTypeCountProjectTeamsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountProjectTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    deliverables: number
    notificationPreferences: number
    notifications: number
    phases: number
    settings: number
    settingsLogs: number
    projectUsers: number
    scopeHistory: number
    tasks: number
    activityLogs: number
    projectTeams: number
    urgentAcknowledgments: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliverables?: boolean | ProjectCountOutputTypeCountDeliverablesArgs
    notificationPreferences?: boolean | ProjectCountOutputTypeCountNotificationPreferencesArgs
    notifications?: boolean | ProjectCountOutputTypeCountNotificationsArgs
    phases?: boolean | ProjectCountOutputTypeCountPhasesArgs
    settings?: boolean | ProjectCountOutputTypeCountSettingsArgs
    settingsLogs?: boolean | ProjectCountOutputTypeCountSettingsLogsArgs
    projectUsers?: boolean | ProjectCountOutputTypeCountProjectUsersArgs
    scopeHistory?: boolean | ProjectCountOutputTypeCountScopeHistoryArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    activityLogs?: boolean | ProjectCountOutputTypeCountActivityLogsArgs
    projectTeams?: boolean | ProjectCountOutputTypeCountProjectTeamsArgs
    urgentAcknowledgments?: boolean | ProjectCountOutputTypeCountUrgentAcknowledgmentsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDeliverablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliverableWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationPreferenceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSettingsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingsChangeLogWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUserWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountScopeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeHistoryWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUrgentAcknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UrgentProjectAcknowledgementWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    attachments: number
    comments: number
    subtasks: number
    dependents: number
    dependencies: number
    labels: number
    timeLogs: number
    assignees: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | TaskCountOutputTypeCountAttachmentsArgs
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
    subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs
    dependents?: boolean | TaskCountOutputTypeCountDependentsArgs
    dependencies?: boolean | TaskCountOutputTypeCountDependenciesArgs
    labels?: boolean | TaskCountOutputTypeCountLabelsArgs
    timeLogs?: boolean | TaskCountOutputTypeCountTimeLogsArgs
    assignees?: boolean | TaskCountOutputTypeCountAssigneesArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type SubtaskCountOutputType
   */

  export type SubtaskCountOutputType = {
    comments: number
    dependencies: number
    dependents: number
    timeLogs: number
  }

  export type SubtaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | SubtaskCountOutputTypeCountCommentsArgs
    dependencies?: boolean | SubtaskCountOutputTypeCountDependenciesArgs
    dependents?: boolean | SubtaskCountOutputTypeCountDependentsArgs
    timeLogs?: boolean | SubtaskCountOutputTypeCountTimeLogsArgs
  }

  // Custom InputTypes
  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskCountOutputType
     */
    select?: SubtaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeCountDependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskDependencyWhereInput
  }

  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskDependencyWhereInput
  }

  /**
   * SubtaskCountOutputType without action
   */
  export type SubtaskCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    mentions: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentions?: boolean | CommentCountOutputTypeCountMentionsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentMentionWhereInput
  }


  /**
   * Count Type LabelCountOutputType
   */

  export type LabelCountOutputType = {
    tasks: number
  }

  export type LabelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | LabelCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     */
    select?: LabelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
  }


  /**
   * Count Type DeliverableCountOutputType
   */

  export type DeliverableCountOutputType = {
    tasks: number
  }

  export type DeliverableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | DeliverableCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * DeliverableCountOutputType without action
   */
  export type DeliverableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverableCountOutputType
     */
    select?: DeliverableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliverableCountOutputType without action
   */
  export type DeliverableCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type SystemSettingCountOutputType
   */

  export type SystemSettingCountOutputType = {
    changeLogs: number
  }

  export type SystemSettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | SystemSettingCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * SystemSettingCountOutputType without action
   */
  export type SystemSettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettingCountOutputType
     */
    select?: SystemSettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemSettingCountOutputType without action
   */
  export type SystemSettingCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsChangeLogWhereInput
  }


  /**
   * Count Type ProjectSettingCountOutputType
   */

  export type ProjectSettingCountOutputType = {
    changeLogs: number
  }

  export type ProjectSettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | ProjectSettingCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * ProjectSettingCountOutputType without action
   */
  export type ProjectSettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingCountOutputType
     */
    select?: ProjectSettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectSettingCountOutputType without action
   */
  export type ProjectSettingCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingsChangeLogWhereInput
  }


  /**
   * Count Type UserSettingCountOutputType
   */

  export type UserSettingCountOutputType = {
    changeLogs: number
  }

  export type UserSettingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | UserSettingCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * UserSettingCountOutputType without action
   */
  export type UserSettingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingCountOutputType
     */
    select?: UserSettingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserSettingCountOutputType without action
   */
  export type UserSettingCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsChangeLogWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type ProjectTypeCountOutputType
   */

  export type ProjectTypeCountOutputType = {
    projects: number
  }

  export type ProjectTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectTypeCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectTypeCountOutputType without action
   */
  export type ProjectTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTypeCountOutputType
     */
    select?: ProjectTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectTypeCountOutputType without action
   */
  export type ProjectTypeCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectStatusCountOutputType
   */

  export type ProjectStatusCountOutputType = {
    projects: number
  }

  export type ProjectStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectStatusCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * ProjectStatusCountOutputType without action
   */
  export type ProjectStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusCountOutputType
     */
    select?: ProjectStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectStatusCountOutputType without action
   */
  export type ProjectStatusCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type TaskStatusCountOutputType
   */

  export type TaskStatusCountOutputType = {
    tasks: number
  }

  export type TaskStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatusCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatusCountOutputType
     */
    select?: TaskStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskStatusCountOutputType without action
   */
  export type TaskStatusCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    teamId: number | null
    avatarUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    teamId: number | null
    avatarUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    role: number
    isActive: number
    createdAt: number
    teamId: number
    avatarUrl: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    teamId?: true
    avatarUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    teamId?: true
    avatarUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    createdAt?: true
    teamId?: true
    avatarUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    passwordHash: string
    role: string
    isActive: boolean
    createdAt: Date
    teamId: number | null
    avatarUrl: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    teamId?: boolean
    avatarUrl?: boolean
    activityLogsPerformed?: boolean | User$activityLogsPerformedArgs<ExtArgs>
    activityLogsAffected?: boolean | User$activityLogsAffectedArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    createdRules?: boolean | User$createdRulesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    commentMentions?: boolean | User$commentMentionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    projectNotificationPreferences?: boolean | User$projectNotificationPreferencesArgs<ExtArgs>
    projectNotifications?: boolean | User$projectNotificationsArgs<ExtArgs>
    projectSettingsUpdated?: boolean | User$projectSettingsUpdatedArgs<ExtArgs>
    projectSettingsChanged?: boolean | User$projectSettingsChangedArgs<ExtArgs>
    projectsManaged?: boolean | User$projectsManagedArgs<ExtArgs>
    projectsMarkedUrgent?: boolean | User$projectsMarkedUrgentArgs<ExtArgs>
    settingsChanged?: boolean | User$settingsChangedArgs<ExtArgs>
    createdSubtasks?: boolean | User$createdSubtasksArgs<ExtArgs>
    assignedSubtasks?: boolean | User$assignedSubtasksArgs<ExtArgs>
    updatedSettings?: boolean | User$updatedSettingsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    userSettingsUpdated?: boolean | User$userSettingsUpdatedArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    userSettingsChanged?: boolean | User$userSettingsChangedArgs<ExtArgs>
    userSettingsChangeLogs?: boolean | User$userSettingsChangeLogsArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    teamsLed?: boolean | User$teamsLedArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    urgentAcknowledgements?: boolean | User$urgentAcknowledgementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    teamId?: boolean
    avatarUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityLogsPerformed?: boolean | User$activityLogsPerformedArgs<ExtArgs>
    activityLogsAffected?: boolean | User$activityLogsAffectedArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>
    createdRules?: boolean | User$createdRulesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    commentMentions?: boolean | User$commentMentionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    projectNotificationPreferences?: boolean | User$projectNotificationPreferencesArgs<ExtArgs>
    projectNotifications?: boolean | User$projectNotificationsArgs<ExtArgs>
    projectSettingsUpdated?: boolean | User$projectSettingsUpdatedArgs<ExtArgs>
    projectSettingsChanged?: boolean | User$projectSettingsChangedArgs<ExtArgs>
    projectsManaged?: boolean | User$projectsManagedArgs<ExtArgs>
    projectsMarkedUrgent?: boolean | User$projectsMarkedUrgentArgs<ExtArgs>
    settingsChanged?: boolean | User$settingsChangedArgs<ExtArgs>
    createdSubtasks?: boolean | User$createdSubtasksArgs<ExtArgs>
    assignedSubtasks?: boolean | User$assignedSubtasksArgs<ExtArgs>
    updatedSettings?: boolean | User$updatedSettingsArgs<ExtArgs>
    tasksCreated?: boolean | User$tasksCreatedArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    userSettingsUpdated?: boolean | User$userSettingsUpdatedArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    userSettingsChanged?: boolean | User$userSettingsChangedArgs<ExtArgs>
    userSettingsChangeLogs?: boolean | User$userSettingsChangeLogsArgs<ExtArgs>
    team?: boolean | User$teamArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    teamsLed?: boolean | User$teamsLedArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    urgentAcknowledgements?: boolean | User$urgentAcknowledgementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      activityLogsPerformed: Prisma.$ActivityLogPayload<ExtArgs>[]
      activityLogsAffected: Prisma.$ActivityLogPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      uploadedFiles: Prisma.$AttachmentPayload<ExtArgs>[]
      createdRules: Prisma.$AutomationRulePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      commentMentions: Prisma.$CommentMentionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      projectNotificationPreferences: Prisma.$ProjectNotificationPreferencePayload<ExtArgs>[]
      projectNotifications: Prisma.$ProjectNotificationPayload<ExtArgs>[]
      projectSettingsUpdated: Prisma.$ProjectSettingPayload<ExtArgs>[]
      projectSettingsChanged: Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>[]
      projectsManaged: Prisma.$ProjectPayload<ExtArgs>[]
      projectsMarkedUrgent: Prisma.$ProjectPayload<ExtArgs>[]
      settingsChanged: Prisma.$SettingsChangeLogPayload<ExtArgs>[]
      createdSubtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      assignedSubtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      updatedSettings: Prisma.$SystemSettingPayload<ExtArgs>[]
      tasksCreated: Prisma.$TaskPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      userSettingsUpdated: Prisma.$UserSettingPayload<ExtArgs>[]
      userSettings: Prisma.$UserSettingPayload<ExtArgs>[]
      userSettingsChanged: Prisma.$UserSettingsChangeLogPayload<ExtArgs>[]
      userSettingsChangeLogs: Prisma.$UserSettingsChangeLogPayload<ExtArgs>[]
      team: Prisma.$TeamPayload<ExtArgs> | null
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      teamsLed: Prisma.$TeamPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      assignedRoles: Prisma.$UserRolePayload<ExtArgs>[]
      urgentAcknowledgements: Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      passwordHash: string
      role: string
      isActive: boolean
      createdAt: Date
      teamId: number | null
      avatarUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityLogsPerformed<T extends User$activityLogsPerformedArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsPerformedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    activityLogsAffected<T extends User$activityLogsAffectedArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsAffectedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedFiles<T extends User$uploadedFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    createdRules<T extends User$createdRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    commentMentions<T extends User$commentMentionsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentMentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    projectNotificationPreferences<T extends User$projectNotificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$projectNotificationPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findMany"> | Null>
    projectNotifications<T extends User$projectNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    projectSettingsUpdated<T extends User$projectSettingsUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$projectSettingsUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findMany"> | Null>
    projectSettingsChanged<T extends User$projectSettingsChangedArgs<ExtArgs> = {}>(args?: Subset<T, User$projectSettingsChangedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    projectsManaged<T extends User$projectsManagedArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsManagedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    projectsMarkedUrgent<T extends User$projectsMarkedUrgentArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsMarkedUrgentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    settingsChanged<T extends User$settingsChangedArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsChangedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    createdSubtasks<T extends User$createdSubtasksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSubtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany"> | Null>
    assignedSubtasks<T extends User$assignedSubtasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedSubtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany"> | Null>
    updatedSettings<T extends User$updatedSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany"> | Null>
    tasksCreated<T extends User$tasksCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    timeLogs<T extends User$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany"> | Null>
    userSettingsUpdated<T extends User$userSettingsUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany"> | Null>
    userSettings<T extends User$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany"> | Null>
    userSettingsChanged<T extends User$userSettingsChangedArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsChangedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    userSettingsChangeLogs<T extends User$userSettingsChangeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsChangeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    team<T extends User$teamArgs<ExtArgs> = {}>(args?: Subset<T, User$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    teamsLed<T extends User$teamsLedArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsLedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    assignedRoles<T extends User$assignedRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    urgentAcknowledgements<T extends User$urgentAcknowledgementsArgs<ExtArgs> = {}>(args?: Subset<T, User$urgentAcknowledgementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly teamId: FieldRef<"User", 'Int'>
    readonly avatarUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.activityLogsPerformed
   */
  export type User$activityLogsPerformedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.activityLogsAffected
   */
  export type User$activityLogsAffectedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.uploadedFiles
   */
  export type User$uploadedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * User.createdRules
   */
  export type User$createdRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    cursor?: AutomationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.commentMentions
   */
  export type User$commentMentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    where?: CommentMentionWhereInput
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    cursor?: CommentMentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentMentionScalarFieldEnum | CommentMentionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.projectNotificationPreferences
   */
  export type User$projectNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    where?: ProjectNotificationPreferenceWhereInput
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectNotificationPreferenceScalarFieldEnum | ProjectNotificationPreferenceScalarFieldEnum[]
  }

  /**
   * User.projectNotifications
   */
  export type User$projectNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    where?: ProjectNotificationWhereInput
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    cursor?: ProjectNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectNotificationScalarFieldEnum | ProjectNotificationScalarFieldEnum[]
  }

  /**
   * User.projectSettingsUpdated
   */
  export type User$projectSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    where?: ProjectSettingWhereInput
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    cursor?: ProjectSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingScalarFieldEnum | ProjectSettingScalarFieldEnum[]
  }

  /**
   * User.projectSettingsChanged
   */
  export type User$projectSettingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    where?: ProjectSettingsChangeLogWhereInput
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * User.projectsManaged
   */
  export type User$projectsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectsMarkedUrgent
   */
  export type User$projectsMarkedUrgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.settingsChanged
   */
  export type User$settingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    where?: SettingsChangeLogWhereInput
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    cursor?: SettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsChangeLogScalarFieldEnum | SettingsChangeLogScalarFieldEnum[]
  }

  /**
   * User.createdSubtasks
   */
  export type User$createdSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * User.assignedSubtasks
   */
  export type User$assignedSubtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * User.updatedSettings
   */
  export type User$updatedSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    cursor?: SystemSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * User.tasksCreated
   */
  export type User$tasksCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.timeLogs
   */
  export type User$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * User.userSettingsUpdated
   */
  export type User$userSettingsUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    cursor?: UserSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * User.userSettings
   */
  export type User$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    cursor?: UserSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * User.userSettingsChanged
   */
  export type User$userSettingsChangedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    where?: UserSettingsChangeLogWhereInput
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    cursor?: UserSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * User.userSettingsChangeLogs
   */
  export type User$userSettingsChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    where?: UserSettingsChangeLogWhereInput
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    cursor?: UserSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * User.team
   */
  export type User$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.teamsLed
   */
  export type User$teamsLedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.assignedRoles
   */
  export type User$assignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.urgentAcknowledgements
   */
  export type User$urgentAcknowledgementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    where?: UrgentProjectAcknowledgementWhereInput
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UrgentProjectAcknowledgementScalarFieldEnum | UrgentProjectAcknowledgementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    teamLeadId: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    teamLeadId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    teamLeadId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    teamLeadId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    teamLeadId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    teamLeadId?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    teamLeadId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamLeadId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamLeadId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    teamLeadId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    description: string | null
    teamLeadId: number | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    teamLeadId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rules?: boolean | Team$rulesArgs<ExtArgs>
    subtasks?: boolean | Team$subtasksArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    users?: boolean | Team$usersArgs<ExtArgs>
    teamLead?: boolean | Team$teamLeadArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    projectTeams?: boolean | Team$projectTeamsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>


  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    teamLeadId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | Team$rulesArgs<ExtArgs>
    subtasks?: boolean | Team$subtasksArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    users?: boolean | Team$usersArgs<ExtArgs>
    teamLead?: boolean | Team$teamLeadArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    projectTeams?: boolean | Team$projectTeamsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      rules: Prisma.$AutomationRulePayload<ExtArgs>[]
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      teamLead: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      projectTeams: Prisma.$ProjectTeamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      teamLeadId: number | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rules<T extends Team$rulesArgs<ExtArgs> = {}>(args?: Subset<T, Team$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany"> | Null>
    subtasks<T extends Team$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Team$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Team$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Team$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Team$usersArgs<ExtArgs> = {}>(args?: Subset<T, Team$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    teamLead<T extends Team$teamLeadArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamLeadArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    projectTeams<T extends Team$projectTeamsArgs<ExtArgs> = {}>(args?: Subset<T, Team$projectTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly teamLeadId: FieldRef<"Team", 'Int'>
    readonly status: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.rules
   */
  export type Team$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    cursor?: AutomationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * Team.subtasks
   */
  export type Team$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Team.tasks
   */
  export type Team$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Team.users
   */
  export type Team$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Team.teamLead
   */
  export type Team$teamLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.projectTeams
   */
  export type Team$projectTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    where?: ProjectTeamWhereInput
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    cursor?: ProjectTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTeamScalarFieldEnum | ProjectTeamScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    projectTypeId: number | null
    projectStatusId: number | null
    urgentMarkedById: number | null
    projectManagerId: number | null
    createdById: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    projectTypeId: number | null
    projectStatusId: number | null
    urgentMarkedById: number | null
    projectManagerId: number | null
    createdById: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    projectTypeId: number | null
    projectStatusId: number | null
    description: string | null
    scope: string | null
    status: string | null
    priority: string | null
    urgentReason: string | null
    urgentMarkedAt: Date | null
    urgentMarkedById: number | null
    startDate: Date | null
    endDate: Date | null
    projectManagerId: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    projectTypeId: number | null
    projectStatusId: number | null
    description: string | null
    scope: string | null
    status: string | null
    priority: string | null
    urgentReason: string | null
    urgentMarkedAt: Date | null
    urgentMarkedById: number | null
    startDate: Date | null
    endDate: Date | null
    projectManagerId: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    type: number
    projectTypeId: number
    projectStatusId: number
    description: number
    scope: number
    status: number
    priority: number
    urgentReason: number
    urgentMarkedAt: number
    urgentMarkedById: number
    startDate: number
    endDate: number
    projectManagerId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    projectTypeId?: true
    projectStatusId?: true
    urgentMarkedById?: true
    projectManagerId?: true
    createdById?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    projectTypeId?: true
    projectStatusId?: true
    urgentMarkedById?: true
    projectManagerId?: true
    createdById?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    projectTypeId?: true
    projectStatusId?: true
    description?: true
    scope?: true
    status?: true
    priority?: true
    urgentReason?: true
    urgentMarkedAt?: true
    urgentMarkedById?: true
    startDate?: true
    endDate?: true
    projectManagerId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    projectTypeId?: true
    projectStatusId?: true
    description?: true
    scope?: true
    status?: true
    priority?: true
    urgentReason?: true
    urgentMarkedAt?: true
    urgentMarkedById?: true
    startDate?: true
    endDate?: true
    projectManagerId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    projectTypeId?: true
    projectStatusId?: true
    description?: true
    scope?: true
    status?: true
    priority?: true
    urgentReason?: true
    urgentMarkedAt?: true
    urgentMarkedById?: true
    startDate?: true
    endDate?: true
    projectManagerId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    name: string
    type: string
    projectTypeId: number | null
    projectStatusId: number | null
    description: string | null
    scope: string | null
    status: string
    priority: string
    urgentReason: string | null
    urgentMarkedAt: Date | null
    urgentMarkedById: number | null
    startDate: Date | null
    endDate: Date | null
    projectManagerId: number | null
    createdById: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    projectTypeId?: boolean
    projectStatusId?: boolean
    description?: boolean
    scope?: boolean
    status?: boolean
    priority?: boolean
    urgentReason?: boolean
    urgentMarkedAt?: boolean
    urgentMarkedById?: boolean
    startDate?: boolean
    endDate?: boolean
    projectManagerId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliverables?: boolean | Project$deliverablesArgs<ExtArgs>
    notificationPreferences?: boolean | Project$notificationPreferencesArgs<ExtArgs>
    notifications?: boolean | Project$notificationsArgs<ExtArgs>
    phases?: boolean | Project$phasesArgs<ExtArgs>
    settings?: boolean | Project$settingsArgs<ExtArgs>
    settingsLogs?: boolean | Project$settingsLogsArgs<ExtArgs>
    projectUsers?: boolean | Project$projectUsersArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    urgentMarkedBy?: boolean | Project$urgentMarkedByArgs<ExtArgs>
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
    projectStatus?: boolean | Project$projectStatusArgs<ExtArgs>
    scopeHistory?: boolean | Project$scopeHistoryArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    activityLogs?: boolean | Project$activityLogsArgs<ExtArgs>
    projectTeams?: boolean | Project$projectTeamsArgs<ExtArgs>
    urgentAcknowledgments?: boolean | Project$urgentAcknowledgmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>


  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    projectTypeId?: boolean
    projectStatusId?: boolean
    description?: boolean
    scope?: boolean
    status?: boolean
    priority?: boolean
    urgentReason?: boolean
    urgentMarkedAt?: boolean
    urgentMarkedById?: boolean
    startDate?: boolean
    endDate?: boolean
    projectManagerId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliverables?: boolean | Project$deliverablesArgs<ExtArgs>
    notificationPreferences?: boolean | Project$notificationPreferencesArgs<ExtArgs>
    notifications?: boolean | Project$notificationsArgs<ExtArgs>
    phases?: boolean | Project$phasesArgs<ExtArgs>
    settings?: boolean | Project$settingsArgs<ExtArgs>
    settingsLogs?: boolean | Project$settingsLogsArgs<ExtArgs>
    projectUsers?: boolean | Project$projectUsersArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    urgentMarkedBy?: boolean | Project$urgentMarkedByArgs<ExtArgs>
    projectType?: boolean | Project$projectTypeArgs<ExtArgs>
    projectStatus?: boolean | Project$projectStatusArgs<ExtArgs>
    scopeHistory?: boolean | Project$scopeHistoryArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    activityLogs?: boolean | Project$activityLogsArgs<ExtArgs>
    projectTeams?: boolean | Project$projectTeamsArgs<ExtArgs>
    urgentAcknowledgments?: boolean | Project$urgentAcknowledgmentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      deliverables: Prisma.$DeliverablePayload<ExtArgs>[]
      notificationPreferences: Prisma.$ProjectNotificationPreferencePayload<ExtArgs>[]
      notifications: Prisma.$ProjectNotificationPayload<ExtArgs>[]
      phases: Prisma.$ProjectPhasePayload<ExtArgs>[]
      settings: Prisma.$ProjectSettingPayload<ExtArgs>[]
      settingsLogs: Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>[]
      projectUsers: Prisma.$ProjectUserPayload<ExtArgs>[]
      projectManager: Prisma.$UserPayload<ExtArgs> | null
      urgentMarkedBy: Prisma.$UserPayload<ExtArgs> | null
      projectType: Prisma.$ProjectTypePayload<ExtArgs> | null
      projectStatus: Prisma.$ProjectStatusPayload<ExtArgs> | null
      scopeHistory: Prisma.$ScopeHistoryPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      projectTeams: Prisma.$ProjectTeamPayload<ExtArgs>[]
      urgentAcknowledgments: Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      projectTypeId: number | null
      projectStatusId: number | null
      description: string | null
      scope: string | null
      status: string
      priority: string
      urgentReason: string | null
      urgentMarkedAt: Date | null
      urgentMarkedById: number | null
      startDate: Date | null
      endDate: Date | null
      projectManagerId: number | null
      createdById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliverables<T extends Project$deliverablesArgs<ExtArgs> = {}>(args?: Subset<T, Project$deliverablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findMany"> | Null>
    notificationPreferences<T extends Project$notificationPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, Project$notificationPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Project$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    phases<T extends Project$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Project$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends Project$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Project$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findMany"> | Null>
    settingsLogs<T extends Project$settingsLogsArgs<ExtArgs> = {}>(args?: Subset<T, Project$settingsLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    projectUsers<T extends Project$projectUsersArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findMany"> | Null>
    projectManager<T extends Project$projectManagerArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectManagerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    urgentMarkedBy<T extends Project$urgentMarkedByArgs<ExtArgs> = {}>(args?: Subset<T, Project$urgentMarkedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    projectType<T extends Project$projectTypeArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectTypeArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    projectStatus<T extends Project$projectStatusArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectStatusArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    scopeHistory<T extends Project$scopeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Project$scopeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends Project$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Project$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    projectTeams<T extends Project$projectTeamsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findMany"> | Null>
    urgentAcknowledgments<T extends Project$urgentAcknowledgmentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$urgentAcknowledgmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly name: FieldRef<"Project", 'String'>
    readonly type: FieldRef<"Project", 'String'>
    readonly projectTypeId: FieldRef<"Project", 'Int'>
    readonly projectStatusId: FieldRef<"Project", 'Int'>
    readonly description: FieldRef<"Project", 'String'>
    readonly scope: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly priority: FieldRef<"Project", 'String'>
    readonly urgentReason: FieldRef<"Project", 'String'>
    readonly urgentMarkedAt: FieldRef<"Project", 'DateTime'>
    readonly urgentMarkedById: FieldRef<"Project", 'Int'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly projectManagerId: FieldRef<"Project", 'Int'>
    readonly createdById: FieldRef<"Project", 'Int'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.deliverables
   */
  export type Project$deliverablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    where?: DeliverableWhereInput
    orderBy?: DeliverableOrderByWithRelationInput | DeliverableOrderByWithRelationInput[]
    cursor?: DeliverableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliverableScalarFieldEnum | DeliverableScalarFieldEnum[]
  }

  /**
   * Project.notificationPreferences
   */
  export type Project$notificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    where?: ProjectNotificationPreferenceWhereInput
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectNotificationPreferenceScalarFieldEnum | ProjectNotificationPreferenceScalarFieldEnum[]
  }

  /**
   * Project.notifications
   */
  export type Project$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    where?: ProjectNotificationWhereInput
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    cursor?: ProjectNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectNotificationScalarFieldEnum | ProjectNotificationScalarFieldEnum[]
  }

  /**
   * Project.phases
   */
  export type Project$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    where?: ProjectPhaseWhereInput
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    cursor?: ProjectPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * Project.settings
   */
  export type Project$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    where?: ProjectSettingWhereInput
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    cursor?: ProjectSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingScalarFieldEnum | ProjectSettingScalarFieldEnum[]
  }

  /**
   * Project.settingsLogs
   */
  export type Project$settingsLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    where?: ProjectSettingsChangeLogWhereInput
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * Project.projectUsers
   */
  export type Project$projectUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    where?: ProjectUserWhereInput
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    cursor?: ProjectUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * Project.projectManager
   */
  export type Project$projectManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.urgentMarkedBy
   */
  export type Project$urgentMarkedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.projectType
   */
  export type Project$projectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    where?: ProjectTypeWhereInput
  }

  /**
   * Project.projectStatus
   */
  export type Project$projectStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    where?: ProjectStatusWhereInput
  }

  /**
   * Project.scopeHistory
   */
  export type Project$scopeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    where?: ScopeHistoryWhereInput
    orderBy?: ScopeHistoryOrderByWithRelationInput | ScopeHistoryOrderByWithRelationInput[]
    cursor?: ScopeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScopeHistoryScalarFieldEnum | ScopeHistoryScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.activityLogs
   */
  export type Project$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Project.projectTeams
   */
  export type Project$projectTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    where?: ProjectTeamWhereInput
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    cursor?: ProjectTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTeamScalarFieldEnum | ProjectTeamScalarFieldEnum[]
  }

  /**
   * Project.urgentAcknowledgments
   */
  export type Project$urgentAcknowledgmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    where?: UrgentProjectAcknowledgementWhereInput
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UrgentProjectAcknowledgementScalarFieldEnum | UrgentProjectAcknowledgementScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    taskStatusId: number | null
    estimatedHours: number | null
    actualHours: number | null
    projectId: number | null
    teamId: number | null
    createdById: number | null
    deliverableId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    taskStatusId: number | null
    estimatedHours: number | null
    actualHours: number | null
    projectId: number | null
    teamId: number | null
    createdById: number | null
    deliverableId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    taskStatusId: number | null
    priority: string | null
    dueDate: Date | null
    plannedDate: Date | null
    estimatedHours: number | null
    actualHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
    teamId: number | null
    createdById: number | null
    deliverableId: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    taskStatusId: number | null
    priority: string | null
    dueDate: Date | null
    plannedDate: Date | null
    estimatedHours: number | null
    actualHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
    teamId: number | null
    createdById: number | null
    deliverableId: number | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    taskStatusId: number
    priority: number
    dueDate: number
    plannedDate: number
    estimatedHours: number
    actualHours: number
    createdAt: number
    updatedAt: number
    projectId: number
    teamId: number
    createdById: number
    deliverableId: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    taskStatusId?: true
    estimatedHours?: true
    actualHours?: true
    projectId?: true
    teamId?: true
    createdById?: true
    deliverableId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    taskStatusId?: true
    estimatedHours?: true
    actualHours?: true
    projectId?: true
    teamId?: true
    createdById?: true
    deliverableId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    taskStatusId?: true
    priority?: true
    dueDate?: true
    plannedDate?: true
    estimatedHours?: true
    actualHours?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    teamId?: true
    createdById?: true
    deliverableId?: true
    startedAt?: true
    completedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    taskStatusId?: true
    priority?: true
    dueDate?: true
    plannedDate?: true
    estimatedHours?: true
    actualHours?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    teamId?: true
    createdById?: true
    deliverableId?: true
    startedAt?: true
    completedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    taskStatusId?: true
    priority?: true
    dueDate?: true
    plannedDate?: true
    estimatedHours?: true
    actualHours?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    teamId?: true
    createdById?: true
    deliverableId?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    title: string
    description: string | null
    status: string
    taskStatusId: number | null
    priority: string
    dueDate: Date | null
    plannedDate: Date | null
    estimatedHours: number
    actualHours: number
    createdAt: Date
    updatedAt: Date
    projectId: number
    teamId: number | null
    createdById: number | null
    deliverableId: number | null
    startedAt: Date | null
    completedAt: Date | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    taskStatusId?: boolean
    priority?: boolean
    dueDate?: boolean
    plannedDate?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    teamId?: boolean
    createdById?: boolean
    deliverableId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    deliverable?: boolean | Task$deliverableArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    team?: boolean | Task$teamArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>


  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    taskStatusId?: boolean
    priority?: boolean
    dueDate?: boolean
    plannedDate?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    teamId?: boolean
    createdById?: boolean
    deliverableId?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Task$attachmentsArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    subtasks?: boolean | Task$subtasksArgs<ExtArgs>
    dependents?: boolean | Task$dependentsArgs<ExtArgs>
    dependencies?: boolean | Task$dependenciesArgs<ExtArgs>
    labels?: boolean | Task$labelsArgs<ExtArgs>
    deliverable?: boolean | Task$deliverableArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    team?: boolean | Task$teamArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    taskStatus?: boolean | Task$taskStatusArgs<ExtArgs>
    timeLogs?: boolean | Task$timeLogsArgs<ExtArgs>
    assignees?: boolean | Task$assigneesArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      subtasks: Prisma.$SubtaskPayload<ExtArgs>[]
      dependents: Prisma.$TaskDependencyPayload<ExtArgs>[]
      dependencies: Prisma.$TaskDependencyPayload<ExtArgs>[]
      labels: Prisma.$TaskLabelPayload<ExtArgs>[]
      deliverable: Prisma.$DeliverablePayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs>
      taskStatus: Prisma.$TaskStatusPayload<ExtArgs> | null
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      assignees: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      status: string
      taskStatusId: number | null
      priority: string
      dueDate: Date | null
      plannedDate: Date | null
      estimatedHours: number
      actualHours: number
      createdAt: Date
      updatedAt: Date
      projectId: number
      teamId: number | null
      createdById: number | null
      deliverableId: number | null
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends Task$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(args?: Subset<T, Task$subtasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany"> | Null>
    dependents<T extends Task$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    dependencies<T extends Task$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Task$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    labels<T extends Task$labelsArgs<ExtArgs> = {}>(args?: Subset<T, Task$labelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany"> | Null>
    deliverable<T extends Task$deliverableArgs<ExtArgs> = {}>(args?: Subset<T, Task$deliverableArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends Task$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Task$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    team<T extends Task$teamArgs<ExtArgs> = {}>(args?: Subset<T, Task$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taskStatus<T extends Task$taskStatusArgs<ExtArgs> = {}>(args?: Subset<T, Task$taskStatusArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    timeLogs<T extends Task$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Task$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany"> | Null>
    assignees<T extends Task$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly taskStatusId: FieldRef<"Task", 'Int'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly plannedDate: FieldRef<"Task", 'DateTime'>
    readonly estimatedHours: FieldRef<"Task", 'Float'>
    readonly actualHours: FieldRef<"Task", 'Float'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly projectId: FieldRef<"Task", 'Int'>
    readonly teamId: FieldRef<"Task", 'Int'>
    readonly createdById: FieldRef<"Task", 'Int'>
    readonly deliverableId: FieldRef<"Task", 'Int'>
    readonly startedAt: FieldRef<"Task", 'DateTime'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.attachments
   */
  export type Task$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Task.subtasks
   */
  export type Task$subtasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    cursor?: SubtaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Task.dependents
   */
  export type Task$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * Task.dependencies
   */
  export type Task$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    cursor?: TaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * Task.labels
   */
  export type Task$labelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Task.deliverable
   */
  export type Task$deliverableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    where?: DeliverableWhereInput
  }

  /**
   * Task.creator
   */
  export type Task$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.team
   */
  export type Task$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Task.taskStatus
   */
  export type Task$taskStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    where?: TaskStatusWhereInput
  }

  /**
   * Task.timeLogs
   */
  export type Task$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Task.assignees
   */
  export type Task$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Subtask
   */

  export type AggregateSubtask = {
    _count: SubtaskCountAggregateOutputType | null
    _avg: SubtaskAvgAggregateOutputType | null
    _sum: SubtaskSumAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  export type SubtaskAvgAggregateOutputType = {
    id: number | null
    estimatedHours: number | null
    actualHours: number | null
    parentTaskId: number | null
    assignedToId: number | null
    teamId: number | null
    createdById: number | null
  }

  export type SubtaskSumAggregateOutputType = {
    id: number | null
    estimatedHours: number | null
    actualHours: number | null
    parentTaskId: number | null
    assignedToId: number | null
    teamId: number | null
    createdById: number | null
  }

  export type SubtaskMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    startDate: Date | null
    dueDate: Date | null
    estimatedHours: number | null
    actualHours: number | null
    parentTaskId: number | null
    assignedToId: number | null
    teamId: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    startDate: Date | null
    dueDate: Date | null
    estimatedHours: number | null
    actualHours: number | null
    parentTaskId: number | null
    assignedToId: number | null
    teamId: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    startDate: number
    dueDate: number
    estimatedHours: number
    actualHours: number
    parentTaskId: number
    assignedToId: number
    teamId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubtaskAvgAggregateInputType = {
    id?: true
    estimatedHours?: true
    actualHours?: true
    parentTaskId?: true
    assignedToId?: true
    teamId?: true
    createdById?: true
  }

  export type SubtaskSumAggregateInputType = {
    id?: true
    estimatedHours?: true
    actualHours?: true
    parentTaskId?: true
    assignedToId?: true
    teamId?: true
    createdById?: true
  }

  export type SubtaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    estimatedHours?: true
    actualHours?: true
    parentTaskId?: true
    assignedToId?: true
    teamId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    estimatedHours?: true
    actualHours?: true
    parentTaskId?: true
    assignedToId?: true
    teamId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    startDate?: true
    dueDate?: true
    estimatedHours?: true
    actualHours?: true
    parentTaskId?: true
    assignedToId?: true
    teamId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubtaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtask to aggregate.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtasks
    **/
    _count?: true | SubtaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskMaxAggregateInputType
  }

  export type GetSubtaskAggregateType<T extends SubtaskAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtask[P]>
      : GetScalarType<T[P], AggregateSubtask[P]>
  }




  export type SubtaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskWhereInput
    orderBy?: SubtaskOrderByWithAggregationInput | SubtaskOrderByWithAggregationInput[]
    by: SubtaskScalarFieldEnum[] | SubtaskScalarFieldEnum
    having?: SubtaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskCountAggregateInputType | true
    _avg?: SubtaskAvgAggregateInputType
    _sum?: SubtaskSumAggregateInputType
    _min?: SubtaskMinAggregateInputType
    _max?: SubtaskMaxAggregateInputType
  }

  export type SubtaskGroupByOutputType = {
    id: number
    title: string
    description: string | null
    status: string
    priority: string
    startDate: Date | null
    dueDate: Date | null
    estimatedHours: number
    actualHours: number
    parentTaskId: number
    assignedToId: number | null
    teamId: number | null
    createdById: number
    createdAt: Date
    updatedAt: Date
    _count: SubtaskCountAggregateOutputType | null
    _avg: SubtaskAvgAggregateOutputType | null
    _sum: SubtaskSumAggregateOutputType | null
    _min: SubtaskMinAggregateOutputType | null
    _max: SubtaskMaxAggregateOutputType | null
  }

  type GetSubtaskGroupByPayload<T extends SubtaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    parentTaskId?: boolean
    assignedToId?: boolean
    teamId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | Subtask$commentsArgs<ExtArgs>
    dependencies?: boolean | Subtask$dependenciesArgs<ExtArgs>
    dependents?: boolean | Subtask$dependentsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Subtask$teamArgs<ExtArgs>
    assignedTo?: boolean | Subtask$assignedToArgs<ExtArgs>
    parentTask?: boolean | TaskDefaultArgs<ExtArgs>
    timeLogs?: boolean | Subtask$timeLogsArgs<ExtArgs>
    _count?: boolean | SubtaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtask"]>


  export type SubtaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    startDate?: boolean
    dueDate?: boolean
    estimatedHours?: boolean
    actualHours?: boolean
    parentTaskId?: boolean
    assignedToId?: boolean
    teamId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Subtask$commentsArgs<ExtArgs>
    dependencies?: boolean | Subtask$dependenciesArgs<ExtArgs>
    dependents?: boolean | Subtask$dependentsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Subtask$teamArgs<ExtArgs>
    assignedTo?: boolean | Subtask$assignedToArgs<ExtArgs>
    parentTask?: boolean | TaskDefaultArgs<ExtArgs>
    timeLogs?: boolean | Subtask$timeLogsArgs<ExtArgs>
    _count?: boolean | SubtaskCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtask"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      dependencies: Prisma.$SubtaskDependencyPayload<ExtArgs>[]
      dependents: Prisma.$SubtaskDependencyPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      parentTask: Prisma.$TaskPayload<ExtArgs>
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      status: string
      priority: string
      startDate: Date | null
      dueDate: Date | null
      estimatedHours: number
      actualHours: number
      parentTaskId: number
      assignedToId: number | null
      teamId: number | null
      createdById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subtask"]>
    composites: {}
  }

  type SubtaskGetPayload<S extends boolean | null | undefined | SubtaskDefaultArgs> = $Result.GetResult<Prisma.$SubtaskPayload, S>

  type SubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubtaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtaskCountAggregateInputType | true
    }

  export interface SubtaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtask'], meta: { name: 'Subtask' } }
    /**
     * Find zero or one Subtask that matches the filter.
     * @param {SubtaskFindUniqueArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskFindUniqueArgs>(args: SelectSubset<T, SubtaskFindUniqueArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subtask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubtaskFindUniqueOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subtask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskFindFirstArgs>(args?: SelectSubset<T, SubtaskFindFirstArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subtask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindFirstOrThrowArgs} args - Arguments to find a Subtask
     * @example
     * // Get one Subtask
     * const subtask = await prisma.subtask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subtasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtasks
     * const subtasks = await prisma.subtask.findMany()
     * 
     * // Get first 10 Subtasks
     * const subtasks = await prisma.subtask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtaskWithIdOnly = await prisma.subtask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtaskFindManyArgs>(args?: SelectSubset<T, SubtaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subtask.
     * @param {SubtaskCreateArgs} args - Arguments to create a Subtask.
     * @example
     * // Create one Subtask
     * const Subtask = await prisma.subtask.create({
     *   data: {
     *     // ... data to create a Subtask
     *   }
     * })
     * 
     */
    create<T extends SubtaskCreateArgs>(args: SelectSubset<T, SubtaskCreateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subtasks.
     * @param {SubtaskCreateManyArgs} args - Arguments to create many Subtasks.
     * @example
     * // Create many Subtasks
     * const subtask = await prisma.subtask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskCreateManyArgs>(args?: SelectSubset<T, SubtaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subtask.
     * @param {SubtaskDeleteArgs} args - Arguments to delete one Subtask.
     * @example
     * // Delete one Subtask
     * const Subtask = await prisma.subtask.delete({
     *   where: {
     *     // ... filter to delete one Subtask
     *   }
     * })
     * 
     */
    delete<T extends SubtaskDeleteArgs>(args: SelectSubset<T, SubtaskDeleteArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subtask.
     * @param {SubtaskUpdateArgs} args - Arguments to update one Subtask.
     * @example
     * // Update one Subtask
     * const subtask = await prisma.subtask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskUpdateArgs>(args: SelectSubset<T, SubtaskUpdateArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subtasks.
     * @param {SubtaskDeleteManyArgs} args - Arguments to filter Subtasks to delete.
     * @example
     * // Delete a few Subtasks
     * const { count } = await prisma.subtask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskDeleteManyArgs>(args?: SelectSubset<T, SubtaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtasks
     * const subtask = await prisma.subtask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskUpdateManyArgs>(args: SelectSubset<T, SubtaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subtask.
     * @param {SubtaskUpsertArgs} args - Arguments to update or create a Subtask.
     * @example
     * // Update or create a Subtask
     * const subtask = await prisma.subtask.upsert({
     *   create: {
     *     // ... data to create a Subtask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtask we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskUpsertArgs>(args: SelectSubset<T, SubtaskUpsertArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subtasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskCountArgs} args - Arguments to filter Subtasks to count.
     * @example
     * // Count the number of Subtasks
     * const count = await prisma.subtask.count({
     *   where: {
     *     // ... the filter for the Subtasks we want to count
     *   }
     * })
    **/
    count<T extends SubtaskCountArgs>(
      args?: Subset<T, SubtaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskAggregateArgs>(args: Subset<T, SubtaskAggregateArgs>): Prisma.PrismaPromise<GetSubtaskAggregateType<T>>

    /**
     * Group by Subtask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtask model
   */
  readonly fields: SubtaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Subtask$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    dependencies<T extends Subtask$dependenciesArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$dependenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    dependents<T extends Subtask$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends Subtask$teamArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedTo<T extends Subtask$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parentTask<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    timeLogs<T extends Subtask$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Subtask$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtask model
   */ 
  interface SubtaskFieldRefs {
    readonly id: FieldRef<"Subtask", 'Int'>
    readonly title: FieldRef<"Subtask", 'String'>
    readonly description: FieldRef<"Subtask", 'String'>
    readonly status: FieldRef<"Subtask", 'String'>
    readonly priority: FieldRef<"Subtask", 'String'>
    readonly startDate: FieldRef<"Subtask", 'DateTime'>
    readonly dueDate: FieldRef<"Subtask", 'DateTime'>
    readonly estimatedHours: FieldRef<"Subtask", 'Float'>
    readonly actualHours: FieldRef<"Subtask", 'Float'>
    readonly parentTaskId: FieldRef<"Subtask", 'Int'>
    readonly assignedToId: FieldRef<"Subtask", 'Int'>
    readonly teamId: FieldRef<"Subtask", 'Int'>
    readonly createdById: FieldRef<"Subtask", 'Int'>
    readonly createdAt: FieldRef<"Subtask", 'DateTime'>
    readonly updatedAt: FieldRef<"Subtask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subtask findUnique
   */
  export type SubtaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findUniqueOrThrow
   */
  export type SubtaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask findFirst
   */
  export type SubtaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findFirstOrThrow
   */
  export type SubtaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtask to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtasks.
     */
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask findMany
   */
  export type SubtaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter, which Subtasks to fetch.
     */
    where?: SubtaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtasks to fetch.
     */
    orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtasks.
     */
    cursor?: SubtaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtasks.
     */
    skip?: number
    distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[]
  }

  /**
   * Subtask create
   */
  export type SubtaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtask.
     */
    data: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
  }

  /**
   * Subtask createMany
   */
  export type SubtaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtasks.
     */
    data: SubtaskCreateManyInput | SubtaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subtask update
   */
  export type SubtaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtask.
     */
    data: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
    /**
     * Choose, which Subtask to update.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask updateMany
   */
  export type SubtaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtasks.
     */
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>
    /**
     * Filter which Subtasks to update
     */
    where?: SubtaskWhereInput
  }

  /**
   * Subtask upsert
   */
  export type SubtaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtask to update in case it exists.
     */
    where: SubtaskWhereUniqueInput
    /**
     * In case the Subtask found by the `where` argument doesn't exist, create a new Subtask with this data.
     */
    create: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>
    /**
     * In case the Subtask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>
  }

  /**
   * Subtask delete
   */
  export type SubtaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    /**
     * Filter which Subtask to delete.
     */
    where: SubtaskWhereUniqueInput
  }

  /**
   * Subtask deleteMany
   */
  export type SubtaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtasks to delete
     */
    where?: SubtaskWhereInput
  }

  /**
   * Subtask.comments
   */
  export type Subtask$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Subtask.dependencies
   */
  export type Subtask$dependenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    where?: SubtaskDependencyWhereInput
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    cursor?: SubtaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskDependencyScalarFieldEnum | SubtaskDependencyScalarFieldEnum[]
  }

  /**
   * Subtask.dependents
   */
  export type Subtask$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    where?: SubtaskDependencyWhereInput
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    cursor?: SubtaskDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtaskDependencyScalarFieldEnum | SubtaskDependencyScalarFieldEnum[]
  }

  /**
   * Subtask.team
   */
  export type Subtask$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Subtask.assignedTo
   */
  export type Subtask$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subtask.timeLogs
   */
  export type Subtask$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Subtask without action
   */
  export type SubtaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
  }


  /**
   * Model SubtaskDependency
   */

  export type AggregateSubtaskDependency = {
    _count: SubtaskDependencyCountAggregateOutputType | null
    _avg: SubtaskDependencyAvgAggregateOutputType | null
    _sum: SubtaskDependencySumAggregateOutputType | null
    _min: SubtaskDependencyMinAggregateOutputType | null
    _max: SubtaskDependencyMaxAggregateOutputType | null
  }

  export type SubtaskDependencyAvgAggregateOutputType = {
    subtaskId: number | null
    dependsOnSubtaskId: number | null
    createdById: number | null
  }

  export type SubtaskDependencySumAggregateOutputType = {
    subtaskId: number | null
    dependsOnSubtaskId: number | null
    createdById: number | null
  }

  export type SubtaskDependencyMinAggregateOutputType = {
    subtaskId: number | null
    dependsOnSubtaskId: number | null
    dependencyType: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type SubtaskDependencyMaxAggregateOutputType = {
    subtaskId: number | null
    dependsOnSubtaskId: number | null
    dependencyType: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type SubtaskDependencyCountAggregateOutputType = {
    subtaskId: number
    dependsOnSubtaskId: number
    dependencyType: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type SubtaskDependencyAvgAggregateInputType = {
    subtaskId?: true
    dependsOnSubtaskId?: true
    createdById?: true
  }

  export type SubtaskDependencySumAggregateInputType = {
    subtaskId?: true
    dependsOnSubtaskId?: true
    createdById?: true
  }

  export type SubtaskDependencyMinAggregateInputType = {
    subtaskId?: true
    dependsOnSubtaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
  }

  export type SubtaskDependencyMaxAggregateInputType = {
    subtaskId?: true
    dependsOnSubtaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
  }

  export type SubtaskDependencyCountAggregateInputType = {
    subtaskId?: true
    dependsOnSubtaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type SubtaskDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtaskDependency to aggregate.
     */
    where?: SubtaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskDependencies to fetch.
     */
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubtaskDependencies
    **/
    _count?: true | SubtaskDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtaskDependencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtaskDependencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtaskDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtaskDependencyMaxAggregateInputType
  }

  export type GetSubtaskDependencyAggregateType<T extends SubtaskDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtaskDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtaskDependency[P]>
      : GetScalarType<T[P], AggregateSubtaskDependency[P]>
  }




  export type SubtaskDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtaskDependencyWhereInput
    orderBy?: SubtaskDependencyOrderByWithAggregationInput | SubtaskDependencyOrderByWithAggregationInput[]
    by: SubtaskDependencyScalarFieldEnum[] | SubtaskDependencyScalarFieldEnum
    having?: SubtaskDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtaskDependencyCountAggregateInputType | true
    _avg?: SubtaskDependencyAvgAggregateInputType
    _sum?: SubtaskDependencySumAggregateInputType
    _min?: SubtaskDependencyMinAggregateInputType
    _max?: SubtaskDependencyMaxAggregateInputType
  }

  export type SubtaskDependencyGroupByOutputType = {
    subtaskId: number
    dependsOnSubtaskId: number
    dependencyType: string
    createdById: number
    createdAt: Date
    _count: SubtaskDependencyCountAggregateOutputType | null
    _avg: SubtaskDependencyAvgAggregateOutputType | null
    _sum: SubtaskDependencySumAggregateOutputType | null
    _min: SubtaskDependencyMinAggregateOutputType | null
    _max: SubtaskDependencyMaxAggregateOutputType | null
  }

  type GetSubtaskDependencyGroupByPayload<T extends SubtaskDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtaskDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtaskDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtaskDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], SubtaskDependencyGroupByOutputType[P]>
        }
      >
    >


  export type SubtaskDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subtaskId?: boolean
    dependsOnSubtaskId?: boolean
    dependencyType?: boolean
    createdById?: boolean
    createdAt?: boolean
    dependsOnSubtask?: boolean | SubtaskDefaultArgs<ExtArgs>
    subtask?: boolean | SubtaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtaskDependency"]>


  export type SubtaskDependencySelectScalar = {
    subtaskId?: boolean
    dependsOnSubtaskId?: boolean
    dependencyType?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type SubtaskDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependsOnSubtask?: boolean | SubtaskDefaultArgs<ExtArgs>
    subtask?: boolean | SubtaskDefaultArgs<ExtArgs>
  }

  export type $SubtaskDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubtaskDependency"
    objects: {
      dependsOnSubtask: Prisma.$SubtaskPayload<ExtArgs>
      subtask: Prisma.$SubtaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subtaskId: number
      dependsOnSubtaskId: number
      dependencyType: string
      createdById: number
      createdAt: Date
    }, ExtArgs["result"]["subtaskDependency"]>
    composites: {}
  }

  type SubtaskDependencyGetPayload<S extends boolean | null | undefined | SubtaskDependencyDefaultArgs> = $Result.GetResult<Prisma.$SubtaskDependencyPayload, S>

  type SubtaskDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubtaskDependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtaskDependencyCountAggregateInputType | true
    }

  export interface SubtaskDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubtaskDependency'], meta: { name: 'SubtaskDependency' } }
    /**
     * Find zero or one SubtaskDependency that matches the filter.
     * @param {SubtaskDependencyFindUniqueArgs} args - Arguments to find a SubtaskDependency
     * @example
     * // Get one SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtaskDependencyFindUniqueArgs>(args: SelectSubset<T, SubtaskDependencyFindUniqueArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubtaskDependency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubtaskDependencyFindUniqueOrThrowArgs} args - Arguments to find a SubtaskDependency
     * @example
     * // Get one SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtaskDependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtaskDependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubtaskDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyFindFirstArgs} args - Arguments to find a SubtaskDependency
     * @example
     * // Get one SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtaskDependencyFindFirstArgs>(args?: SelectSubset<T, SubtaskDependencyFindFirstArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubtaskDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyFindFirstOrThrowArgs} args - Arguments to find a SubtaskDependency
     * @example
     * // Get one SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtaskDependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtaskDependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubtaskDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubtaskDependencies
     * const subtaskDependencies = await prisma.subtaskDependency.findMany()
     * 
     * // Get first 10 SubtaskDependencies
     * const subtaskDependencies = await prisma.subtaskDependency.findMany({ take: 10 })
     * 
     * // Only select the `subtaskId`
     * const subtaskDependencyWithSubtaskIdOnly = await prisma.subtaskDependency.findMany({ select: { subtaskId: true } })
     * 
     */
    findMany<T extends SubtaskDependencyFindManyArgs>(args?: SelectSubset<T, SubtaskDependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubtaskDependency.
     * @param {SubtaskDependencyCreateArgs} args - Arguments to create a SubtaskDependency.
     * @example
     * // Create one SubtaskDependency
     * const SubtaskDependency = await prisma.subtaskDependency.create({
     *   data: {
     *     // ... data to create a SubtaskDependency
     *   }
     * })
     * 
     */
    create<T extends SubtaskDependencyCreateArgs>(args: SelectSubset<T, SubtaskDependencyCreateArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubtaskDependencies.
     * @param {SubtaskDependencyCreateManyArgs} args - Arguments to create many SubtaskDependencies.
     * @example
     * // Create many SubtaskDependencies
     * const subtaskDependency = await prisma.subtaskDependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtaskDependencyCreateManyArgs>(args?: SelectSubset<T, SubtaskDependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubtaskDependency.
     * @param {SubtaskDependencyDeleteArgs} args - Arguments to delete one SubtaskDependency.
     * @example
     * // Delete one SubtaskDependency
     * const SubtaskDependency = await prisma.subtaskDependency.delete({
     *   where: {
     *     // ... filter to delete one SubtaskDependency
     *   }
     * })
     * 
     */
    delete<T extends SubtaskDependencyDeleteArgs>(args: SelectSubset<T, SubtaskDependencyDeleteArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubtaskDependency.
     * @param {SubtaskDependencyUpdateArgs} args - Arguments to update one SubtaskDependency.
     * @example
     * // Update one SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtaskDependencyUpdateArgs>(args: SelectSubset<T, SubtaskDependencyUpdateArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubtaskDependencies.
     * @param {SubtaskDependencyDeleteManyArgs} args - Arguments to filter SubtaskDependencies to delete.
     * @example
     * // Delete a few SubtaskDependencies
     * const { count } = await prisma.subtaskDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtaskDependencyDeleteManyArgs>(args?: SelectSubset<T, SubtaskDependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubtaskDependencies
     * const subtaskDependency = await prisma.subtaskDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtaskDependencyUpdateManyArgs>(args: SelectSubset<T, SubtaskDependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubtaskDependency.
     * @param {SubtaskDependencyUpsertArgs} args - Arguments to update or create a SubtaskDependency.
     * @example
     * // Update or create a SubtaskDependency
     * const subtaskDependency = await prisma.subtaskDependency.upsert({
     *   create: {
     *     // ... data to create a SubtaskDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubtaskDependency we want to update
     *   }
     * })
     */
    upsert<T extends SubtaskDependencyUpsertArgs>(args: SelectSubset<T, SubtaskDependencyUpsertArgs<ExtArgs>>): Prisma__SubtaskDependencyClient<$Result.GetResult<Prisma.$SubtaskDependencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubtaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyCountArgs} args - Arguments to filter SubtaskDependencies to count.
     * @example
     * // Count the number of SubtaskDependencies
     * const count = await prisma.subtaskDependency.count({
     *   where: {
     *     // ... the filter for the SubtaskDependencies we want to count
     *   }
     * })
    **/
    count<T extends SubtaskDependencyCountArgs>(
      args?: Subset<T, SubtaskDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtaskDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubtaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtaskDependencyAggregateArgs>(args: Subset<T, SubtaskDependencyAggregateArgs>): Prisma.PrismaPromise<GetSubtaskDependencyAggregateType<T>>

    /**
     * Group by SubtaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtaskDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtaskDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtaskDependencyGroupByArgs['orderBy'] }
        : { orderBy?: SubtaskDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtaskDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtaskDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubtaskDependency model
   */
  readonly fields: SubtaskDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubtaskDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtaskDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dependsOnSubtask<T extends SubtaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubtaskDefaultArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subtask<T extends SubtaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubtaskDefaultArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubtaskDependency model
   */ 
  interface SubtaskDependencyFieldRefs {
    readonly subtaskId: FieldRef<"SubtaskDependency", 'Int'>
    readonly dependsOnSubtaskId: FieldRef<"SubtaskDependency", 'Int'>
    readonly dependencyType: FieldRef<"SubtaskDependency", 'String'>
    readonly createdById: FieldRef<"SubtaskDependency", 'Int'>
    readonly createdAt: FieldRef<"SubtaskDependency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubtaskDependency findUnique
   */
  export type SubtaskDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskDependency to fetch.
     */
    where: SubtaskDependencyWhereUniqueInput
  }

  /**
   * SubtaskDependency findUniqueOrThrow
   */
  export type SubtaskDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskDependency to fetch.
     */
    where: SubtaskDependencyWhereUniqueInput
  }

  /**
   * SubtaskDependency findFirst
   */
  export type SubtaskDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskDependency to fetch.
     */
    where?: SubtaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskDependencies to fetch.
     */
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtaskDependencies.
     */
    cursor?: SubtaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtaskDependencies.
     */
    distinct?: SubtaskDependencyScalarFieldEnum | SubtaskDependencyScalarFieldEnum[]
  }

  /**
   * SubtaskDependency findFirstOrThrow
   */
  export type SubtaskDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskDependency to fetch.
     */
    where?: SubtaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskDependencies to fetch.
     */
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtaskDependencies.
     */
    cursor?: SubtaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtaskDependencies.
     */
    distinct?: SubtaskDependencyScalarFieldEnum | SubtaskDependencyScalarFieldEnum[]
  }

  /**
   * SubtaskDependency findMany
   */
  export type SubtaskDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which SubtaskDependencies to fetch.
     */
    where?: SubtaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtaskDependencies to fetch.
     */
    orderBy?: SubtaskDependencyOrderByWithRelationInput | SubtaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubtaskDependencies.
     */
    cursor?: SubtaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtaskDependencies.
     */
    skip?: number
    distinct?: SubtaskDependencyScalarFieldEnum | SubtaskDependencyScalarFieldEnum[]
  }

  /**
   * SubtaskDependency create
   */
  export type SubtaskDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a SubtaskDependency.
     */
    data: XOR<SubtaskDependencyCreateInput, SubtaskDependencyUncheckedCreateInput>
  }

  /**
   * SubtaskDependency createMany
   */
  export type SubtaskDependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubtaskDependencies.
     */
    data: SubtaskDependencyCreateManyInput | SubtaskDependencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubtaskDependency update
   */
  export type SubtaskDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a SubtaskDependency.
     */
    data: XOR<SubtaskDependencyUpdateInput, SubtaskDependencyUncheckedUpdateInput>
    /**
     * Choose, which SubtaskDependency to update.
     */
    where: SubtaskDependencyWhereUniqueInput
  }

  /**
   * SubtaskDependency updateMany
   */
  export type SubtaskDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubtaskDependencies.
     */
    data: XOR<SubtaskDependencyUpdateManyMutationInput, SubtaskDependencyUncheckedUpdateManyInput>
    /**
     * Filter which SubtaskDependencies to update
     */
    where?: SubtaskDependencyWhereInput
  }

  /**
   * SubtaskDependency upsert
   */
  export type SubtaskDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the SubtaskDependency to update in case it exists.
     */
    where: SubtaskDependencyWhereUniqueInput
    /**
     * In case the SubtaskDependency found by the `where` argument doesn't exist, create a new SubtaskDependency with this data.
     */
    create: XOR<SubtaskDependencyCreateInput, SubtaskDependencyUncheckedCreateInput>
    /**
     * In case the SubtaskDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtaskDependencyUpdateInput, SubtaskDependencyUncheckedUpdateInput>
  }

  /**
   * SubtaskDependency delete
   */
  export type SubtaskDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
    /**
     * Filter which SubtaskDependency to delete.
     */
    where: SubtaskDependencyWhereUniqueInput
  }

  /**
   * SubtaskDependency deleteMany
   */
  export type SubtaskDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtaskDependencies to delete
     */
    where?: SubtaskDependencyWhereInput
  }

  /**
   * SubtaskDependency without action
   */
  export type SubtaskDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtaskDependency
     */
    select?: SubtaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskDependencyInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
    subtaskId: number | null
    userId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    taskId: number | null
    subtaskId: number | null
    userId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    taskId: number | null
    subtaskId: number | null
    userId: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    taskId: number | null
    subtaskId: number | null
    userId: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    taskId: number
    subtaskId: number
    userId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    taskId?: true
    subtaskId?: true
    userId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    taskId?: true
    subtaskId?: true
    userId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    taskId?: true
    subtaskId?: true
    userId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    taskId?: true
    subtaskId?: true
    userId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    taskId?: true
    subtaskId?: true
    userId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    taskId: number | null
    subtaskId: number | null
    userId: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    taskId?: boolean
    subtaskId?: boolean
    userId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    subtask?: boolean | Comment$subtaskArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
    mentions?: boolean | Comment$mentionsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>


  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    taskId?: boolean
    subtaskId?: boolean
    userId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    subtask?: boolean | Comment$subtaskArgs<ExtArgs>
    task?: boolean | Comment$taskArgs<ExtArgs>
    mentions?: boolean | Comment$mentionsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      subtask: Prisma.$SubtaskPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
      mentions: Prisma.$CommentMentionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      createdAt: Date
      taskId: number | null
      subtaskId: number | null
      userId: number
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subtask<T extends Comment$subtaskArgs<ExtArgs> = {}>(args?: Subset<T, Comment$subtaskArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task<T extends Comment$taskArgs<ExtArgs> = {}>(args?: Subset<T, Comment$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mentions<T extends Comment$mentionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$mentionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly taskId: FieldRef<"Comment", 'Int'>
    readonly subtaskId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.subtask
   */
  export type Comment$subtaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
  }

  /**
   * Comment.task
   */
  export type Comment$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Comment.mentions
   */
  export type Comment$mentionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    where?: CommentMentionWhereInput
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    cursor?: CommentMentionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentMentionScalarFieldEnum | CommentMentionScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentMention
   */

  export type AggregateCommentMention = {
    _count: CommentMentionCountAggregateOutputType | null
    _avg: CommentMentionAvgAggregateOutputType | null
    _sum: CommentMentionSumAggregateOutputType | null
    _min: CommentMentionMinAggregateOutputType | null
    _max: CommentMentionMaxAggregateOutputType | null
  }

  export type CommentMentionAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type CommentMentionSumAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type CommentMentionMinAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type CommentMentionMaxAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    createdAt: Date | null
  }

  export type CommentMentionCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type CommentMentionAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type CommentMentionSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type CommentMentionMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdAt?: true
  }

  export type CommentMentionMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdAt?: true
  }

  export type CommentMentionCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type CommentMentionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentMention to aggregate.
     */
    where?: CommentMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentMentions to fetch.
     */
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentMentions
    **/
    _count?: true | CommentMentionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentMentionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentMentionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMentionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMentionMaxAggregateInputType
  }

  export type GetCommentMentionAggregateType<T extends CommentMentionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentMention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentMention[P]>
      : GetScalarType<T[P], AggregateCommentMention[P]>
  }




  export type CommentMentionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentMentionWhereInput
    orderBy?: CommentMentionOrderByWithAggregationInput | CommentMentionOrderByWithAggregationInput[]
    by: CommentMentionScalarFieldEnum[] | CommentMentionScalarFieldEnum
    having?: CommentMentionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentMentionCountAggregateInputType | true
    _avg?: CommentMentionAvgAggregateInputType
    _sum?: CommentMentionSumAggregateInputType
    _min?: CommentMentionMinAggregateInputType
    _max?: CommentMentionMaxAggregateInputType
  }

  export type CommentMentionGroupByOutputType = {
    id: number
    commentId: number
    userId: number
    createdAt: Date
    _count: CommentMentionCountAggregateOutputType | null
    _avg: CommentMentionAvgAggregateOutputType | null
    _sum: CommentMentionSumAggregateOutputType | null
    _min: CommentMentionMinAggregateOutputType | null
    _max: CommentMentionMaxAggregateOutputType | null
  }

  type GetCommentMentionGroupByPayload<T extends CommentMentionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentMentionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentMentionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentMentionGroupByOutputType[P]>
            : GetScalarType<T[P], CommentMentionGroupByOutputType[P]>
        }
      >
    >


  export type CommentMentionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentMention"]>


  export type CommentMentionSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type CommentMentionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentMentionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentMention"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commentId: number
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["commentMention"]>
    composites: {}
  }

  type CommentMentionGetPayload<S extends boolean | null | undefined | CommentMentionDefaultArgs> = $Result.GetResult<Prisma.$CommentMentionPayload, S>

  type CommentMentionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentMentionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentMentionCountAggregateInputType | true
    }

  export interface CommentMentionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentMention'], meta: { name: 'CommentMention' } }
    /**
     * Find zero or one CommentMention that matches the filter.
     * @param {CommentMentionFindUniqueArgs} args - Arguments to find a CommentMention
     * @example
     * // Get one CommentMention
     * const commentMention = await prisma.commentMention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentMentionFindUniqueArgs>(args: SelectSubset<T, CommentMentionFindUniqueArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommentMention that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentMentionFindUniqueOrThrowArgs} args - Arguments to find a CommentMention
     * @example
     * // Get one CommentMention
     * const commentMention = await prisma.commentMention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentMentionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentMentionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommentMention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionFindFirstArgs} args - Arguments to find a CommentMention
     * @example
     * // Get one CommentMention
     * const commentMention = await prisma.commentMention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentMentionFindFirstArgs>(args?: SelectSubset<T, CommentMentionFindFirstArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommentMention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionFindFirstOrThrowArgs} args - Arguments to find a CommentMention
     * @example
     * // Get one CommentMention
     * const commentMention = await prisma.commentMention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentMentionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentMentionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommentMentions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentMentions
     * const commentMentions = await prisma.commentMention.findMany()
     * 
     * // Get first 10 CommentMentions
     * const commentMentions = await prisma.commentMention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentMentionWithIdOnly = await prisma.commentMention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentMentionFindManyArgs>(args?: SelectSubset<T, CommentMentionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommentMention.
     * @param {CommentMentionCreateArgs} args - Arguments to create a CommentMention.
     * @example
     * // Create one CommentMention
     * const CommentMention = await prisma.commentMention.create({
     *   data: {
     *     // ... data to create a CommentMention
     *   }
     * })
     * 
     */
    create<T extends CommentMentionCreateArgs>(args: SelectSubset<T, CommentMentionCreateArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommentMentions.
     * @param {CommentMentionCreateManyArgs} args - Arguments to create many CommentMentions.
     * @example
     * // Create many CommentMentions
     * const commentMention = await prisma.commentMention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentMentionCreateManyArgs>(args?: SelectSubset<T, CommentMentionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentMention.
     * @param {CommentMentionDeleteArgs} args - Arguments to delete one CommentMention.
     * @example
     * // Delete one CommentMention
     * const CommentMention = await prisma.commentMention.delete({
     *   where: {
     *     // ... filter to delete one CommentMention
     *   }
     * })
     * 
     */
    delete<T extends CommentMentionDeleteArgs>(args: SelectSubset<T, CommentMentionDeleteArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommentMention.
     * @param {CommentMentionUpdateArgs} args - Arguments to update one CommentMention.
     * @example
     * // Update one CommentMention
     * const commentMention = await prisma.commentMention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentMentionUpdateArgs>(args: SelectSubset<T, CommentMentionUpdateArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommentMentions.
     * @param {CommentMentionDeleteManyArgs} args - Arguments to filter CommentMentions to delete.
     * @example
     * // Delete a few CommentMentions
     * const { count } = await prisma.commentMention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentMentionDeleteManyArgs>(args?: SelectSubset<T, CommentMentionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentMentions
     * const commentMention = await prisma.commentMention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentMentionUpdateManyArgs>(args: SelectSubset<T, CommentMentionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentMention.
     * @param {CommentMentionUpsertArgs} args - Arguments to update or create a CommentMention.
     * @example
     * // Update or create a CommentMention
     * const commentMention = await prisma.commentMention.upsert({
     *   create: {
     *     // ... data to create a CommentMention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentMention we want to update
     *   }
     * })
     */
    upsert<T extends CommentMentionUpsertArgs>(args: SelectSubset<T, CommentMentionUpsertArgs<ExtArgs>>): Prisma__CommentMentionClient<$Result.GetResult<Prisma.$CommentMentionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommentMentions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionCountArgs} args - Arguments to filter CommentMentions to count.
     * @example
     * // Count the number of CommentMentions
     * const count = await prisma.commentMention.count({
     *   where: {
     *     // ... the filter for the CommentMentions we want to count
     *   }
     * })
    **/
    count<T extends CommentMentionCountArgs>(
      args?: Subset<T, CommentMentionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentMentionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentMention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentMentionAggregateArgs>(args: Subset<T, CommentMentionAggregateArgs>): Prisma.PrismaPromise<GetCommentMentionAggregateType<T>>

    /**
     * Group by CommentMention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentMentionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentMentionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentMentionGroupByArgs['orderBy'] }
        : { orderBy?: CommentMentionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentMentionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentMentionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentMention model
   */
  readonly fields: CommentMentionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentMention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentMentionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentMention model
   */ 
  interface CommentMentionFieldRefs {
    readonly id: FieldRef<"CommentMention", 'Int'>
    readonly commentId: FieldRef<"CommentMention", 'Int'>
    readonly userId: FieldRef<"CommentMention", 'Int'>
    readonly createdAt: FieldRef<"CommentMention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentMention findUnique
   */
  export type CommentMentionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter, which CommentMention to fetch.
     */
    where: CommentMentionWhereUniqueInput
  }

  /**
   * CommentMention findUniqueOrThrow
   */
  export type CommentMentionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter, which CommentMention to fetch.
     */
    where: CommentMentionWhereUniqueInput
  }

  /**
   * CommentMention findFirst
   */
  export type CommentMentionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter, which CommentMention to fetch.
     */
    where?: CommentMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentMentions to fetch.
     */
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentMentions.
     */
    cursor?: CommentMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentMentions.
     */
    distinct?: CommentMentionScalarFieldEnum | CommentMentionScalarFieldEnum[]
  }

  /**
   * CommentMention findFirstOrThrow
   */
  export type CommentMentionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter, which CommentMention to fetch.
     */
    where?: CommentMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentMentions to fetch.
     */
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentMentions.
     */
    cursor?: CommentMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentMentions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentMentions.
     */
    distinct?: CommentMentionScalarFieldEnum | CommentMentionScalarFieldEnum[]
  }

  /**
   * CommentMention findMany
   */
  export type CommentMentionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter, which CommentMentions to fetch.
     */
    where?: CommentMentionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentMentions to fetch.
     */
    orderBy?: CommentMentionOrderByWithRelationInput | CommentMentionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentMentions.
     */
    cursor?: CommentMentionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentMentions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentMentions.
     */
    skip?: number
    distinct?: CommentMentionScalarFieldEnum | CommentMentionScalarFieldEnum[]
  }

  /**
   * CommentMention create
   */
  export type CommentMentionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentMention.
     */
    data: XOR<CommentMentionCreateInput, CommentMentionUncheckedCreateInput>
  }

  /**
   * CommentMention createMany
   */
  export type CommentMentionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentMentions.
     */
    data: CommentMentionCreateManyInput | CommentMentionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentMention update
   */
  export type CommentMentionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentMention.
     */
    data: XOR<CommentMentionUpdateInput, CommentMentionUncheckedUpdateInput>
    /**
     * Choose, which CommentMention to update.
     */
    where: CommentMentionWhereUniqueInput
  }

  /**
   * CommentMention updateMany
   */
  export type CommentMentionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentMentions.
     */
    data: XOR<CommentMentionUpdateManyMutationInput, CommentMentionUncheckedUpdateManyInput>
    /**
     * Filter which CommentMentions to update
     */
    where?: CommentMentionWhereInput
  }

  /**
   * CommentMention upsert
   */
  export type CommentMentionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentMention to update in case it exists.
     */
    where: CommentMentionWhereUniqueInput
    /**
     * In case the CommentMention found by the `where` argument doesn't exist, create a new CommentMention with this data.
     */
    create: XOR<CommentMentionCreateInput, CommentMentionUncheckedCreateInput>
    /**
     * In case the CommentMention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentMentionUpdateInput, CommentMentionUncheckedUpdateInput>
  }

  /**
   * CommentMention delete
   */
  export type CommentMentionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
    /**
     * Filter which CommentMention to delete.
     */
    where: CommentMentionWhereUniqueInput
  }

  /**
   * CommentMention deleteMany
   */
  export type CommentMentionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentMentions to delete
     */
    where?: CommentMentionWhereInput
  }

  /**
   * CommentMention without action
   */
  export type CommentMentionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentMention
     */
    select?: CommentMentionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentMentionInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelAvgAggregateOutputType = {
    id: number | null
  }

  export type LabelSumAggregateOutputType = {
    id: number | null
  }

  export type LabelMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
  }

  export type LabelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    name: number
    color: number
    description: number
    createdAt: number
    _all: number
  }


  export type LabelAvgAggregateInputType = {
    id?: true
  }

  export type LabelSumAggregateInputType = {
    id?: true
  }

  export type LabelMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _avg?: LabelAvgAggregateInputType
    _sum?: LabelSumAggregateInputType
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: number
    name: string
    color: string
    description: string | null
    createdAt: Date
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    tasks?: boolean | Label$tasksArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>


  export type LabelSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Label$tasksArgs<ExtArgs>
    _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      tasks: Prisma.$TaskLabelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Label$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Label$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */ 
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'Int'>
    readonly name: FieldRef<"Label", 'String'>
    readonly color: FieldRef<"Label", 'String'>
    readonly description: FieldRef<"Label", 'String'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
  }

  /**
   * Label.tasks
   */
  export type Label$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    cursor?: TaskLabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model TaskLabel
   */

  export type AggregateTaskLabel = {
    _count: TaskLabelCountAggregateOutputType | null
    _avg: TaskLabelAvgAggregateOutputType | null
    _sum: TaskLabelSumAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  export type TaskLabelAvgAggregateOutputType = {
    taskId: number | null
    labelId: number | null
  }

  export type TaskLabelSumAggregateOutputType = {
    taskId: number | null
    labelId: number | null
  }

  export type TaskLabelMinAggregateOutputType = {
    taskId: number | null
    labelId: number | null
    createdAt: Date | null
  }

  export type TaskLabelMaxAggregateOutputType = {
    taskId: number | null
    labelId: number | null
    createdAt: Date | null
  }

  export type TaskLabelCountAggregateOutputType = {
    taskId: number
    labelId: number
    createdAt: number
    _all: number
  }


  export type TaskLabelAvgAggregateInputType = {
    taskId?: true
    labelId?: true
  }

  export type TaskLabelSumAggregateInputType = {
    taskId?: true
    labelId?: true
  }

  export type TaskLabelMinAggregateInputType = {
    taskId?: true
    labelId?: true
    createdAt?: true
  }

  export type TaskLabelMaxAggregateInputType = {
    taskId?: true
    labelId?: true
    createdAt?: true
  }

  export type TaskLabelCountAggregateInputType = {
    taskId?: true
    labelId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskLabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabel to aggregate.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLabels
    **/
    _count?: true | TaskLabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskLabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskLabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLabelMaxAggregateInputType
  }

  export type GetTaskLabelAggregateType<T extends TaskLabelAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLabel[P]>
      : GetScalarType<T[P], AggregateTaskLabel[P]>
  }




  export type TaskLabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLabelWhereInput
    orderBy?: TaskLabelOrderByWithAggregationInput | TaskLabelOrderByWithAggregationInput[]
    by: TaskLabelScalarFieldEnum[] | TaskLabelScalarFieldEnum
    having?: TaskLabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLabelCountAggregateInputType | true
    _avg?: TaskLabelAvgAggregateInputType
    _sum?: TaskLabelSumAggregateInputType
    _min?: TaskLabelMinAggregateInputType
    _max?: TaskLabelMaxAggregateInputType
  }

  export type TaskLabelGroupByOutputType = {
    taskId: number
    labelId: number
    createdAt: Date
    _count: TaskLabelCountAggregateOutputType | null
    _avg: TaskLabelAvgAggregateOutputType | null
    _sum: TaskLabelSumAggregateOutputType | null
    _min: TaskLabelMinAggregateOutputType | null
    _max: TaskLabelMaxAggregateOutputType | null
  }

  type GetTaskLabelGroupByPayload<T extends TaskLabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLabelGroupByOutputType[P]>
        }
      >
    >


  export type TaskLabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    labelId?: boolean
    createdAt?: boolean
    label?: boolean | LabelDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskLabel"]>


  export type TaskLabelSelectScalar = {
    taskId?: boolean
    labelId?: boolean
    createdAt?: boolean
  }

  export type TaskLabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    label?: boolean | LabelDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskLabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLabel"
    objects: {
      label: Prisma.$LabelPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: number
      labelId: number
      createdAt: Date
    }, ExtArgs["result"]["taskLabel"]>
    composites: {}
  }

  type TaskLabelGetPayload<S extends boolean | null | undefined | TaskLabelDefaultArgs> = $Result.GetResult<Prisma.$TaskLabelPayload, S>

  type TaskLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskLabelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskLabelCountAggregateInputType | true
    }

  export interface TaskLabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLabel'], meta: { name: 'TaskLabel' } }
    /**
     * Find zero or one TaskLabel that matches the filter.
     * @param {TaskLabelFindUniqueArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLabelFindUniqueArgs>(args: SelectSubset<T, TaskLabelFindUniqueArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskLabel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskLabelFindUniqueOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLabelFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskLabel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLabelFindFirstArgs>(args?: SelectSubset<T, TaskLabelFindFirstArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskLabel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindFirstOrThrowArgs} args - Arguments to find a TaskLabel
     * @example
     * // Get one TaskLabel
     * const taskLabel = await prisma.taskLabel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLabelFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany()
     * 
     * // Get first 10 TaskLabels
     * const taskLabels = await prisma.taskLabel.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskLabelWithTaskIdOnly = await prisma.taskLabel.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskLabelFindManyArgs>(args?: SelectSubset<T, TaskLabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskLabel.
     * @param {TaskLabelCreateArgs} args - Arguments to create a TaskLabel.
     * @example
     * // Create one TaskLabel
     * const TaskLabel = await prisma.taskLabel.create({
     *   data: {
     *     // ... data to create a TaskLabel
     *   }
     * })
     * 
     */
    create<T extends TaskLabelCreateArgs>(args: SelectSubset<T, TaskLabelCreateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskLabels.
     * @param {TaskLabelCreateManyArgs} args - Arguments to create many TaskLabels.
     * @example
     * // Create many TaskLabels
     * const taskLabel = await prisma.taskLabel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLabelCreateManyArgs>(args?: SelectSubset<T, TaskLabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskLabel.
     * @param {TaskLabelDeleteArgs} args - Arguments to delete one TaskLabel.
     * @example
     * // Delete one TaskLabel
     * const TaskLabel = await prisma.taskLabel.delete({
     *   where: {
     *     // ... filter to delete one TaskLabel
     *   }
     * })
     * 
     */
    delete<T extends TaskLabelDeleteArgs>(args: SelectSubset<T, TaskLabelDeleteArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskLabel.
     * @param {TaskLabelUpdateArgs} args - Arguments to update one TaskLabel.
     * @example
     * // Update one TaskLabel
     * const taskLabel = await prisma.taskLabel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLabelUpdateArgs>(args: SelectSubset<T, TaskLabelUpdateArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskLabels.
     * @param {TaskLabelDeleteManyArgs} args - Arguments to filter TaskLabels to delete.
     * @example
     * // Delete a few TaskLabels
     * const { count } = await prisma.taskLabel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLabelDeleteManyArgs>(args?: SelectSubset<T, TaskLabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLabels
     * const taskLabel = await prisma.taskLabel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLabelUpdateManyArgs>(args: SelectSubset<T, TaskLabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskLabel.
     * @param {TaskLabelUpsertArgs} args - Arguments to update or create a TaskLabel.
     * @example
     * // Update or create a TaskLabel
     * const taskLabel = await prisma.taskLabel.upsert({
     *   create: {
     *     // ... data to create a TaskLabel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLabel we want to update
     *   }
     * })
     */
    upsert<T extends TaskLabelUpsertArgs>(args: SelectSubset<T, TaskLabelUpsertArgs<ExtArgs>>): Prisma__TaskLabelClient<$Result.GetResult<Prisma.$TaskLabelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelCountArgs} args - Arguments to filter TaskLabels to count.
     * @example
     * // Count the number of TaskLabels
     * const count = await prisma.taskLabel.count({
     *   where: {
     *     // ... the filter for the TaskLabels we want to count
     *   }
     * })
    **/
    count<T extends TaskLabelCountArgs>(
      args?: Subset<T, TaskLabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLabelAggregateArgs>(args: Subset<T, TaskLabelAggregateArgs>): Prisma.PrismaPromise<GetTaskLabelAggregateType<T>>

    /**
     * Group by TaskLabel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLabelGroupByArgs['orderBy'] }
        : { orderBy?: TaskLabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLabel model
   */
  readonly fields: TaskLabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLabel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    label<T extends LabelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabelDefaultArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLabel model
   */ 
  interface TaskLabelFieldRefs {
    readonly taskId: FieldRef<"TaskLabel", 'Int'>
    readonly labelId: FieldRef<"TaskLabel", 'Int'>
    readonly createdAt: FieldRef<"TaskLabel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskLabel findUnique
   */
  export type TaskLabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findUniqueOrThrow
   */
  export type TaskLabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel findFirst
   */
  export type TaskLabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findFirstOrThrow
   */
  export type TaskLabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabel to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLabels.
     */
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel findMany
   */
  export type TaskLabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter, which TaskLabels to fetch.
     */
    where?: TaskLabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLabels to fetch.
     */
    orderBy?: TaskLabelOrderByWithRelationInput | TaskLabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLabels.
     */
    cursor?: TaskLabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLabels.
     */
    skip?: number
    distinct?: TaskLabelScalarFieldEnum | TaskLabelScalarFieldEnum[]
  }

  /**
   * TaskLabel create
   */
  export type TaskLabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLabel.
     */
    data: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
  }

  /**
   * TaskLabel createMany
   */
  export type TaskLabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLabels.
     */
    data: TaskLabelCreateManyInput | TaskLabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskLabel update
   */
  export type TaskLabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLabel.
     */
    data: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
    /**
     * Choose, which TaskLabel to update.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel updateMany
   */
  export type TaskLabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLabels.
     */
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyInput>
    /**
     * Filter which TaskLabels to update
     */
    where?: TaskLabelWhereInput
  }

  /**
   * TaskLabel upsert
   */
  export type TaskLabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLabel to update in case it exists.
     */
    where: TaskLabelWhereUniqueInput
    /**
     * In case the TaskLabel found by the `where` argument doesn't exist, create a new TaskLabel with this data.
     */
    create: XOR<TaskLabelCreateInput, TaskLabelUncheckedCreateInput>
    /**
     * In case the TaskLabel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLabelUpdateInput, TaskLabelUncheckedUpdateInput>
  }

  /**
   * TaskLabel delete
   */
  export type TaskLabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
    /**
     * Filter which TaskLabel to delete.
     */
    where: TaskLabelWhereUniqueInput
  }

  /**
   * TaskLabel deleteMany
   */
  export type TaskLabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLabels to delete
     */
    where?: TaskLabelWhereInput
  }

  /**
   * TaskLabel without action
   */
  export type TaskLabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLabel
     */
    select?: TaskLabelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLabelInclude<ExtArgs> | null
  }


  /**
   * Model TaskDependency
   */

  export type AggregateTaskDependency = {
    _count: TaskDependencyCountAggregateOutputType | null
    _avg: TaskDependencyAvgAggregateOutputType | null
    _sum: TaskDependencySumAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  export type TaskDependencyAvgAggregateOutputType = {
    taskId: number | null
    dependsOnTaskId: number | null
    createdById: number | null
  }

  export type TaskDependencySumAggregateOutputType = {
    taskId: number | null
    dependsOnTaskId: number | null
    createdById: number | null
  }

  export type TaskDependencyMinAggregateOutputType = {
    taskId: number | null
    dependsOnTaskId: number | null
    dependencyType: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type TaskDependencyMaxAggregateOutputType = {
    taskId: number | null
    dependsOnTaskId: number | null
    dependencyType: string | null
    createdById: number | null
    createdAt: Date | null
  }

  export type TaskDependencyCountAggregateOutputType = {
    taskId: number
    dependsOnTaskId: number
    dependencyType: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type TaskDependencyAvgAggregateInputType = {
    taskId?: true
    dependsOnTaskId?: true
    createdById?: true
  }

  export type TaskDependencySumAggregateInputType = {
    taskId?: true
    dependsOnTaskId?: true
    createdById?: true
  }

  export type TaskDependencyMinAggregateInputType = {
    taskId?: true
    dependsOnTaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
  }

  export type TaskDependencyMaxAggregateInputType = {
    taskId?: true
    dependsOnTaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
  }

  export type TaskDependencyCountAggregateInputType = {
    taskId?: true
    dependsOnTaskId?: true
    dependencyType?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type TaskDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependency to aggregate.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskDependencies
    **/
    _count?: true | TaskDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskDependencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskDependencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type GetTaskDependencyAggregateType<T extends TaskDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskDependency[P]>
      : GetScalarType<T[P], AggregateTaskDependency[P]>
  }




  export type TaskDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskDependencyWhereInput
    orderBy?: TaskDependencyOrderByWithAggregationInput | TaskDependencyOrderByWithAggregationInput[]
    by: TaskDependencyScalarFieldEnum[] | TaskDependencyScalarFieldEnum
    having?: TaskDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskDependencyCountAggregateInputType | true
    _avg?: TaskDependencyAvgAggregateInputType
    _sum?: TaskDependencySumAggregateInputType
    _min?: TaskDependencyMinAggregateInputType
    _max?: TaskDependencyMaxAggregateInputType
  }

  export type TaskDependencyGroupByOutputType = {
    taskId: number
    dependsOnTaskId: number
    dependencyType: string
    createdById: number
    createdAt: Date
    _count: TaskDependencyCountAggregateOutputType | null
    _avg: TaskDependencyAvgAggregateOutputType | null
    _sum: TaskDependencySumAggregateOutputType | null
    _min: TaskDependencyMinAggregateOutputType | null
    _max: TaskDependencyMaxAggregateOutputType | null
  }

  type GetTaskDependencyGroupByPayload<T extends TaskDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
        }
      >
    >


  export type TaskDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    taskId?: boolean
    dependsOnTaskId?: boolean
    dependencyType?: boolean
    createdById?: boolean
    createdAt?: boolean
    dependsOnTask?: boolean | TaskDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskDependency"]>


  export type TaskDependencySelectScalar = {
    taskId?: boolean
    dependsOnTaskId?: boolean
    dependencyType?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type TaskDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependsOnTask?: boolean | TaskDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskDependency"
    objects: {
      dependsOnTask: Prisma.$TaskPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      taskId: number
      dependsOnTaskId: number
      dependencyType: string
      createdById: number
      createdAt: Date
    }, ExtArgs["result"]["taskDependency"]>
    composites: {}
  }

  type TaskDependencyGetPayload<S extends boolean | null | undefined | TaskDependencyDefaultArgs> = $Result.GetResult<Prisma.$TaskDependencyPayload, S>

  type TaskDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskDependencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskDependencyCountAggregateInputType | true
    }

  export interface TaskDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskDependency'], meta: { name: 'TaskDependency' } }
    /**
     * Find zero or one TaskDependency that matches the filter.
     * @param {TaskDependencyFindUniqueArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskDependencyFindUniqueArgs>(args: SelectSubset<T, TaskDependencyFindUniqueArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskDependency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskDependencyFindUniqueOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskDependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskDependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskDependencyFindFirstArgs>(args?: SelectSubset<T, TaskDependencyFindFirstArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindFirstOrThrowArgs} args - Arguments to find a TaskDependency
     * @example
     * // Get one TaskDependency
     * const taskDependency = await prisma.taskDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskDependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskDependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany()
     * 
     * // Get first 10 TaskDependencies
     * const taskDependencies = await prisma.taskDependency.findMany({ take: 10 })
     * 
     * // Only select the `taskId`
     * const taskDependencyWithTaskIdOnly = await prisma.taskDependency.findMany({ select: { taskId: true } })
     * 
     */
    findMany<T extends TaskDependencyFindManyArgs>(args?: SelectSubset<T, TaskDependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskDependency.
     * @param {TaskDependencyCreateArgs} args - Arguments to create a TaskDependency.
     * @example
     * // Create one TaskDependency
     * const TaskDependency = await prisma.taskDependency.create({
     *   data: {
     *     // ... data to create a TaskDependency
     *   }
     * })
     * 
     */
    create<T extends TaskDependencyCreateArgs>(args: SelectSubset<T, TaskDependencyCreateArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskDependencies.
     * @param {TaskDependencyCreateManyArgs} args - Arguments to create many TaskDependencies.
     * @example
     * // Create many TaskDependencies
     * const taskDependency = await prisma.taskDependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskDependencyCreateManyArgs>(args?: SelectSubset<T, TaskDependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskDependency.
     * @param {TaskDependencyDeleteArgs} args - Arguments to delete one TaskDependency.
     * @example
     * // Delete one TaskDependency
     * const TaskDependency = await prisma.taskDependency.delete({
     *   where: {
     *     // ... filter to delete one TaskDependency
     *   }
     * })
     * 
     */
    delete<T extends TaskDependencyDeleteArgs>(args: SelectSubset<T, TaskDependencyDeleteArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskDependency.
     * @param {TaskDependencyUpdateArgs} args - Arguments to update one TaskDependency.
     * @example
     * // Update one TaskDependency
     * const taskDependency = await prisma.taskDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskDependencyUpdateArgs>(args: SelectSubset<T, TaskDependencyUpdateArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskDependencies.
     * @param {TaskDependencyDeleteManyArgs} args - Arguments to filter TaskDependencies to delete.
     * @example
     * // Delete a few TaskDependencies
     * const { count } = await prisma.taskDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDependencyDeleteManyArgs>(args?: SelectSubset<T, TaskDependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskDependencies
     * const taskDependency = await prisma.taskDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskDependencyUpdateManyArgs>(args: SelectSubset<T, TaskDependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskDependency.
     * @param {TaskDependencyUpsertArgs} args - Arguments to update or create a TaskDependency.
     * @example
     * // Update or create a TaskDependency
     * const taskDependency = await prisma.taskDependency.upsert({
     *   create: {
     *     // ... data to create a TaskDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskDependency we want to update
     *   }
     * })
     */
    upsert<T extends TaskDependencyUpsertArgs>(args: SelectSubset<T, TaskDependencyUpsertArgs<ExtArgs>>): Prisma__TaskDependencyClient<$Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyCountArgs} args - Arguments to filter TaskDependencies to count.
     * @example
     * // Count the number of TaskDependencies
     * const count = await prisma.taskDependency.count({
     *   where: {
     *     // ... the filter for the TaskDependencies we want to count
     *   }
     * })
    **/
    count<T extends TaskDependencyCountArgs>(
      args?: Subset<T, TaskDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskDependencyAggregateArgs>(args: Subset<T, TaskDependencyAggregateArgs>): Prisma.PrismaPromise<GetTaskDependencyAggregateType<T>>

    /**
     * Group by TaskDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskDependencyGroupByArgs['orderBy'] }
        : { orderBy?: TaskDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskDependency model
   */
  readonly fields: TaskDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dependsOnTask<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskDependency model
   */ 
  interface TaskDependencyFieldRefs {
    readonly taskId: FieldRef<"TaskDependency", 'Int'>
    readonly dependsOnTaskId: FieldRef<"TaskDependency", 'Int'>
    readonly dependencyType: FieldRef<"TaskDependency", 'String'>
    readonly createdById: FieldRef<"TaskDependency", 'Int'>
    readonly createdAt: FieldRef<"TaskDependency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskDependency findUnique
   */
  export type TaskDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency findUniqueOrThrow
   */
  export type TaskDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency findFirst
   */
  export type TaskDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency findFirstOrThrow
   */
  export type TaskDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependency to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskDependencies.
     */
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency findMany
   */
  export type TaskDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter, which TaskDependencies to fetch.
     */
    where?: TaskDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskDependencies to fetch.
     */
    orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskDependencies.
     */
    cursor?: TaskDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskDependencies.
     */
    skip?: number
    distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[]
  }

  /**
   * TaskDependency create
   */
  export type TaskDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskDependency.
     */
    data: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
  }

  /**
   * TaskDependency createMany
   */
  export type TaskDependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskDependencies.
     */
    data: TaskDependencyCreateManyInput | TaskDependencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskDependency update
   */
  export type TaskDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskDependency.
     */
    data: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
    /**
     * Choose, which TaskDependency to update.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency updateMany
   */
  export type TaskDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskDependencies.
     */
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyInput>
    /**
     * Filter which TaskDependencies to update
     */
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskDependency upsert
   */
  export type TaskDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskDependency to update in case it exists.
     */
    where: TaskDependencyWhereUniqueInput
    /**
     * In case the TaskDependency found by the `where` argument doesn't exist, create a new TaskDependency with this data.
     */
    create: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>
    /**
     * In case the TaskDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>
  }

  /**
   * TaskDependency delete
   */
  export type TaskDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
    /**
     * Filter which TaskDependency to delete.
     */
    where: TaskDependencyWhereUniqueInput
  }

  /**
   * TaskDependency deleteMany
   */
  export type TaskDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskDependencies to delete
     */
    where?: TaskDependencyWhereInput
  }

  /**
   * TaskDependency without action
   */
  export type TaskDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskDependency
     */
    select?: TaskDependencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskDependencyInclude<ExtArgs> | null
  }


  /**
   * Model TimeLog
   */

  export type AggregateTimeLog = {
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  export type TimeLogAvgAggregateOutputType = {
    id: number | null
    hoursLogged: number | null
    userId: number | null
    taskId: number | null
    subtaskId: number | null
  }

  export type TimeLogSumAggregateOutputType = {
    id: number | null
    hoursLogged: number | null
    userId: number | null
    taskId: number | null
    subtaskId: number | null
  }

  export type TimeLogMinAggregateOutputType = {
    id: number | null
    hoursLogged: number | null
    description: string | null
    logDate: Date | null
    createdAt: Date | null
    userId: number | null
    taskId: number | null
    subtaskId: number | null
  }

  export type TimeLogMaxAggregateOutputType = {
    id: number | null
    hoursLogged: number | null
    description: string | null
    logDate: Date | null
    createdAt: Date | null
    userId: number | null
    taskId: number | null
    subtaskId: number | null
  }

  export type TimeLogCountAggregateOutputType = {
    id: number
    hoursLogged: number
    description: number
    logDate: number
    createdAt: number
    userId: number
    taskId: number
    subtaskId: number
    _all: number
  }


  export type TimeLogAvgAggregateInputType = {
    id?: true
    hoursLogged?: true
    userId?: true
    taskId?: true
    subtaskId?: true
  }

  export type TimeLogSumAggregateInputType = {
    id?: true
    hoursLogged?: true
    userId?: true
    taskId?: true
    subtaskId?: true
  }

  export type TimeLogMinAggregateInputType = {
    id?: true
    hoursLogged?: true
    description?: true
    logDate?: true
    createdAt?: true
    userId?: true
    taskId?: true
    subtaskId?: true
  }

  export type TimeLogMaxAggregateInputType = {
    id?: true
    hoursLogged?: true
    description?: true
    logDate?: true
    createdAt?: true
    userId?: true
    taskId?: true
    subtaskId?: true
  }

  export type TimeLogCountAggregateInputType = {
    id?: true
    hoursLogged?: true
    description?: true
    logDate?: true
    createdAt?: true
    userId?: true
    taskId?: true
    subtaskId?: true
    _all?: true
  }

  export type TimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLog to aggregate.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeLogs
    **/
    _count?: true | TimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeLogMaxAggregateInputType
  }

  export type GetTimeLogAggregateType<T extends TimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeLog[P]>
      : GetScalarType<T[P], AggregateTimeLog[P]>
  }




  export type TimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithAggregationInput | TimeLogOrderByWithAggregationInput[]
    by: TimeLogScalarFieldEnum[] | TimeLogScalarFieldEnum
    having?: TimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeLogCountAggregateInputType | true
    _avg?: TimeLogAvgAggregateInputType
    _sum?: TimeLogSumAggregateInputType
    _min?: TimeLogMinAggregateInputType
    _max?: TimeLogMaxAggregateInputType
  }

  export type TimeLogGroupByOutputType = {
    id: number
    hoursLogged: number
    description: string | null
    logDate: Date
    createdAt: Date
    userId: number
    taskId: number | null
    subtaskId: number | null
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  type GetTimeLogGroupByPayload<T extends TimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
        }
      >
    >


  export type TimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hoursLogged?: boolean
    description?: boolean
    logDate?: boolean
    createdAt?: boolean
    userId?: boolean
    taskId?: boolean
    subtaskId?: boolean
    subtask?: boolean | TimeLog$subtaskArgs<ExtArgs>
    task?: boolean | TimeLog$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>


  export type TimeLogSelectScalar = {
    id?: boolean
    hoursLogged?: boolean
    description?: boolean
    logDate?: boolean
    createdAt?: boolean
    userId?: boolean
    taskId?: boolean
    subtaskId?: boolean
  }

  export type TimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtask?: boolean | TimeLog$subtaskArgs<ExtArgs>
    task?: boolean | TimeLog$taskArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeLog"
    objects: {
      subtask: Prisma.$SubtaskPayload<ExtArgs> | null
      task: Prisma.$TaskPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hoursLogged: number
      description: string | null
      logDate: Date
      createdAt: Date
      userId: number
      taskId: number | null
      subtaskId: number | null
    }, ExtArgs["result"]["timeLog"]>
    composites: {}
  }

  type TimeLogGetPayload<S extends boolean | null | undefined | TimeLogDefaultArgs> = $Result.GetResult<Prisma.$TimeLogPayload, S>

  type TimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeLogCountAggregateInputType | true
    }

  export interface TimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeLog'], meta: { name: 'TimeLog' } }
    /**
     * Find zero or one TimeLog that matches the filter.
     * @param {TimeLogFindUniqueArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeLogFindUniqueArgs>(args: SelectSubset<T, TimeLogFindUniqueArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeLogFindUniqueOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeLogFindFirstArgs>(args?: SelectSubset<T, TimeLogFindFirstArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeLogs
     * const timeLogs = await prisma.timeLog.findMany()
     * 
     * // Get first 10 TimeLogs
     * const timeLogs = await prisma.timeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeLogFindManyArgs>(args?: SelectSubset<T, TimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeLog.
     * @param {TimeLogCreateArgs} args - Arguments to create a TimeLog.
     * @example
     * // Create one TimeLog
     * const TimeLog = await prisma.timeLog.create({
     *   data: {
     *     // ... data to create a TimeLog
     *   }
     * })
     * 
     */
    create<T extends TimeLogCreateArgs>(args: SelectSubset<T, TimeLogCreateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeLogs.
     * @param {TimeLogCreateManyArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeLogCreateManyArgs>(args?: SelectSubset<T, TimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TimeLog.
     * @param {TimeLogDeleteArgs} args - Arguments to delete one TimeLog.
     * @example
     * // Delete one TimeLog
     * const TimeLog = await prisma.timeLog.delete({
     *   where: {
     *     // ... filter to delete one TimeLog
     *   }
     * })
     * 
     */
    delete<T extends TimeLogDeleteArgs>(args: SelectSubset<T, TimeLogDeleteArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeLog.
     * @param {TimeLogUpdateArgs} args - Arguments to update one TimeLog.
     * @example
     * // Update one TimeLog
     * const timeLog = await prisma.timeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeLogUpdateArgs>(args: SelectSubset<T, TimeLogUpdateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeLogs.
     * @param {TimeLogDeleteManyArgs} args - Arguments to filter TimeLogs to delete.
     * @example
     * // Delete a few TimeLogs
     * const { count } = await prisma.timeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeLogDeleteManyArgs>(args?: SelectSubset<T, TimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeLogUpdateManyArgs>(args: SelectSubset<T, TimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeLog.
     * @param {TimeLogUpsertArgs} args - Arguments to update or create a TimeLog.
     * @example
     * // Update or create a TimeLog
     * const timeLog = await prisma.timeLog.upsert({
     *   create: {
     *     // ... data to create a TimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeLog we want to update
     *   }
     * })
     */
    upsert<T extends TimeLogUpsertArgs>(args: SelectSubset<T, TimeLogUpsertArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogCountArgs} args - Arguments to filter TimeLogs to count.
     * @example
     * // Count the number of TimeLogs
     * const count = await prisma.timeLog.count({
     *   where: {
     *     // ... the filter for the TimeLogs we want to count
     *   }
     * })
    **/
    count<T extends TimeLogCountArgs>(
      args?: Subset<T, TimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeLogAggregateArgs>(args: Subset<T, TimeLogAggregateArgs>): Prisma.PrismaPromise<GetTimeLogAggregateType<T>>

    /**
     * Group by TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeLogGroupByArgs['orderBy'] }
        : { orderBy?: TimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeLog model
   */
  readonly fields: TimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subtask<T extends TimeLog$subtaskArgs<ExtArgs> = {}>(args?: Subset<T, TimeLog$subtaskArgs<ExtArgs>>): Prisma__SubtaskClient<$Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task<T extends TimeLog$taskArgs<ExtArgs> = {}>(args?: Subset<T, TimeLog$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeLog model
   */ 
  interface TimeLogFieldRefs {
    readonly id: FieldRef<"TimeLog", 'Int'>
    readonly hoursLogged: FieldRef<"TimeLog", 'Float'>
    readonly description: FieldRef<"TimeLog", 'String'>
    readonly logDate: FieldRef<"TimeLog", 'DateTime'>
    readonly createdAt: FieldRef<"TimeLog", 'DateTime'>
    readonly userId: FieldRef<"TimeLog", 'Int'>
    readonly taskId: FieldRef<"TimeLog", 'Int'>
    readonly subtaskId: FieldRef<"TimeLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TimeLog findUnique
   */
  export type TimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findUniqueOrThrow
   */
  export type TimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findFirst
   */
  export type TimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findFirstOrThrow
   */
  export type TimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findMany
   */
  export type TimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLogs to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog create
   */
  export type TimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeLog.
     */
    data: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
  }

  /**
   * TimeLog createMany
   */
  export type TimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeLog update
   */
  export type TimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeLog.
     */
    data: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
    /**
     * Choose, which TimeLog to update.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog updateMany
   */
  export type TimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
  }

  /**
   * TimeLog upsert
   */
  export type TimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeLog to update in case it exists.
     */
    where: TimeLogWhereUniqueInput
    /**
     * In case the TimeLog found by the `where` argument doesn't exist, create a new TimeLog with this data.
     */
    create: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
    /**
     * In case the TimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
  }

  /**
   * TimeLog delete
   */
  export type TimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter which TimeLog to delete.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog deleteMany
   */
  export type TimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLogs to delete
     */
    where?: TimeLogWhereInput
  }

  /**
   * TimeLog.subtask
   */
  export type TimeLog$subtaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtask
     */
    select?: SubtaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtaskInclude<ExtArgs> | null
    where?: SubtaskWhereInput
  }

  /**
   * TimeLog.task
   */
  export type TimeLog$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * TimeLog without action
   */
  export type TimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
  }


  /**
   * Model AutomationRule
   */

  export type AggregateAutomationRule = {
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  export type AutomationRuleAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    teamId: number | null
  }

  export type AutomationRuleSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    teamId: number | null
  }

  export type AutomationRuleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    triggerType: string | null
    triggerCondition: string | null
    actionType: string | null
    actionConfig: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdById: number | null
    teamId: number | null
  }

  export type AutomationRuleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    triggerType: string | null
    triggerCondition: string | null
    actionType: string | null
    actionConfig: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdById: number | null
    teamId: number | null
  }

  export type AutomationRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    triggerType: number
    triggerCondition: number
    actionType: number
    actionConfig: number
    isActive: number
    createdAt: number
    createdById: number
    teamId: number
    _all: number
  }


  export type AutomationRuleAvgAggregateInputType = {
    id?: true
    createdById?: true
    teamId?: true
  }

  export type AutomationRuleSumAggregateInputType = {
    id?: true
    createdById?: true
    teamId?: true
  }

  export type AutomationRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerType?: true
    triggerCondition?: true
    actionType?: true
    actionConfig?: true
    isActive?: true
    createdAt?: true
    createdById?: true
    teamId?: true
  }

  export type AutomationRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerType?: true
    triggerCondition?: true
    actionType?: true
    actionConfig?: true
    isActive?: true
    createdAt?: true
    createdById?: true
    teamId?: true
  }

  export type AutomationRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    triggerType?: true
    triggerCondition?: true
    actionType?: true
    actionConfig?: true
    isActive?: true
    createdAt?: true
    createdById?: true
    teamId?: true
    _all?: true
  }

  export type AutomationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRule to aggregate.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationRules
    **/
    _count?: true | AutomationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomationRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomationRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type GetAutomationRuleAggregateType<T extends AutomationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationRule[P]>
      : GetScalarType<T[P], AggregateAutomationRule[P]>
  }




  export type AutomationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationRuleWhereInput
    orderBy?: AutomationRuleOrderByWithAggregationInput | AutomationRuleOrderByWithAggregationInput[]
    by: AutomationRuleScalarFieldEnum[] | AutomationRuleScalarFieldEnum
    having?: AutomationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationRuleCountAggregateInputType | true
    _avg?: AutomationRuleAvgAggregateInputType
    _sum?: AutomationRuleSumAggregateInputType
    _min?: AutomationRuleMinAggregateInputType
    _max?: AutomationRuleMaxAggregateInputType
  }

  export type AutomationRuleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    triggerType: string
    triggerCondition: string | null
    actionType: string
    actionConfig: string | null
    isActive: boolean
    createdAt: Date
    createdById: number
    teamId: number | null
    _count: AutomationRuleCountAggregateOutputType | null
    _avg: AutomationRuleAvgAggregateOutputType | null
    _sum: AutomationRuleSumAggregateOutputType | null
    _min: AutomationRuleMinAggregateOutputType | null
    _max: AutomationRuleMaxAggregateOutputType | null
  }

  type GetAutomationRuleGroupByPayload<T extends AutomationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationRuleGroupByOutputType[P]>
        }
      >
    >


  export type AutomationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerCondition?: boolean
    actionType?: boolean
    actionConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdById?: boolean
    teamId?: boolean
    team?: boolean | AutomationRule$teamArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationRule"]>


  export type AutomationRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    triggerType?: boolean
    triggerCondition?: boolean
    actionType?: boolean
    actionConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdById?: boolean
    teamId?: boolean
  }

  export type AutomationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | AutomationRule$teamArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutomationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationRule"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      triggerType: string
      triggerCondition: string | null
      actionType: string
      actionConfig: string | null
      isActive: boolean
      createdAt: Date
      createdById: number
      teamId: number | null
    }, ExtArgs["result"]["automationRule"]>
    composites: {}
  }

  type AutomationRuleGetPayload<S extends boolean | null | undefined | AutomationRuleDefaultArgs> = $Result.GetResult<Prisma.$AutomationRulePayload, S>

  type AutomationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AutomationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomationRuleCountAggregateInputType | true
    }

  export interface AutomationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationRule'], meta: { name: 'AutomationRule' } }
    /**
     * Find zero or one AutomationRule that matches the filter.
     * @param {AutomationRuleFindUniqueArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationRuleFindUniqueArgs>(args: SelectSubset<T, AutomationRuleFindUniqueArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AutomationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AutomationRuleFindUniqueOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AutomationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationRuleFindFirstArgs>(args?: SelectSubset<T, AutomationRuleFindFirstArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AutomationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindFirstOrThrowArgs} args - Arguments to find a AutomationRule
     * @example
     * // Get one AutomationRule
     * const automationRule = await prisma.automationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AutomationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationRules
     * const automationRules = await prisma.automationRule.findMany()
     * 
     * // Get first 10 AutomationRules
     * const automationRules = await prisma.automationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationRuleWithIdOnly = await prisma.automationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationRuleFindManyArgs>(args?: SelectSubset<T, AutomationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AutomationRule.
     * @param {AutomationRuleCreateArgs} args - Arguments to create a AutomationRule.
     * @example
     * // Create one AutomationRule
     * const AutomationRule = await prisma.automationRule.create({
     *   data: {
     *     // ... data to create a AutomationRule
     *   }
     * })
     * 
     */
    create<T extends AutomationRuleCreateArgs>(args: SelectSubset<T, AutomationRuleCreateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AutomationRules.
     * @param {AutomationRuleCreateManyArgs} args - Arguments to create many AutomationRules.
     * @example
     * // Create many AutomationRules
     * const automationRule = await prisma.automationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationRuleCreateManyArgs>(args?: SelectSubset<T, AutomationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutomationRule.
     * @param {AutomationRuleDeleteArgs} args - Arguments to delete one AutomationRule.
     * @example
     * // Delete one AutomationRule
     * const AutomationRule = await prisma.automationRule.delete({
     *   where: {
     *     // ... filter to delete one AutomationRule
     *   }
     * })
     * 
     */
    delete<T extends AutomationRuleDeleteArgs>(args: SelectSubset<T, AutomationRuleDeleteArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AutomationRule.
     * @param {AutomationRuleUpdateArgs} args - Arguments to update one AutomationRule.
     * @example
     * // Update one AutomationRule
     * const automationRule = await prisma.automationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationRuleUpdateArgs>(args: SelectSubset<T, AutomationRuleUpdateArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AutomationRules.
     * @param {AutomationRuleDeleteManyArgs} args - Arguments to filter AutomationRules to delete.
     * @example
     * // Delete a few AutomationRules
     * const { count } = await prisma.automationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationRuleDeleteManyArgs>(args?: SelectSubset<T, AutomationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationRules
     * const automationRule = await prisma.automationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationRuleUpdateManyArgs>(args: SelectSubset<T, AutomationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutomationRule.
     * @param {AutomationRuleUpsertArgs} args - Arguments to update or create a AutomationRule.
     * @example
     * // Update or create a AutomationRule
     * const automationRule = await prisma.automationRule.upsert({
     *   create: {
     *     // ... data to create a AutomationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationRule we want to update
     *   }
     * })
     */
    upsert<T extends AutomationRuleUpsertArgs>(args: SelectSubset<T, AutomationRuleUpsertArgs<ExtArgs>>): Prisma__AutomationRuleClient<$Result.GetResult<Prisma.$AutomationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AutomationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleCountArgs} args - Arguments to filter AutomationRules to count.
     * @example
     * // Count the number of AutomationRules
     * const count = await prisma.automationRule.count({
     *   where: {
     *     // ... the filter for the AutomationRules we want to count
     *   }
     * })
    **/
    count<T extends AutomationRuleCountArgs>(
      args?: Subset<T, AutomationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationRuleAggregateArgs>(args: Subset<T, AutomationRuleAggregateArgs>): Prisma.PrismaPromise<GetAutomationRuleAggregateType<T>>

    /**
     * Group by AutomationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationRuleGroupByArgs['orderBy'] }
        : { orderBy?: AutomationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationRule model
   */
  readonly fields: AutomationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends AutomationRule$teamArgs<ExtArgs> = {}>(args?: Subset<T, AutomationRule$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationRule model
   */ 
  interface AutomationRuleFieldRefs {
    readonly id: FieldRef<"AutomationRule", 'Int'>
    readonly name: FieldRef<"AutomationRule", 'String'>
    readonly description: FieldRef<"AutomationRule", 'String'>
    readonly triggerType: FieldRef<"AutomationRule", 'String'>
    readonly triggerCondition: FieldRef<"AutomationRule", 'String'>
    readonly actionType: FieldRef<"AutomationRule", 'String'>
    readonly actionConfig: FieldRef<"AutomationRule", 'String'>
    readonly isActive: FieldRef<"AutomationRule", 'Boolean'>
    readonly createdAt: FieldRef<"AutomationRule", 'DateTime'>
    readonly createdById: FieldRef<"AutomationRule", 'Int'>
    readonly teamId: FieldRef<"AutomationRule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AutomationRule findUnique
   */
  export type AutomationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findUniqueOrThrow
   */
  export type AutomationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule findFirst
   */
  export type AutomationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findFirstOrThrow
   */
  export type AutomationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRule to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationRules.
     */
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule findMany
   */
  export type AutomationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter, which AutomationRules to fetch.
     */
    where?: AutomationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationRules to fetch.
     */
    orderBy?: AutomationRuleOrderByWithRelationInput | AutomationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationRules.
     */
    cursor?: AutomationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationRules.
     */
    skip?: number
    distinct?: AutomationRuleScalarFieldEnum | AutomationRuleScalarFieldEnum[]
  }

  /**
   * AutomationRule create
   */
  export type AutomationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationRule.
     */
    data: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
  }

  /**
   * AutomationRule createMany
   */
  export type AutomationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationRules.
     */
    data: AutomationRuleCreateManyInput | AutomationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationRule update
   */
  export type AutomationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationRule.
     */
    data: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
    /**
     * Choose, which AutomationRule to update.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule updateMany
   */
  export type AutomationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationRules.
     */
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyInput>
    /**
     * Filter which AutomationRules to update
     */
    where?: AutomationRuleWhereInput
  }

  /**
   * AutomationRule upsert
   */
  export type AutomationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationRule to update in case it exists.
     */
    where: AutomationRuleWhereUniqueInput
    /**
     * In case the AutomationRule found by the `where` argument doesn't exist, create a new AutomationRule with this data.
     */
    create: XOR<AutomationRuleCreateInput, AutomationRuleUncheckedCreateInput>
    /**
     * In case the AutomationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationRuleUpdateInput, AutomationRuleUncheckedUpdateInput>
  }

  /**
   * AutomationRule delete
   */
  export type AutomationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
    /**
     * Filter which AutomationRule to delete.
     */
    where: AutomationRuleWhereUniqueInput
  }

  /**
   * AutomationRule deleteMany
   */
  export type AutomationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationRules to delete
     */
    where?: AutomationRuleWhereInput
  }

  /**
   * AutomationRule.team
   */
  export type AutomationRule$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * AutomationRule without action
   */
  export type AutomationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationRule
     */
    select?: AutomationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationRuleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    isRead: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string
    message: string
    type: string
    isRead: boolean
    createdAt: Date
    userId: number
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      message: string
      type: string
      isRead: boolean
      createdAt: Date
      userId: number
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    performedById: number | null
    affectedUserId: number | null
    projectId: number | null
    entityId: number | null
    userId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    performedById: number | null
    affectedUserId: number | null
    projectId: number | null
    entityId: number | null
    userId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    actionType: string | null
    actionCategory: string | null
    actionSummary: string | null
    actionDetails: string | null
    performedById: number | null
    affectedUserId: number | null
    projectId: number | null
    entityType: string | null
    entityId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    action: string | null
    description: string | null
    userId: number | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    actionType: string | null
    actionCategory: string | null
    actionSummary: string | null
    actionDetails: string | null
    performedById: number | null
    affectedUserId: number | null
    projectId: number | null
    entityType: string | null
    entityId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    action: string | null
    description: string | null
    userId: number | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    actionType: number
    actionCategory: number
    actionSummary: number
    actionDetails: number
    performedById: number
    affectedUserId: number
    projectId: number
    entityType: number
    entityId: number
    ipAddress: number
    userAgent: number
    createdAt: number
    action: number
    description: number
    userId: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    performedById?: true
    affectedUserId?: true
    projectId?: true
    entityId?: true
    userId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    performedById?: true
    affectedUserId?: true
    projectId?: true
    entityId?: true
    userId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    actionType?: true
    actionCategory?: true
    actionSummary?: true
    actionDetails?: true
    performedById?: true
    affectedUserId?: true
    projectId?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    action?: true
    description?: true
    userId?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    actionType?: true
    actionCategory?: true
    actionSummary?: true
    actionDetails?: true
    performedById?: true
    affectedUserId?: true
    projectId?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    action?: true
    description?: true
    userId?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    actionType?: true
    actionCategory?: true
    actionSummary?: true
    actionDetails?: true
    performedById?: true
    affectedUserId?: true
    projectId?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    action?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    actionType: string | null
    actionCategory: string | null
    actionSummary: string | null
    actionDetails: string | null
    performedById: number | null
    affectedUserId: number | null
    projectId: number | null
    entityType: string | null
    entityId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    action: string | null
    description: string | null
    userId: number | null
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    actionCategory?: boolean
    actionSummary?: boolean
    actionDetails?: boolean
    performedById?: boolean
    affectedUserId?: boolean
    projectId?: boolean
    entityType?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    action?: boolean
    description?: boolean
    userId?: boolean
    performedBy?: boolean | ActivityLog$performedByArgs<ExtArgs>
    affectedUser?: boolean | ActivityLog$affectedUserArgs<ExtArgs>
    project?: boolean | ActivityLog$projectArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>


  export type ActivityLogSelectScalar = {
    id?: boolean
    actionType?: boolean
    actionCategory?: boolean
    actionSummary?: boolean
    actionDetails?: boolean
    performedById?: boolean
    affectedUserId?: boolean
    projectId?: boolean
    entityType?: boolean
    entityId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    action?: boolean
    description?: boolean
    userId?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performedBy?: boolean | ActivityLog$performedByArgs<ExtArgs>
    affectedUser?: boolean | ActivityLog$affectedUserArgs<ExtArgs>
    project?: boolean | ActivityLog$projectArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      performedBy: Prisma.$UserPayload<ExtArgs> | null
      affectedUser: Prisma.$UserPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actionType: string | null
      actionCategory: string | null
      actionSummary: string | null
      actionDetails: string | null
      performedById: number | null
      affectedUserId: number | null
      projectId: number | null
      entityType: string | null
      entityId: number | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      action: string | null
      description: string | null
      userId: number | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performedBy<T extends ActivityLog$performedByArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$performedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    affectedUser<T extends ActivityLog$affectedUserArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$affectedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends ActivityLog$projectArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly actionType: FieldRef<"ActivityLog", 'String'>
    readonly actionCategory: FieldRef<"ActivityLog", 'String'>
    readonly actionSummary: FieldRef<"ActivityLog", 'String'>
    readonly actionDetails: FieldRef<"ActivityLog", 'String'>
    readonly performedById: FieldRef<"ActivityLog", 'Int'>
    readonly affectedUserId: FieldRef<"ActivityLog", 'Int'>
    readonly projectId: FieldRef<"ActivityLog", 'Int'>
    readonly entityType: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'Int'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data?: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog.performedBy
   */
  export type ActivityLog$performedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog.affectedUser
   */
  export type ActivityLog$affectedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog.project
   */
  export type ActivityLog$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model ProjectUser
   */

  export type AggregateProjectUser = {
    _count: ProjectUserCountAggregateOutputType | null
    _avg: ProjectUserAvgAggregateOutputType | null
    _sum: ProjectUserSumAggregateOutputType | null
    _min: ProjectUserMinAggregateOutputType | null
    _max: ProjectUserMaxAggregateOutputType | null
  }

  export type ProjectUserAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    allocationPercentage: number | null
  }

  export type ProjectUserSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    allocationPercentage: number | null
  }

  export type ProjectUserMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: string | null
    allocationPercentage: number | null
    joinedAt: Date | null
    leftAt: Date | null
    createdAt: Date | null
  }

  export type ProjectUserMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    role: string | null
    allocationPercentage: number | null
    joinedAt: Date | null
    leftAt: Date | null
    createdAt: Date | null
  }

  export type ProjectUserCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    allocationPercentage: number
    joinedAt: number
    leftAt: number
    createdAt: number
    _all: number
  }


  export type ProjectUserAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    allocationPercentage?: true
  }

  export type ProjectUserSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    allocationPercentage?: true
  }

  export type ProjectUserMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    allocationPercentage?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
  }

  export type ProjectUserMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    allocationPercentage?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
  }

  export type ProjectUserCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    allocationPercentage?: true
    joinedAt?: true
    leftAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUser to aggregate.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUsers
    **/
    _count?: true | ProjectUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUserMaxAggregateInputType
  }

  export type GetProjectUserAggregateType<T extends ProjectUserAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUser[P]>
      : GetScalarType<T[P], AggregateProjectUser[P]>
  }




  export type ProjectUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUserWhereInput
    orderBy?: ProjectUserOrderByWithAggregationInput | ProjectUserOrderByWithAggregationInput[]
    by: ProjectUserScalarFieldEnum[] | ProjectUserScalarFieldEnum
    having?: ProjectUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUserCountAggregateInputType | true
    _avg?: ProjectUserAvgAggregateInputType
    _sum?: ProjectUserSumAggregateInputType
    _min?: ProjectUserMinAggregateInputType
    _max?: ProjectUserMaxAggregateInputType
  }

  export type ProjectUserGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    role: string
    allocationPercentage: number
    joinedAt: Date
    leftAt: Date | null
    createdAt: Date
    _count: ProjectUserCountAggregateOutputType | null
    _avg: ProjectUserAvgAggregateOutputType | null
    _sum: ProjectUserSumAggregateOutputType | null
    _min: ProjectUserMinAggregateOutputType | null
    _max: ProjectUserMaxAggregateOutputType | null
  }

  type GetProjectUserGroupByPayload<T extends ProjectUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUserGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUserGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    allocationPercentage?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUser"]>


  export type ProjectUserSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    allocationPercentage?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    createdAt?: boolean
  }

  export type ProjectUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectUser"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      role: string
      allocationPercentage: number
      joinedAt: Date
      leftAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["projectUser"]>
    composites: {}
  }

  type ProjectUserGetPayload<S extends boolean | null | undefined | ProjectUserDefaultArgs> = $Result.GetResult<Prisma.$ProjectUserPayload, S>

  type ProjectUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectUserCountAggregateInputType | true
    }

  export interface ProjectUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectUser'], meta: { name: 'ProjectUser' } }
    /**
     * Find zero or one ProjectUser that matches the filter.
     * @param {ProjectUserFindUniqueArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectUserFindUniqueArgs>(args: SelectSubset<T, ProjectUserFindUniqueArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectUserFindUniqueOrThrowArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindFirstArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectUserFindFirstArgs>(args?: SelectSubset<T, ProjectUserFindFirstArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindFirstOrThrowArgs} args - Arguments to find a ProjectUser
     * @example
     * // Get one ProjectUser
     * const projectUser = await prisma.projectUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUsers
     * const projectUsers = await prisma.projectUser.findMany()
     * 
     * // Get first 10 ProjectUsers
     * const projectUsers = await prisma.projectUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectUserWithIdOnly = await prisma.projectUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectUserFindManyArgs>(args?: SelectSubset<T, ProjectUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectUser.
     * @param {ProjectUserCreateArgs} args - Arguments to create a ProjectUser.
     * @example
     * // Create one ProjectUser
     * const ProjectUser = await prisma.projectUser.create({
     *   data: {
     *     // ... data to create a ProjectUser
     *   }
     * })
     * 
     */
    create<T extends ProjectUserCreateArgs>(args: SelectSubset<T, ProjectUserCreateArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectUsers.
     * @param {ProjectUserCreateManyArgs} args - Arguments to create many ProjectUsers.
     * @example
     * // Create many ProjectUsers
     * const projectUser = await prisma.projectUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectUserCreateManyArgs>(args?: SelectSubset<T, ProjectUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectUser.
     * @param {ProjectUserDeleteArgs} args - Arguments to delete one ProjectUser.
     * @example
     * // Delete one ProjectUser
     * const ProjectUser = await prisma.projectUser.delete({
     *   where: {
     *     // ... filter to delete one ProjectUser
     *   }
     * })
     * 
     */
    delete<T extends ProjectUserDeleteArgs>(args: SelectSubset<T, ProjectUserDeleteArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectUser.
     * @param {ProjectUserUpdateArgs} args - Arguments to update one ProjectUser.
     * @example
     * // Update one ProjectUser
     * const projectUser = await prisma.projectUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUserUpdateArgs>(args: SelectSubset<T, ProjectUserUpdateArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectUsers.
     * @param {ProjectUserDeleteManyArgs} args - Arguments to filter ProjectUsers to delete.
     * @example
     * // Delete a few ProjectUsers
     * const { count } = await prisma.projectUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectUserDeleteManyArgs>(args?: SelectSubset<T, ProjectUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUsers
     * const projectUser = await prisma.projectUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUserUpdateManyArgs>(args: SelectSubset<T, ProjectUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectUser.
     * @param {ProjectUserUpsertArgs} args - Arguments to update or create a ProjectUser.
     * @example
     * // Update or create a ProjectUser
     * const projectUser = await prisma.projectUser.upsert({
     *   create: {
     *     // ... data to create a ProjectUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUser we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUserUpsertArgs>(args: SelectSubset<T, ProjectUserUpsertArgs<ExtArgs>>): Prisma__ProjectUserClient<$Result.GetResult<Prisma.$ProjectUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserCountArgs} args - Arguments to filter ProjectUsers to count.
     * @example
     * // Count the number of ProjectUsers
     * const count = await prisma.projectUser.count({
     *   where: {
     *     // ... the filter for the ProjectUsers we want to count
     *   }
     * })
    **/
    count<T extends ProjectUserCountArgs>(
      args?: Subset<T, ProjectUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUserAggregateArgs>(args: Subset<T, ProjectUserAggregateArgs>): Prisma.PrismaPromise<GetProjectUserAggregateType<T>>

    /**
     * Group by ProjectUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUserGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectUser model
   */
  readonly fields: ProjectUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectUser model
   */ 
  interface ProjectUserFieldRefs {
    readonly id: FieldRef<"ProjectUser", 'Int'>
    readonly projectId: FieldRef<"ProjectUser", 'Int'>
    readonly userId: FieldRef<"ProjectUser", 'Int'>
    readonly role: FieldRef<"ProjectUser", 'String'>
    readonly allocationPercentage: FieldRef<"ProjectUser", 'Int'>
    readonly joinedAt: FieldRef<"ProjectUser", 'DateTime'>
    readonly leftAt: FieldRef<"ProjectUser", 'DateTime'>
    readonly createdAt: FieldRef<"ProjectUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectUser findUnique
   */
  export type ProjectUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser findUniqueOrThrow
   */
  export type ProjectUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser findFirst
   */
  export type ProjectUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser findFirstOrThrow
   */
  export type ProjectUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUser to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUsers.
     */
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser findMany
   */
  export type ProjectUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUsers to fetch.
     */
    where?: ProjectUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUsers to fetch.
     */
    orderBy?: ProjectUserOrderByWithRelationInput | ProjectUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUsers.
     */
    cursor?: ProjectUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUsers.
     */
    skip?: number
    distinct?: ProjectUserScalarFieldEnum | ProjectUserScalarFieldEnum[]
  }

  /**
   * ProjectUser create
   */
  export type ProjectUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectUser.
     */
    data: XOR<ProjectUserCreateInput, ProjectUserUncheckedCreateInput>
  }

  /**
   * ProjectUser createMany
   */
  export type ProjectUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectUsers.
     */
    data: ProjectUserCreateManyInput | ProjectUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectUser update
   */
  export type ProjectUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectUser.
     */
    data: XOR<ProjectUserUpdateInput, ProjectUserUncheckedUpdateInput>
    /**
     * Choose, which ProjectUser to update.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser updateMany
   */
  export type ProjectUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectUsers.
     */
    data: XOR<ProjectUserUpdateManyMutationInput, ProjectUserUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUsers to update
     */
    where?: ProjectUserWhereInput
  }

  /**
   * ProjectUser upsert
   */
  export type ProjectUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectUser to update in case it exists.
     */
    where: ProjectUserWhereUniqueInput
    /**
     * In case the ProjectUser found by the `where` argument doesn't exist, create a new ProjectUser with this data.
     */
    create: XOR<ProjectUserCreateInput, ProjectUserUncheckedCreateInput>
    /**
     * In case the ProjectUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUserUpdateInput, ProjectUserUncheckedUpdateInput>
  }

  /**
   * ProjectUser delete
   */
  export type ProjectUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
    /**
     * Filter which ProjectUser to delete.
     */
    where: ProjectUserWhereUniqueInput
  }

  /**
   * ProjectUser deleteMany
   */
  export type ProjectUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUsers to delete
     */
    where?: ProjectUserWhereInput
  }

  /**
   * ProjectUser without action
   */
  export type ProjectUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUser
     */
    select?: ProjectUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUserInclude<ExtArgs> | null
  }


  /**
   * Model ProjectPhase
   */

  export type AggregateProjectPhase = {
    _count: ProjectPhaseCountAggregateOutputType | null
    _avg: ProjectPhaseAvgAggregateOutputType | null
    _sum: ProjectPhaseSumAggregateOutputType | null
    _min: ProjectPhaseMinAggregateOutputType | null
    _max: ProjectPhaseMaxAggregateOutputType | null
  }

  export type ProjectPhaseAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    sequenceOrder: number | null
  }

  export type ProjectPhaseSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    sequenceOrder: number | null
  }

  export type ProjectPhaseMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    sequenceOrder: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectPhaseMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    sequenceOrder: number | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ProjectPhaseCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    sequenceOrder: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    _all: number
  }


  export type ProjectPhaseAvgAggregateInputType = {
    id?: true
    projectId?: true
    sequenceOrder?: true
  }

  export type ProjectPhaseSumAggregateInputType = {
    id?: true
    projectId?: true
    sequenceOrder?: true
  }

  export type ProjectPhaseMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    sequenceOrder?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
  }

  export type ProjectPhaseMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    sequenceOrder?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
  }

  export type ProjectPhaseCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    sequenceOrder?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectPhase to aggregate.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectPhases
    **/
    _count?: true | ProjectPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectPhaseMaxAggregateInputType
  }

  export type GetProjectPhaseAggregateType<T extends ProjectPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectPhase[P]>
      : GetScalarType<T[P], AggregateProjectPhase[P]>
  }




  export type ProjectPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectPhaseWhereInput
    orderBy?: ProjectPhaseOrderByWithAggregationInput | ProjectPhaseOrderByWithAggregationInput[]
    by: ProjectPhaseScalarFieldEnum[] | ProjectPhaseScalarFieldEnum
    having?: ProjectPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectPhaseCountAggregateInputType | true
    _avg?: ProjectPhaseAvgAggregateInputType
    _sum?: ProjectPhaseSumAggregateInputType
    _min?: ProjectPhaseMinAggregateInputType
    _max?: ProjectPhaseMaxAggregateInputType
  }

  export type ProjectPhaseGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    sequenceOrder: number
    startDate: Date | null
    endDate: Date | null
    status: string
    createdAt: Date
    _count: ProjectPhaseCountAggregateOutputType | null
    _avg: ProjectPhaseAvgAggregateOutputType | null
    _sum: ProjectPhaseSumAggregateOutputType | null
    _min: ProjectPhaseMinAggregateOutputType | null
    _max: ProjectPhaseMaxAggregateOutputType | null
  }

  type GetProjectPhaseGroupByPayload<T extends ProjectPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectPhaseGroupByOutputType[P]>
        }
      >
    >


  export type ProjectPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    sequenceOrder?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectPhase"]>


  export type ProjectPhaseSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    sequenceOrder?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ProjectPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectPhase"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      sequenceOrder: number
      startDate: Date | null
      endDate: Date | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["projectPhase"]>
    composites: {}
  }

  type ProjectPhaseGetPayload<S extends boolean | null | undefined | ProjectPhaseDefaultArgs> = $Result.GetResult<Prisma.$ProjectPhasePayload, S>

  type ProjectPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectPhaseCountAggregateInputType | true
    }

  export interface ProjectPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectPhase'], meta: { name: 'ProjectPhase' } }
    /**
     * Find zero or one ProjectPhase that matches the filter.
     * @param {ProjectPhaseFindUniqueArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectPhaseFindUniqueArgs>(args: SelectSubset<T, ProjectPhaseFindUniqueArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectPhaseFindUniqueOrThrowArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindFirstArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectPhaseFindFirstArgs>(args?: SelectSubset<T, ProjectPhaseFindFirstArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindFirstOrThrowArgs} args - Arguments to find a ProjectPhase
     * @example
     * // Get one ProjectPhase
     * const projectPhase = await prisma.projectPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectPhases
     * const projectPhases = await prisma.projectPhase.findMany()
     * 
     * // Get first 10 ProjectPhases
     * const projectPhases = await prisma.projectPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectPhaseWithIdOnly = await prisma.projectPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectPhaseFindManyArgs>(args?: SelectSubset<T, ProjectPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectPhase.
     * @param {ProjectPhaseCreateArgs} args - Arguments to create a ProjectPhase.
     * @example
     * // Create one ProjectPhase
     * const ProjectPhase = await prisma.projectPhase.create({
     *   data: {
     *     // ... data to create a ProjectPhase
     *   }
     * })
     * 
     */
    create<T extends ProjectPhaseCreateArgs>(args: SelectSubset<T, ProjectPhaseCreateArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectPhases.
     * @param {ProjectPhaseCreateManyArgs} args - Arguments to create many ProjectPhases.
     * @example
     * // Create many ProjectPhases
     * const projectPhase = await prisma.projectPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectPhaseCreateManyArgs>(args?: SelectSubset<T, ProjectPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectPhase.
     * @param {ProjectPhaseDeleteArgs} args - Arguments to delete one ProjectPhase.
     * @example
     * // Delete one ProjectPhase
     * const ProjectPhase = await prisma.projectPhase.delete({
     *   where: {
     *     // ... filter to delete one ProjectPhase
     *   }
     * })
     * 
     */
    delete<T extends ProjectPhaseDeleteArgs>(args: SelectSubset<T, ProjectPhaseDeleteArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectPhase.
     * @param {ProjectPhaseUpdateArgs} args - Arguments to update one ProjectPhase.
     * @example
     * // Update one ProjectPhase
     * const projectPhase = await prisma.projectPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectPhaseUpdateArgs>(args: SelectSubset<T, ProjectPhaseUpdateArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectPhases.
     * @param {ProjectPhaseDeleteManyArgs} args - Arguments to filter ProjectPhases to delete.
     * @example
     * // Delete a few ProjectPhases
     * const { count } = await prisma.projectPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectPhaseDeleteManyArgs>(args?: SelectSubset<T, ProjectPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectPhases
     * const projectPhase = await prisma.projectPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectPhaseUpdateManyArgs>(args: SelectSubset<T, ProjectPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectPhase.
     * @param {ProjectPhaseUpsertArgs} args - Arguments to update or create a ProjectPhase.
     * @example
     * // Update or create a ProjectPhase
     * const projectPhase = await prisma.projectPhase.upsert({
     *   create: {
     *     // ... data to create a ProjectPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectPhase we want to update
     *   }
     * })
     */
    upsert<T extends ProjectPhaseUpsertArgs>(args: SelectSubset<T, ProjectPhaseUpsertArgs<ExtArgs>>): Prisma__ProjectPhaseClient<$Result.GetResult<Prisma.$ProjectPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseCountArgs} args - Arguments to filter ProjectPhases to count.
     * @example
     * // Count the number of ProjectPhases
     * const count = await prisma.projectPhase.count({
     *   where: {
     *     // ... the filter for the ProjectPhases we want to count
     *   }
     * })
    **/
    count<T extends ProjectPhaseCountArgs>(
      args?: Subset<T, ProjectPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectPhaseAggregateArgs>(args: Subset<T, ProjectPhaseAggregateArgs>): Prisma.PrismaPromise<GetProjectPhaseAggregateType<T>>

    /**
     * Group by ProjectPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectPhaseGroupByArgs['orderBy'] }
        : { orderBy?: ProjectPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectPhase model
   */
  readonly fields: ProjectPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectPhase model
   */ 
  interface ProjectPhaseFieldRefs {
    readonly id: FieldRef<"ProjectPhase", 'Int'>
    readonly projectId: FieldRef<"ProjectPhase", 'Int'>
    readonly name: FieldRef<"ProjectPhase", 'String'>
    readonly description: FieldRef<"ProjectPhase", 'String'>
    readonly sequenceOrder: FieldRef<"ProjectPhase", 'Int'>
    readonly startDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly endDate: FieldRef<"ProjectPhase", 'DateTime'>
    readonly status: FieldRef<"ProjectPhase", 'String'>
    readonly createdAt: FieldRef<"ProjectPhase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectPhase findUnique
   */
  export type ProjectPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase findUniqueOrThrow
   */
  export type ProjectPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase findFirst
   */
  export type ProjectPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectPhases.
     */
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase findFirstOrThrow
   */
  export type ProjectPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhase to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectPhases.
     */
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase findMany
   */
  export type ProjectPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter, which ProjectPhases to fetch.
     */
    where?: ProjectPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectPhases to fetch.
     */
    orderBy?: ProjectPhaseOrderByWithRelationInput | ProjectPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectPhases.
     */
    cursor?: ProjectPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectPhases.
     */
    skip?: number
    distinct?: ProjectPhaseScalarFieldEnum | ProjectPhaseScalarFieldEnum[]
  }

  /**
   * ProjectPhase create
   */
  export type ProjectPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectPhase.
     */
    data: XOR<ProjectPhaseCreateInput, ProjectPhaseUncheckedCreateInput>
  }

  /**
   * ProjectPhase createMany
   */
  export type ProjectPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectPhases.
     */
    data: ProjectPhaseCreateManyInput | ProjectPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectPhase update
   */
  export type ProjectPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectPhase.
     */
    data: XOR<ProjectPhaseUpdateInput, ProjectPhaseUncheckedUpdateInput>
    /**
     * Choose, which ProjectPhase to update.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase updateMany
   */
  export type ProjectPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectPhases.
     */
    data: XOR<ProjectPhaseUpdateManyMutationInput, ProjectPhaseUncheckedUpdateManyInput>
    /**
     * Filter which ProjectPhases to update
     */
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhase upsert
   */
  export type ProjectPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectPhase to update in case it exists.
     */
    where: ProjectPhaseWhereUniqueInput
    /**
     * In case the ProjectPhase found by the `where` argument doesn't exist, create a new ProjectPhase with this data.
     */
    create: XOR<ProjectPhaseCreateInput, ProjectPhaseUncheckedCreateInput>
    /**
     * In case the ProjectPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectPhaseUpdateInput, ProjectPhaseUncheckedUpdateInput>
  }

  /**
   * ProjectPhase delete
   */
  export type ProjectPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
    /**
     * Filter which ProjectPhase to delete.
     */
    where: ProjectPhaseWhereUniqueInput
  }

  /**
   * ProjectPhase deleteMany
   */
  export type ProjectPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectPhases to delete
     */
    where?: ProjectPhaseWhereInput
  }

  /**
   * ProjectPhase without action
   */
  export type ProjectPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectPhase
     */
    select?: ProjectPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectPhaseInclude<ExtArgs> | null
  }


  /**
   * Model Deliverable
   */

  export type AggregateDeliverable = {
    _count: DeliverableCountAggregateOutputType | null
    _avg: DeliverableAvgAggregateOutputType | null
    _sum: DeliverableSumAggregateOutputType | null
    _min: DeliverableMinAggregateOutputType | null
    _max: DeliverableMaxAggregateOutputType | null
  }

  export type DeliverableAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type DeliverableSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type DeliverableMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    acceptanceCriteria: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliverableMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    name: string | null
    description: string | null
    acceptanceCriteria: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliverableCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    acceptanceCriteria: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliverableAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type DeliverableSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type DeliverableMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    acceptanceCriteria?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliverableMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    acceptanceCriteria?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliverableCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    acceptanceCriteria?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliverableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliverable to aggregate.
     */
    where?: DeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliverables to fetch.
     */
    orderBy?: DeliverableOrderByWithRelationInput | DeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliverables
    **/
    _count?: true | DeliverableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliverableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliverableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliverableMaxAggregateInputType
  }

  export type GetDeliverableAggregateType<T extends DeliverableAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliverable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliverable[P]>
      : GetScalarType<T[P], AggregateDeliverable[P]>
  }




  export type DeliverableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliverableWhereInput
    orderBy?: DeliverableOrderByWithAggregationInput | DeliverableOrderByWithAggregationInput[]
    by: DeliverableScalarFieldEnum[] | DeliverableScalarFieldEnum
    having?: DeliverableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliverableCountAggregateInputType | true
    _avg?: DeliverableAvgAggregateInputType
    _sum?: DeliverableSumAggregateInputType
    _min?: DeliverableMinAggregateInputType
    _max?: DeliverableMaxAggregateInputType
  }

  export type DeliverableGroupByOutputType = {
    id: number
    projectId: number
    name: string
    description: string | null
    acceptanceCriteria: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: DeliverableCountAggregateOutputType | null
    _avg: DeliverableAvgAggregateOutputType | null
    _sum: DeliverableSumAggregateOutputType | null
    _min: DeliverableMinAggregateOutputType | null
    _max: DeliverableMaxAggregateOutputType | null
  }

  type GetDeliverableGroupByPayload<T extends DeliverableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliverableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliverableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliverableGroupByOutputType[P]>
            : GetScalarType<T[P], DeliverableGroupByOutputType[P]>
        }
      >
    >


  export type DeliverableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Deliverable$tasksArgs<ExtArgs>
    _count?: boolean | DeliverableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliverable"]>


  export type DeliverableSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    acceptanceCriteria?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliverableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Deliverable$tasksArgs<ExtArgs>
    _count?: boolean | DeliverableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DeliverablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deliverable"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      name: string
      description: string | null
      acceptanceCriteria: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deliverable"]>
    composites: {}
  }

  type DeliverableGetPayload<S extends boolean | null | undefined | DeliverableDefaultArgs> = $Result.GetResult<Prisma.$DeliverablePayload, S>

  type DeliverableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliverableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliverableCountAggregateInputType | true
    }

  export interface DeliverableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deliverable'], meta: { name: 'Deliverable' } }
    /**
     * Find zero or one Deliverable that matches the filter.
     * @param {DeliverableFindUniqueArgs} args - Arguments to find a Deliverable
     * @example
     * // Get one Deliverable
     * const deliverable = await prisma.deliverable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliverableFindUniqueArgs>(args: SelectSubset<T, DeliverableFindUniqueArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deliverable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliverableFindUniqueOrThrowArgs} args - Arguments to find a Deliverable
     * @example
     * // Get one Deliverable
     * const deliverable = await prisma.deliverable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliverableFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliverableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deliverable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableFindFirstArgs} args - Arguments to find a Deliverable
     * @example
     * // Get one Deliverable
     * const deliverable = await prisma.deliverable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliverableFindFirstArgs>(args?: SelectSubset<T, DeliverableFindFirstArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deliverable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableFindFirstOrThrowArgs} args - Arguments to find a Deliverable
     * @example
     * // Get one Deliverable
     * const deliverable = await prisma.deliverable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliverableFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliverableFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deliverables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliverables
     * const deliverables = await prisma.deliverable.findMany()
     * 
     * // Get first 10 Deliverables
     * const deliverables = await prisma.deliverable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliverableWithIdOnly = await prisma.deliverable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliverableFindManyArgs>(args?: SelectSubset<T, DeliverableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deliverable.
     * @param {DeliverableCreateArgs} args - Arguments to create a Deliverable.
     * @example
     * // Create one Deliverable
     * const Deliverable = await prisma.deliverable.create({
     *   data: {
     *     // ... data to create a Deliverable
     *   }
     * })
     * 
     */
    create<T extends DeliverableCreateArgs>(args: SelectSubset<T, DeliverableCreateArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deliverables.
     * @param {DeliverableCreateManyArgs} args - Arguments to create many Deliverables.
     * @example
     * // Create many Deliverables
     * const deliverable = await prisma.deliverable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliverableCreateManyArgs>(args?: SelectSubset<T, DeliverableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deliverable.
     * @param {DeliverableDeleteArgs} args - Arguments to delete one Deliverable.
     * @example
     * // Delete one Deliverable
     * const Deliverable = await prisma.deliverable.delete({
     *   where: {
     *     // ... filter to delete one Deliverable
     *   }
     * })
     * 
     */
    delete<T extends DeliverableDeleteArgs>(args: SelectSubset<T, DeliverableDeleteArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deliverable.
     * @param {DeliverableUpdateArgs} args - Arguments to update one Deliverable.
     * @example
     * // Update one Deliverable
     * const deliverable = await prisma.deliverable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliverableUpdateArgs>(args: SelectSubset<T, DeliverableUpdateArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deliverables.
     * @param {DeliverableDeleteManyArgs} args - Arguments to filter Deliverables to delete.
     * @example
     * // Delete a few Deliverables
     * const { count } = await prisma.deliverable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliverableDeleteManyArgs>(args?: SelectSubset<T, DeliverableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliverables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliverables
     * const deliverable = await prisma.deliverable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliverableUpdateManyArgs>(args: SelectSubset<T, DeliverableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deliverable.
     * @param {DeliverableUpsertArgs} args - Arguments to update or create a Deliverable.
     * @example
     * // Update or create a Deliverable
     * const deliverable = await prisma.deliverable.upsert({
     *   create: {
     *     // ... data to create a Deliverable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deliverable we want to update
     *   }
     * })
     */
    upsert<T extends DeliverableUpsertArgs>(args: SelectSubset<T, DeliverableUpsertArgs<ExtArgs>>): Prisma__DeliverableClient<$Result.GetResult<Prisma.$DeliverablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deliverables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableCountArgs} args - Arguments to filter Deliverables to count.
     * @example
     * // Count the number of Deliverables
     * const count = await prisma.deliverable.count({
     *   where: {
     *     // ... the filter for the Deliverables we want to count
     *   }
     * })
    **/
    count<T extends DeliverableCountArgs>(
      args?: Subset<T, DeliverableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliverableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deliverable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliverableAggregateArgs>(args: Subset<T, DeliverableAggregateArgs>): Prisma.PrismaPromise<GetDeliverableAggregateType<T>>

    /**
     * Group by Deliverable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliverableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliverableGroupByArgs['orderBy'] }
        : { orderBy?: DeliverableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliverableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliverableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deliverable model
   */
  readonly fields: DeliverableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deliverable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliverableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends Deliverable$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Deliverable$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deliverable model
   */ 
  interface DeliverableFieldRefs {
    readonly id: FieldRef<"Deliverable", 'Int'>
    readonly projectId: FieldRef<"Deliverable", 'Int'>
    readonly name: FieldRef<"Deliverable", 'String'>
    readonly description: FieldRef<"Deliverable", 'String'>
    readonly acceptanceCriteria: FieldRef<"Deliverable", 'String'>
    readonly status: FieldRef<"Deliverable", 'String'>
    readonly createdAt: FieldRef<"Deliverable", 'DateTime'>
    readonly updatedAt: FieldRef<"Deliverable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deliverable findUnique
   */
  export type DeliverableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter, which Deliverable to fetch.
     */
    where: DeliverableWhereUniqueInput
  }

  /**
   * Deliverable findUniqueOrThrow
   */
  export type DeliverableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter, which Deliverable to fetch.
     */
    where: DeliverableWhereUniqueInput
  }

  /**
   * Deliverable findFirst
   */
  export type DeliverableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter, which Deliverable to fetch.
     */
    where?: DeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliverables to fetch.
     */
    orderBy?: DeliverableOrderByWithRelationInput | DeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliverables.
     */
    cursor?: DeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliverables.
     */
    distinct?: DeliverableScalarFieldEnum | DeliverableScalarFieldEnum[]
  }

  /**
   * Deliverable findFirstOrThrow
   */
  export type DeliverableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter, which Deliverable to fetch.
     */
    where?: DeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliverables to fetch.
     */
    orderBy?: DeliverableOrderByWithRelationInput | DeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliverables.
     */
    cursor?: DeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliverables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliverables.
     */
    distinct?: DeliverableScalarFieldEnum | DeliverableScalarFieldEnum[]
  }

  /**
   * Deliverable findMany
   */
  export type DeliverableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter, which Deliverables to fetch.
     */
    where?: DeliverableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliverables to fetch.
     */
    orderBy?: DeliverableOrderByWithRelationInput | DeliverableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliverables.
     */
    cursor?: DeliverableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliverables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliverables.
     */
    skip?: number
    distinct?: DeliverableScalarFieldEnum | DeliverableScalarFieldEnum[]
  }

  /**
   * Deliverable create
   */
  export type DeliverableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * The data needed to create a Deliverable.
     */
    data: XOR<DeliverableCreateInput, DeliverableUncheckedCreateInput>
  }

  /**
   * Deliverable createMany
   */
  export type DeliverableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliverables.
     */
    data: DeliverableCreateManyInput | DeliverableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deliverable update
   */
  export type DeliverableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * The data needed to update a Deliverable.
     */
    data: XOR<DeliverableUpdateInput, DeliverableUncheckedUpdateInput>
    /**
     * Choose, which Deliverable to update.
     */
    where: DeliverableWhereUniqueInput
  }

  /**
   * Deliverable updateMany
   */
  export type DeliverableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliverables.
     */
    data: XOR<DeliverableUpdateManyMutationInput, DeliverableUncheckedUpdateManyInput>
    /**
     * Filter which Deliverables to update
     */
    where?: DeliverableWhereInput
  }

  /**
   * Deliverable upsert
   */
  export type DeliverableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * The filter to search for the Deliverable to update in case it exists.
     */
    where: DeliverableWhereUniqueInput
    /**
     * In case the Deliverable found by the `where` argument doesn't exist, create a new Deliverable with this data.
     */
    create: XOR<DeliverableCreateInput, DeliverableUncheckedCreateInput>
    /**
     * In case the Deliverable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliverableUpdateInput, DeliverableUncheckedUpdateInput>
  }

  /**
   * Deliverable delete
   */
  export type DeliverableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
    /**
     * Filter which Deliverable to delete.
     */
    where: DeliverableWhereUniqueInput
  }

  /**
   * Deliverable deleteMany
   */
  export type DeliverableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliverables to delete
     */
    where?: DeliverableWhereInput
  }

  /**
   * Deliverable.tasks
   */
  export type Deliverable$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Deliverable without action
   */
  export type DeliverableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deliverable
     */
    select?: DeliverableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliverableInclude<ExtArgs> | null
  }


  /**
   * Model ScopeHistory
   */

  export type AggregateScopeHistory = {
    _count: ScopeHistoryCountAggregateOutputType | null
    _avg: ScopeHistoryAvgAggregateOutputType | null
    _sum: ScopeHistorySumAggregateOutputType | null
    _min: ScopeHistoryMinAggregateOutputType | null
    _max: ScopeHistoryMaxAggregateOutputType | null
  }

  export type ScopeHistoryAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    changedById: number | null
  }

  export type ScopeHistorySumAggregateOutputType = {
    id: number | null
    projectId: number | null
    changedById: number | null
  }

  export type ScopeHistoryMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    scopeText: string | null
    changeReason: string | null
    changedById: number | null
    createdAt: Date | null
  }

  export type ScopeHistoryMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    scopeText: string | null
    changeReason: string | null
    changedById: number | null
    createdAt: Date | null
  }

  export type ScopeHistoryCountAggregateOutputType = {
    id: number
    projectId: number
    scopeText: number
    changeReason: number
    changedById: number
    createdAt: number
    _all: number
  }


  export type ScopeHistoryAvgAggregateInputType = {
    id?: true
    projectId?: true
    changedById?: true
  }

  export type ScopeHistorySumAggregateInputType = {
    id?: true
    projectId?: true
    changedById?: true
  }

  export type ScopeHistoryMinAggregateInputType = {
    id?: true
    projectId?: true
    scopeText?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type ScopeHistoryMaxAggregateInputType = {
    id?: true
    projectId?: true
    scopeText?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
  }

  export type ScopeHistoryCountAggregateInputType = {
    id?: true
    projectId?: true
    scopeText?: true
    changeReason?: true
    changedById?: true
    createdAt?: true
    _all?: true
  }

  export type ScopeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScopeHistory to aggregate.
     */
    where?: ScopeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeHistories to fetch.
     */
    orderBy?: ScopeHistoryOrderByWithRelationInput | ScopeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScopeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScopeHistories
    **/
    _count?: true | ScopeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScopeHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScopeHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScopeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScopeHistoryMaxAggregateInputType
  }

  export type GetScopeHistoryAggregateType<T extends ScopeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateScopeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScopeHistory[P]>
      : GetScalarType<T[P], AggregateScopeHistory[P]>
  }




  export type ScopeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScopeHistoryWhereInput
    orderBy?: ScopeHistoryOrderByWithAggregationInput | ScopeHistoryOrderByWithAggregationInput[]
    by: ScopeHistoryScalarFieldEnum[] | ScopeHistoryScalarFieldEnum
    having?: ScopeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScopeHistoryCountAggregateInputType | true
    _avg?: ScopeHistoryAvgAggregateInputType
    _sum?: ScopeHistorySumAggregateInputType
    _min?: ScopeHistoryMinAggregateInputType
    _max?: ScopeHistoryMaxAggregateInputType
  }

  export type ScopeHistoryGroupByOutputType = {
    id: number
    projectId: number
    scopeText: string
    changeReason: string | null
    changedById: number
    createdAt: Date
    _count: ScopeHistoryCountAggregateOutputType | null
    _avg: ScopeHistoryAvgAggregateOutputType | null
    _sum: ScopeHistorySumAggregateOutputType | null
    _min: ScopeHistoryMinAggregateOutputType | null
    _max: ScopeHistoryMaxAggregateOutputType | null
  }

  type GetScopeHistoryGroupByPayload<T extends ScopeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScopeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScopeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScopeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ScopeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ScopeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    scopeText?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scopeHistory"]>


  export type ScopeHistorySelectScalar = {
    id?: boolean
    projectId?: boolean
    scopeText?: boolean
    changeReason?: boolean
    changedById?: boolean
    createdAt?: boolean
  }

  export type ScopeHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ScopeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScopeHistory"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      scopeText: string
      changeReason: string | null
      changedById: number
      createdAt: Date
    }, ExtArgs["result"]["scopeHistory"]>
    composites: {}
  }

  type ScopeHistoryGetPayload<S extends boolean | null | undefined | ScopeHistoryDefaultArgs> = $Result.GetResult<Prisma.$ScopeHistoryPayload, S>

  type ScopeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScopeHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScopeHistoryCountAggregateInputType | true
    }

  export interface ScopeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScopeHistory'], meta: { name: 'ScopeHistory' } }
    /**
     * Find zero or one ScopeHistory that matches the filter.
     * @param {ScopeHistoryFindUniqueArgs} args - Arguments to find a ScopeHistory
     * @example
     * // Get one ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScopeHistoryFindUniqueArgs>(args: SelectSubset<T, ScopeHistoryFindUniqueArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScopeHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScopeHistoryFindUniqueOrThrowArgs} args - Arguments to find a ScopeHistory
     * @example
     * // Get one ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScopeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ScopeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScopeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryFindFirstArgs} args - Arguments to find a ScopeHistory
     * @example
     * // Get one ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScopeHistoryFindFirstArgs>(args?: SelectSubset<T, ScopeHistoryFindFirstArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScopeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryFindFirstOrThrowArgs} args - Arguments to find a ScopeHistory
     * @example
     * // Get one ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScopeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ScopeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScopeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScopeHistories
     * const scopeHistories = await prisma.scopeHistory.findMany()
     * 
     * // Get first 10 ScopeHistories
     * const scopeHistories = await prisma.scopeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scopeHistoryWithIdOnly = await prisma.scopeHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScopeHistoryFindManyArgs>(args?: SelectSubset<T, ScopeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScopeHistory.
     * @param {ScopeHistoryCreateArgs} args - Arguments to create a ScopeHistory.
     * @example
     * // Create one ScopeHistory
     * const ScopeHistory = await prisma.scopeHistory.create({
     *   data: {
     *     // ... data to create a ScopeHistory
     *   }
     * })
     * 
     */
    create<T extends ScopeHistoryCreateArgs>(args: SelectSubset<T, ScopeHistoryCreateArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScopeHistories.
     * @param {ScopeHistoryCreateManyArgs} args - Arguments to create many ScopeHistories.
     * @example
     * // Create many ScopeHistories
     * const scopeHistory = await prisma.scopeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScopeHistoryCreateManyArgs>(args?: SelectSubset<T, ScopeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScopeHistory.
     * @param {ScopeHistoryDeleteArgs} args - Arguments to delete one ScopeHistory.
     * @example
     * // Delete one ScopeHistory
     * const ScopeHistory = await prisma.scopeHistory.delete({
     *   where: {
     *     // ... filter to delete one ScopeHistory
     *   }
     * })
     * 
     */
    delete<T extends ScopeHistoryDeleteArgs>(args: SelectSubset<T, ScopeHistoryDeleteArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScopeHistory.
     * @param {ScopeHistoryUpdateArgs} args - Arguments to update one ScopeHistory.
     * @example
     * // Update one ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScopeHistoryUpdateArgs>(args: SelectSubset<T, ScopeHistoryUpdateArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScopeHistories.
     * @param {ScopeHistoryDeleteManyArgs} args - Arguments to filter ScopeHistories to delete.
     * @example
     * // Delete a few ScopeHistories
     * const { count } = await prisma.scopeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScopeHistoryDeleteManyArgs>(args?: SelectSubset<T, ScopeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScopeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScopeHistories
     * const scopeHistory = await prisma.scopeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScopeHistoryUpdateManyArgs>(args: SelectSubset<T, ScopeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScopeHistory.
     * @param {ScopeHistoryUpsertArgs} args - Arguments to update or create a ScopeHistory.
     * @example
     * // Update or create a ScopeHistory
     * const scopeHistory = await prisma.scopeHistory.upsert({
     *   create: {
     *     // ... data to create a ScopeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScopeHistory we want to update
     *   }
     * })
     */
    upsert<T extends ScopeHistoryUpsertArgs>(args: SelectSubset<T, ScopeHistoryUpsertArgs<ExtArgs>>): Prisma__ScopeHistoryClient<$Result.GetResult<Prisma.$ScopeHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScopeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryCountArgs} args - Arguments to filter ScopeHistories to count.
     * @example
     * // Count the number of ScopeHistories
     * const count = await prisma.scopeHistory.count({
     *   where: {
     *     // ... the filter for the ScopeHistories we want to count
     *   }
     * })
    **/
    count<T extends ScopeHistoryCountArgs>(
      args?: Subset<T, ScopeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScopeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScopeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScopeHistoryAggregateArgs>(args: Subset<T, ScopeHistoryAggregateArgs>): Prisma.PrismaPromise<GetScopeHistoryAggregateType<T>>

    /**
     * Group by ScopeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScopeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScopeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScopeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ScopeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScopeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScopeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScopeHistory model
   */
  readonly fields: ScopeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScopeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScopeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScopeHistory model
   */ 
  interface ScopeHistoryFieldRefs {
    readonly id: FieldRef<"ScopeHistory", 'Int'>
    readonly projectId: FieldRef<"ScopeHistory", 'Int'>
    readonly scopeText: FieldRef<"ScopeHistory", 'String'>
    readonly changeReason: FieldRef<"ScopeHistory", 'String'>
    readonly changedById: FieldRef<"ScopeHistory", 'Int'>
    readonly createdAt: FieldRef<"ScopeHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScopeHistory findUnique
   */
  export type ScopeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ScopeHistory to fetch.
     */
    where: ScopeHistoryWhereUniqueInput
  }

  /**
   * ScopeHistory findUniqueOrThrow
   */
  export type ScopeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ScopeHistory to fetch.
     */
    where: ScopeHistoryWhereUniqueInput
  }

  /**
   * ScopeHistory findFirst
   */
  export type ScopeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ScopeHistory to fetch.
     */
    where?: ScopeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeHistories to fetch.
     */
    orderBy?: ScopeHistoryOrderByWithRelationInput | ScopeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScopeHistories.
     */
    cursor?: ScopeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScopeHistories.
     */
    distinct?: ScopeHistoryScalarFieldEnum | ScopeHistoryScalarFieldEnum[]
  }

  /**
   * ScopeHistory findFirstOrThrow
   */
  export type ScopeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ScopeHistory to fetch.
     */
    where?: ScopeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeHistories to fetch.
     */
    orderBy?: ScopeHistoryOrderByWithRelationInput | ScopeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScopeHistories.
     */
    cursor?: ScopeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScopeHistories.
     */
    distinct?: ScopeHistoryScalarFieldEnum | ScopeHistoryScalarFieldEnum[]
  }

  /**
   * ScopeHistory findMany
   */
  export type ScopeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ScopeHistories to fetch.
     */
    where?: ScopeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScopeHistories to fetch.
     */
    orderBy?: ScopeHistoryOrderByWithRelationInput | ScopeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScopeHistories.
     */
    cursor?: ScopeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScopeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScopeHistories.
     */
    skip?: number
    distinct?: ScopeHistoryScalarFieldEnum | ScopeHistoryScalarFieldEnum[]
  }

  /**
   * ScopeHistory create
   */
  export type ScopeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ScopeHistory.
     */
    data: XOR<ScopeHistoryCreateInput, ScopeHistoryUncheckedCreateInput>
  }

  /**
   * ScopeHistory createMany
   */
  export type ScopeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScopeHistories.
     */
    data: ScopeHistoryCreateManyInput | ScopeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScopeHistory update
   */
  export type ScopeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ScopeHistory.
     */
    data: XOR<ScopeHistoryUpdateInput, ScopeHistoryUncheckedUpdateInput>
    /**
     * Choose, which ScopeHistory to update.
     */
    where: ScopeHistoryWhereUniqueInput
  }

  /**
   * ScopeHistory updateMany
   */
  export type ScopeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScopeHistories.
     */
    data: XOR<ScopeHistoryUpdateManyMutationInput, ScopeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ScopeHistories to update
     */
    where?: ScopeHistoryWhereInput
  }

  /**
   * ScopeHistory upsert
   */
  export type ScopeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ScopeHistory to update in case it exists.
     */
    where: ScopeHistoryWhereUniqueInput
    /**
     * In case the ScopeHistory found by the `where` argument doesn't exist, create a new ScopeHistory with this data.
     */
    create: XOR<ScopeHistoryCreateInput, ScopeHistoryUncheckedCreateInput>
    /**
     * In case the ScopeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScopeHistoryUpdateInput, ScopeHistoryUncheckedUpdateInput>
  }

  /**
   * ScopeHistory delete
   */
  export type ScopeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
    /**
     * Filter which ScopeHistory to delete.
     */
    where: ScopeHistoryWhereUniqueInput
  }

  /**
   * ScopeHistory deleteMany
   */
  export type ScopeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScopeHistories to delete
     */
    where?: ScopeHistoryWhereInput
  }

  /**
   * ScopeHistory without action
   */
  export type ScopeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScopeHistory
     */
    select?: ScopeHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScopeHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
    taskId: number | null
    uploadedById: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    id: number | null
    fileSize: number | null
    taskId: number | null
    uploadedById: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: number | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    uploadedAt: Date | null
    taskId: number | null
    uploadedById: number | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: number | null
    fileName: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    uploadedAt: Date | null
    taskId: number | null
    uploadedById: number | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    fileName: number
    fileUrl: number
    fileType: number
    fileSize: number
    uploadedAt: number
    taskId: number
    uploadedById: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    id?: true
    fileSize?: true
    taskId?: true
    uploadedById?: true
  }

  export type AttachmentSumAggregateInputType = {
    id?: true
    fileSize?: true
    taskId?: true
    uploadedById?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    uploadedAt?: true
    taskId?: true
    uploadedById?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    uploadedAt?: true
    taskId?: true
    uploadedById?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    fileName?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    uploadedAt?: true
    taskId?: true
    uploadedById?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: number
    fileName: string
    fileUrl: string
    fileType: string | null
    fileSize: number | null
    uploadedAt: Date
    taskId: number | null
    uploadedById: number
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
    taskId?: boolean
    uploadedById?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | Attachment$taskArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>


  export type AttachmentSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    uploadedAt?: boolean
    taskId?: boolean
    uploadedById?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | Attachment$taskArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fileName: string
      fileUrl: string
      fileType: string | null
      fileSize: number | null
      uploadedAt: Date
      taskId: number | null
      uploadedById: number
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends Attachment$taskArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$taskArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Int'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly fileUrl: FieldRef<"Attachment", 'String'>
    readonly fileType: FieldRef<"Attachment", 'String'>
    readonly fileSize: FieldRef<"Attachment", 'Int'>
    readonly uploadedAt: FieldRef<"Attachment", 'DateTime'>
    readonly taskId: FieldRef<"Attachment", 'Int'>
    readonly uploadedById: FieldRef<"Attachment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.task
   */
  export type Attachment$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingAvgAggregateOutputType = {
    id: number | null
    updatedBy: number | null
  }

  export type SystemSettingSumAggregateOutputType = {
    id: number | null
    updatedBy: number | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type SystemSettingAvgAggregateInputType = {
    id?: true
    updatedBy?: true
  }

  export type SystemSettingSumAggregateInputType = {
    id?: true
    updatedBy?: true
  }

  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _avg?: SystemSettingAvgAggregateInputType
    _sum?: SystemSettingSumAggregateInputType
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: number
    key: string
    value: string
    category: string
    description: string | null
    updatedAt: Date
    updatedBy: number
    _count: SystemSettingCountAggregateOutputType | null
    _avg: SystemSettingAvgAggregateOutputType | null
    _sum: SystemSettingSumAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    changeLogs?: boolean | SystemSetting$changeLogsArgs<ExtArgs>
    updater?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | SystemSettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>


  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type SystemSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeLogs?: boolean | SystemSetting$changeLogsArgs<ExtArgs>
    updater?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | SystemSettingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {
      changeLogs: Prisma.$SettingsChangeLogPayload<ExtArgs>[]
      updater: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      category: string
      description: string | null
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    changeLogs<T extends SystemSetting$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, SystemSetting$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    updater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */ 
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'Int'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemSetting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting.changeLogs
   */
  export type SystemSetting$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    where?: SettingsChangeLogWhereInput
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    cursor?: SettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsChangeLogScalarFieldEnum | SettingsChangeLogScalarFieldEnum[]
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
  }


  /**
   * Model SettingsChangeLog
   */

  export type AggregateSettingsChangeLog = {
    _count: SettingsChangeLogCountAggregateOutputType | null
    _avg: SettingsChangeLogAvgAggregateOutputType | null
    _sum: SettingsChangeLogSumAggregateOutputType | null
    _min: SettingsChangeLogMinAggregateOutputType | null
    _max: SettingsChangeLogMaxAggregateOutputType | null
  }

  export type SettingsChangeLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
  }

  export type SettingsChangeLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    settingId: number | null
  }

  export type SettingsChangeLogMinAggregateOutputType = {
    id: number | null
    settingKey: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    userId: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type SettingsChangeLogMaxAggregateOutputType = {
    id: number | null
    settingKey: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    userId: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type SettingsChangeLogCountAggregateOutputType = {
    id: number
    settingKey: number
    oldValue: number
    newValue: number
    reason: number
    userId: number
    settingId: number
    createdAt: number
    _all: number
  }


  export type SettingsChangeLogAvgAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
  }

  export type SettingsChangeLogSumAggregateInputType = {
    id?: true
    userId?: true
    settingId?: true
  }

  export type SettingsChangeLogMinAggregateInputType = {
    id?: true
    settingKey?: true
    oldValue?: true
    newValue?: true
    reason?: true
    userId?: true
    settingId?: true
    createdAt?: true
  }

  export type SettingsChangeLogMaxAggregateInputType = {
    id?: true
    settingKey?: true
    oldValue?: true
    newValue?: true
    reason?: true
    userId?: true
    settingId?: true
    createdAt?: true
  }

  export type SettingsChangeLogCountAggregateInputType = {
    id?: true
    settingKey?: true
    oldValue?: true
    newValue?: true
    reason?: true
    userId?: true
    settingId?: true
    createdAt?: true
    _all?: true
  }

  export type SettingsChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingsChangeLog to aggregate.
     */
    where?: SettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsChangeLogs to fetch.
     */
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SettingsChangeLogs
    **/
    _count?: true | SettingsChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsChangeLogMaxAggregateInputType
  }

  export type GetSettingsChangeLogAggregateType<T extends SettingsChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingsChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingsChangeLog[P]>
      : GetScalarType<T[P], AggregateSettingsChangeLog[P]>
  }




  export type SettingsChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsChangeLogWhereInput
    orderBy?: SettingsChangeLogOrderByWithAggregationInput | SettingsChangeLogOrderByWithAggregationInput[]
    by: SettingsChangeLogScalarFieldEnum[] | SettingsChangeLogScalarFieldEnum
    having?: SettingsChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsChangeLogCountAggregateInputType | true
    _avg?: SettingsChangeLogAvgAggregateInputType
    _sum?: SettingsChangeLogSumAggregateInputType
    _min?: SettingsChangeLogMinAggregateInputType
    _max?: SettingsChangeLogMaxAggregateInputType
  }

  export type SettingsChangeLogGroupByOutputType = {
    id: number
    settingKey: string
    oldValue: string | null
    newValue: string
    reason: string | null
    userId: number
    settingId: number
    createdAt: Date
    _count: SettingsChangeLogCountAggregateOutputType | null
    _avg: SettingsChangeLogAvgAggregateOutputType | null
    _sum: SettingsChangeLogSumAggregateOutputType | null
    _min: SettingsChangeLogMinAggregateOutputType | null
    _max: SettingsChangeLogMaxAggregateOutputType | null
  }

  type GetSettingsChangeLogGroupByPayload<T extends SettingsChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type SettingsChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    settingKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    userId?: boolean
    settingId?: boolean
    createdAt?: boolean
    setting?: boolean | SystemSettingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settingsChangeLog"]>


  export type SettingsChangeLogSelectScalar = {
    id?: boolean
    settingKey?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    userId?: boolean
    settingId?: boolean
    createdAt?: boolean
  }

  export type SettingsChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting?: boolean | SystemSettingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SettingsChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SettingsChangeLog"
    objects: {
      setting: Prisma.$SystemSettingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      settingKey: string
      oldValue: string | null
      newValue: string
      reason: string | null
      userId: number
      settingId: number
      createdAt: Date
    }, ExtArgs["result"]["settingsChangeLog"]>
    composites: {}
  }

  type SettingsChangeLogGetPayload<S extends boolean | null | undefined | SettingsChangeLogDefaultArgs> = $Result.GetResult<Prisma.$SettingsChangeLogPayload, S>

  type SettingsChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingsChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingsChangeLogCountAggregateInputType | true
    }

  export interface SettingsChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SettingsChangeLog'], meta: { name: 'SettingsChangeLog' } }
    /**
     * Find zero or one SettingsChangeLog that matches the filter.
     * @param {SettingsChangeLogFindUniqueArgs} args - Arguments to find a SettingsChangeLog
     * @example
     * // Get one SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsChangeLogFindUniqueArgs>(args: SelectSubset<T, SettingsChangeLogFindUniqueArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SettingsChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingsChangeLogFindUniqueOrThrowArgs} args - Arguments to find a SettingsChangeLog
     * @example
     * // Get one SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SettingsChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogFindFirstArgs} args - Arguments to find a SettingsChangeLog
     * @example
     * // Get one SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsChangeLogFindFirstArgs>(args?: SelectSubset<T, SettingsChangeLogFindFirstArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SettingsChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogFindFirstOrThrowArgs} args - Arguments to find a SettingsChangeLog
     * @example
     * // Get one SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SettingsChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SettingsChangeLogs
     * const settingsChangeLogs = await prisma.settingsChangeLog.findMany()
     * 
     * // Get first 10 SettingsChangeLogs
     * const settingsChangeLogs = await prisma.settingsChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsChangeLogWithIdOnly = await prisma.settingsChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsChangeLogFindManyArgs>(args?: SelectSubset<T, SettingsChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SettingsChangeLog.
     * @param {SettingsChangeLogCreateArgs} args - Arguments to create a SettingsChangeLog.
     * @example
     * // Create one SettingsChangeLog
     * const SettingsChangeLog = await prisma.settingsChangeLog.create({
     *   data: {
     *     // ... data to create a SettingsChangeLog
     *   }
     * })
     * 
     */
    create<T extends SettingsChangeLogCreateArgs>(args: SelectSubset<T, SettingsChangeLogCreateArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SettingsChangeLogs.
     * @param {SettingsChangeLogCreateManyArgs} args - Arguments to create many SettingsChangeLogs.
     * @example
     * // Create many SettingsChangeLogs
     * const settingsChangeLog = await prisma.settingsChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsChangeLogCreateManyArgs>(args?: SelectSubset<T, SettingsChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SettingsChangeLog.
     * @param {SettingsChangeLogDeleteArgs} args - Arguments to delete one SettingsChangeLog.
     * @example
     * // Delete one SettingsChangeLog
     * const SettingsChangeLog = await prisma.settingsChangeLog.delete({
     *   where: {
     *     // ... filter to delete one SettingsChangeLog
     *   }
     * })
     * 
     */
    delete<T extends SettingsChangeLogDeleteArgs>(args: SelectSubset<T, SettingsChangeLogDeleteArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SettingsChangeLog.
     * @param {SettingsChangeLogUpdateArgs} args - Arguments to update one SettingsChangeLog.
     * @example
     * // Update one SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsChangeLogUpdateArgs>(args: SelectSubset<T, SettingsChangeLogUpdateArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SettingsChangeLogs.
     * @param {SettingsChangeLogDeleteManyArgs} args - Arguments to filter SettingsChangeLogs to delete.
     * @example
     * // Delete a few SettingsChangeLogs
     * const { count } = await prisma.settingsChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsChangeLogDeleteManyArgs>(args?: SelectSubset<T, SettingsChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SettingsChangeLogs
     * const settingsChangeLog = await prisma.settingsChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsChangeLogUpdateManyArgs>(args: SelectSubset<T, SettingsChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SettingsChangeLog.
     * @param {SettingsChangeLogUpsertArgs} args - Arguments to update or create a SettingsChangeLog.
     * @example
     * // Update or create a SettingsChangeLog
     * const settingsChangeLog = await prisma.settingsChangeLog.upsert({
     *   create: {
     *     // ... data to create a SettingsChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SettingsChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends SettingsChangeLogUpsertArgs>(args: SelectSubset<T, SettingsChangeLogUpsertArgs<ExtArgs>>): Prisma__SettingsChangeLogClient<$Result.GetResult<Prisma.$SettingsChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogCountArgs} args - Arguments to filter SettingsChangeLogs to count.
     * @example
     * // Count the number of SettingsChangeLogs
     * const count = await prisma.settingsChangeLog.count({
     *   where: {
     *     // ... the filter for the SettingsChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends SettingsChangeLogCountArgs>(
      args?: Subset<T, SettingsChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsChangeLogAggregateArgs>(args: Subset<T, SettingsChangeLogAggregateArgs>): Prisma.PrismaPromise<GetSettingsChangeLogAggregateType<T>>

    /**
     * Group by SettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: SettingsChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SettingsChangeLog model
   */
  readonly fields: SettingsChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SettingsChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting<T extends SystemSettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemSettingDefaultArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SettingsChangeLog model
   */ 
  interface SettingsChangeLogFieldRefs {
    readonly id: FieldRef<"SettingsChangeLog", 'Int'>
    readonly settingKey: FieldRef<"SettingsChangeLog", 'String'>
    readonly oldValue: FieldRef<"SettingsChangeLog", 'String'>
    readonly newValue: FieldRef<"SettingsChangeLog", 'String'>
    readonly reason: FieldRef<"SettingsChangeLog", 'String'>
    readonly userId: FieldRef<"SettingsChangeLog", 'Int'>
    readonly settingId: FieldRef<"SettingsChangeLog", 'Int'>
    readonly createdAt: FieldRef<"SettingsChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SettingsChangeLog findUnique
   */
  export type SettingsChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which SettingsChangeLog to fetch.
     */
    where: SettingsChangeLogWhereUniqueInput
  }

  /**
   * SettingsChangeLog findUniqueOrThrow
   */
  export type SettingsChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which SettingsChangeLog to fetch.
     */
    where: SettingsChangeLogWhereUniqueInput
  }

  /**
   * SettingsChangeLog findFirst
   */
  export type SettingsChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which SettingsChangeLog to fetch.
     */
    where?: SettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsChangeLogs to fetch.
     */
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingsChangeLogs.
     */
    cursor?: SettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingsChangeLogs.
     */
    distinct?: SettingsChangeLogScalarFieldEnum | SettingsChangeLogScalarFieldEnum[]
  }

  /**
   * SettingsChangeLog findFirstOrThrow
   */
  export type SettingsChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which SettingsChangeLog to fetch.
     */
    where?: SettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsChangeLogs to fetch.
     */
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SettingsChangeLogs.
     */
    cursor?: SettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SettingsChangeLogs.
     */
    distinct?: SettingsChangeLogScalarFieldEnum | SettingsChangeLogScalarFieldEnum[]
  }

  /**
   * SettingsChangeLog findMany
   */
  export type SettingsChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which SettingsChangeLogs to fetch.
     */
    where?: SettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SettingsChangeLogs to fetch.
     */
    orderBy?: SettingsChangeLogOrderByWithRelationInput | SettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SettingsChangeLogs.
     */
    cursor?: SettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SettingsChangeLogs.
     */
    skip?: number
    distinct?: SettingsChangeLogScalarFieldEnum | SettingsChangeLogScalarFieldEnum[]
  }

  /**
   * SettingsChangeLog create
   */
  export type SettingsChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SettingsChangeLog.
     */
    data: XOR<SettingsChangeLogCreateInput, SettingsChangeLogUncheckedCreateInput>
  }

  /**
   * SettingsChangeLog createMany
   */
  export type SettingsChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SettingsChangeLogs.
     */
    data: SettingsChangeLogCreateManyInput | SettingsChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SettingsChangeLog update
   */
  export type SettingsChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SettingsChangeLog.
     */
    data: XOR<SettingsChangeLogUpdateInput, SettingsChangeLogUncheckedUpdateInput>
    /**
     * Choose, which SettingsChangeLog to update.
     */
    where: SettingsChangeLogWhereUniqueInput
  }

  /**
   * SettingsChangeLog updateMany
   */
  export type SettingsChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SettingsChangeLogs.
     */
    data: XOR<SettingsChangeLogUpdateManyMutationInput, SettingsChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which SettingsChangeLogs to update
     */
    where?: SettingsChangeLogWhereInput
  }

  /**
   * SettingsChangeLog upsert
   */
  export type SettingsChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SettingsChangeLog to update in case it exists.
     */
    where: SettingsChangeLogWhereUniqueInput
    /**
     * In case the SettingsChangeLog found by the `where` argument doesn't exist, create a new SettingsChangeLog with this data.
     */
    create: XOR<SettingsChangeLogCreateInput, SettingsChangeLogUncheckedCreateInput>
    /**
     * In case the SettingsChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsChangeLogUpdateInput, SettingsChangeLogUncheckedUpdateInput>
  }

  /**
   * SettingsChangeLog delete
   */
  export type SettingsChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter which SettingsChangeLog to delete.
     */
    where: SettingsChangeLogWhereUniqueInput
  }

  /**
   * SettingsChangeLog deleteMany
   */
  export type SettingsChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SettingsChangeLogs to delete
     */
    where?: SettingsChangeLogWhereInput
  }

  /**
   * SettingsChangeLog without action
   */
  export type SettingsChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SettingsChangeLog
     */
    select?: SettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSetting
   */

  export type AggregateProjectSetting = {
    _count: ProjectSettingCountAggregateOutputType | null
    _avg: ProjectSettingAvgAggregateOutputType | null
    _sum: ProjectSettingSumAggregateOutputType | null
    _min: ProjectSettingMinAggregateOutputType | null
    _max: ProjectSettingMaxAggregateOutputType | null
  }

  export type ProjectSettingAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    updatedBy: number | null
  }

  export type ProjectSettingSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    updatedBy: number | null
  }

  export type ProjectSettingMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    key: string | null
    value: string | null
    category: string | null
    enabled: boolean | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type ProjectSettingMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    key: string | null
    value: string | null
    category: string | null
    enabled: boolean | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type ProjectSettingCountAggregateOutputType = {
    id: number
    projectId: number
    key: number
    value: number
    category: number
    enabled: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProjectSettingAvgAggregateInputType = {
    id?: true
    projectId?: true
    updatedBy?: true
  }

  export type ProjectSettingSumAggregateInputType = {
    id?: true
    projectId?: true
    updatedBy?: true
  }

  export type ProjectSettingMinAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    value?: true
    category?: true
    enabled?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectSettingMaxAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    value?: true
    category?: true
    enabled?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProjectSettingCountAggregateInputType = {
    id?: true
    projectId?: true
    key?: true
    value?: true
    category?: true
    enabled?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProjectSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSetting to aggregate.
     */
    where?: ProjectSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettings to fetch.
     */
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSettings
    **/
    _count?: true | ProjectSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSettingMaxAggregateInputType
  }

  export type GetProjectSettingAggregateType<T extends ProjectSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSetting[P]>
      : GetScalarType<T[P], AggregateProjectSetting[P]>
  }




  export type ProjectSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingWhereInput
    orderBy?: ProjectSettingOrderByWithAggregationInput | ProjectSettingOrderByWithAggregationInput[]
    by: ProjectSettingScalarFieldEnum[] | ProjectSettingScalarFieldEnum
    having?: ProjectSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSettingCountAggregateInputType | true
    _avg?: ProjectSettingAvgAggregateInputType
    _sum?: ProjectSettingSumAggregateInputType
    _min?: ProjectSettingMinAggregateInputType
    _max?: ProjectSettingMaxAggregateInputType
  }

  export type ProjectSettingGroupByOutputType = {
    id: number
    projectId: number
    key: string
    value: string
    category: string
    enabled: boolean
    updatedAt: Date
    updatedBy: number
    _count: ProjectSettingCountAggregateOutputType | null
    _avg: ProjectSettingAvgAggregateOutputType | null
    _sum: ProjectSettingSumAggregateOutputType | null
    _min: ProjectSettingMinAggregateOutputType | null
    _max: ProjectSettingMaxAggregateOutputType | null
  }

  type GetProjectSettingGroupByPayload<T extends ProjectSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSettingGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSettingGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    enabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    updater?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    changeLogs?: boolean | ProjectSetting$changeLogsArgs<ExtArgs>
    _count?: boolean | ProjectSettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSetting"]>


  export type ProjectSettingSelectScalar = {
    id?: boolean
    projectId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    enabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProjectSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updater?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    changeLogs?: boolean | ProjectSetting$changeLogsArgs<ExtArgs>
    _count?: boolean | ProjectSettingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSetting"
    objects: {
      updater: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      changeLogs: Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      key: string
      value: string
      category: string
      enabled: boolean
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["projectSetting"]>
    composites: {}
  }

  type ProjectSettingGetPayload<S extends boolean | null | undefined | ProjectSettingDefaultArgs> = $Result.GetResult<Prisma.$ProjectSettingPayload, S>

  type ProjectSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectSettingCountAggregateInputType | true
    }

  export interface ProjectSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSetting'], meta: { name: 'ProjectSetting' } }
    /**
     * Find zero or one ProjectSetting that matches the filter.
     * @param {ProjectSettingFindUniqueArgs} args - Arguments to find a ProjectSetting
     * @example
     * // Get one ProjectSetting
     * const projectSetting = await prisma.projectSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSettingFindUniqueArgs>(args: SelectSubset<T, ProjectSettingFindUniqueArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectSettingFindUniqueOrThrowArgs} args - Arguments to find a ProjectSetting
     * @example
     * // Get one ProjectSetting
     * const projectSetting = await prisma.projectSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingFindFirstArgs} args - Arguments to find a ProjectSetting
     * @example
     * // Get one ProjectSetting
     * const projectSetting = await prisma.projectSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSettingFindFirstArgs>(args?: SelectSubset<T, ProjectSettingFindFirstArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingFindFirstOrThrowArgs} args - Arguments to find a ProjectSetting
     * @example
     * // Get one ProjectSetting
     * const projectSetting = await prisma.projectSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSettings
     * const projectSettings = await prisma.projectSetting.findMany()
     * 
     * // Get first 10 ProjectSettings
     * const projectSettings = await prisma.projectSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectSettingWithIdOnly = await prisma.projectSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectSettingFindManyArgs>(args?: SelectSubset<T, ProjectSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectSetting.
     * @param {ProjectSettingCreateArgs} args - Arguments to create a ProjectSetting.
     * @example
     * // Create one ProjectSetting
     * const ProjectSetting = await prisma.projectSetting.create({
     *   data: {
     *     // ... data to create a ProjectSetting
     *   }
     * })
     * 
     */
    create<T extends ProjectSettingCreateArgs>(args: SelectSubset<T, ProjectSettingCreateArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectSettings.
     * @param {ProjectSettingCreateManyArgs} args - Arguments to create many ProjectSettings.
     * @example
     * // Create many ProjectSettings
     * const projectSetting = await prisma.projectSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSettingCreateManyArgs>(args?: SelectSubset<T, ProjectSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectSetting.
     * @param {ProjectSettingDeleteArgs} args - Arguments to delete one ProjectSetting.
     * @example
     * // Delete one ProjectSetting
     * const ProjectSetting = await prisma.projectSetting.delete({
     *   where: {
     *     // ... filter to delete one ProjectSetting
     *   }
     * })
     * 
     */
    delete<T extends ProjectSettingDeleteArgs>(args: SelectSubset<T, ProjectSettingDeleteArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectSetting.
     * @param {ProjectSettingUpdateArgs} args - Arguments to update one ProjectSetting.
     * @example
     * // Update one ProjectSetting
     * const projectSetting = await prisma.projectSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSettingUpdateArgs>(args: SelectSubset<T, ProjectSettingUpdateArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectSettings.
     * @param {ProjectSettingDeleteManyArgs} args - Arguments to filter ProjectSettings to delete.
     * @example
     * // Delete a few ProjectSettings
     * const { count } = await prisma.projectSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSettingDeleteManyArgs>(args?: SelectSubset<T, ProjectSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSettings
     * const projectSetting = await prisma.projectSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSettingUpdateManyArgs>(args: SelectSubset<T, ProjectSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectSetting.
     * @param {ProjectSettingUpsertArgs} args - Arguments to update or create a ProjectSetting.
     * @example
     * // Update or create a ProjectSetting
     * const projectSetting = await prisma.projectSetting.upsert({
     *   create: {
     *     // ... data to create a ProjectSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSetting we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSettingUpsertArgs>(args: SelectSubset<T, ProjectSettingUpsertArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingCountArgs} args - Arguments to filter ProjectSettings to count.
     * @example
     * // Count the number of ProjectSettings
     * const count = await prisma.projectSetting.count({
     *   where: {
     *     // ... the filter for the ProjectSettings we want to count
     *   }
     * })
    **/
    count<T extends ProjectSettingCountArgs>(
      args?: Subset<T, ProjectSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSettingAggregateArgs>(args: Subset<T, ProjectSettingAggregateArgs>): Prisma.PrismaPromise<GetProjectSettingAggregateType<T>>

    /**
     * Group by ProjectSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSettingGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSetting model
   */
  readonly fields: ProjectSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    updater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changeLogs<T extends ProjectSetting$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectSetting$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSetting model
   */ 
  interface ProjectSettingFieldRefs {
    readonly id: FieldRef<"ProjectSetting", 'Int'>
    readonly projectId: FieldRef<"ProjectSetting", 'Int'>
    readonly key: FieldRef<"ProjectSetting", 'String'>
    readonly value: FieldRef<"ProjectSetting", 'String'>
    readonly category: FieldRef<"ProjectSetting", 'String'>
    readonly enabled: FieldRef<"ProjectSetting", 'Boolean'>
    readonly updatedAt: FieldRef<"ProjectSetting", 'DateTime'>
    readonly updatedBy: FieldRef<"ProjectSetting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSetting findUnique
   */
  export type ProjectSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSetting to fetch.
     */
    where: ProjectSettingWhereUniqueInput
  }

  /**
   * ProjectSetting findUniqueOrThrow
   */
  export type ProjectSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSetting to fetch.
     */
    where: ProjectSettingWhereUniqueInput
  }

  /**
   * ProjectSetting findFirst
   */
  export type ProjectSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSetting to fetch.
     */
    where?: ProjectSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettings to fetch.
     */
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettings.
     */
    cursor?: ProjectSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettings.
     */
    distinct?: ProjectSettingScalarFieldEnum | ProjectSettingScalarFieldEnum[]
  }

  /**
   * ProjectSetting findFirstOrThrow
   */
  export type ProjectSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSetting to fetch.
     */
    where?: ProjectSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettings to fetch.
     */
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettings.
     */
    cursor?: ProjectSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettings.
     */
    distinct?: ProjectSettingScalarFieldEnum | ProjectSettingScalarFieldEnum[]
  }

  /**
   * ProjectSetting findMany
   */
  export type ProjectSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettings to fetch.
     */
    where?: ProjectSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettings to fetch.
     */
    orderBy?: ProjectSettingOrderByWithRelationInput | ProjectSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSettings.
     */
    cursor?: ProjectSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettings.
     */
    skip?: number
    distinct?: ProjectSettingScalarFieldEnum | ProjectSettingScalarFieldEnum[]
  }

  /**
   * ProjectSetting create
   */
  export type ProjectSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSetting.
     */
    data: XOR<ProjectSettingCreateInput, ProjectSettingUncheckedCreateInput>
  }

  /**
   * ProjectSetting createMany
   */
  export type ProjectSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSettings.
     */
    data: ProjectSettingCreateManyInput | ProjectSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSetting update
   */
  export type ProjectSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSetting.
     */
    data: XOR<ProjectSettingUpdateInput, ProjectSettingUncheckedUpdateInput>
    /**
     * Choose, which ProjectSetting to update.
     */
    where: ProjectSettingWhereUniqueInput
  }

  /**
   * ProjectSetting updateMany
   */
  export type ProjectSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSettings.
     */
    data: XOR<ProjectSettingUpdateManyMutationInput, ProjectSettingUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSettings to update
     */
    where?: ProjectSettingWhereInput
  }

  /**
   * ProjectSetting upsert
   */
  export type ProjectSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSetting to update in case it exists.
     */
    where: ProjectSettingWhereUniqueInput
    /**
     * In case the ProjectSetting found by the `where` argument doesn't exist, create a new ProjectSetting with this data.
     */
    create: XOR<ProjectSettingCreateInput, ProjectSettingUncheckedCreateInput>
    /**
     * In case the ProjectSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSettingUpdateInput, ProjectSettingUncheckedUpdateInput>
  }

  /**
   * ProjectSetting delete
   */
  export type ProjectSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
    /**
     * Filter which ProjectSetting to delete.
     */
    where: ProjectSettingWhereUniqueInput
  }

  /**
   * ProjectSetting deleteMany
   */
  export type ProjectSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSettings to delete
     */
    where?: ProjectSettingWhereInput
  }

  /**
   * ProjectSetting.changeLogs
   */
  export type ProjectSetting$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    where?: ProjectSettingsChangeLogWhereInput
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * ProjectSetting without action
   */
  export type ProjectSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSetting
     */
    select?: ProjectSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSettingsChangeLog
   */

  export type AggregateProjectSettingsChangeLog = {
    _count: ProjectSettingsChangeLogCountAggregateOutputType | null
    _avg: ProjectSettingsChangeLogAvgAggregateOutputType | null
    _sum: ProjectSettingsChangeLogSumAggregateOutputType | null
    _min: ProjectSettingsChangeLogMinAggregateOutputType | null
    _max: ProjectSettingsChangeLogMaxAggregateOutputType | null
  }

  export type ProjectSettingsChangeLogAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    changedBy: number | null
    settingId: number | null
  }

  export type ProjectSettingsChangeLogSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    changedBy: number | null
    settingId: number | null
  }

  export type ProjectSettingsChangeLogMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    settingKey: string | null
    category: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    changedBy: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type ProjectSettingsChangeLogMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    settingKey: string | null
    category: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    changedBy: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type ProjectSettingsChangeLogCountAggregateOutputType = {
    id: number
    projectId: number
    settingKey: number
    category: number
    oldValue: number
    newValue: number
    reason: number
    changedBy: number
    settingId: number
    createdAt: number
    _all: number
  }


  export type ProjectSettingsChangeLogAvgAggregateInputType = {
    id?: true
    projectId?: true
    changedBy?: true
    settingId?: true
  }

  export type ProjectSettingsChangeLogSumAggregateInputType = {
    id?: true
    projectId?: true
    changedBy?: true
    settingId?: true
  }

  export type ProjectSettingsChangeLogMinAggregateInputType = {
    id?: true
    projectId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
  }

  export type ProjectSettingsChangeLogMaxAggregateInputType = {
    id?: true
    projectId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
  }

  export type ProjectSettingsChangeLogCountAggregateInputType = {
    id?: true
    projectId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectSettingsChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSettingsChangeLog to aggregate.
     */
    where?: ProjectSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingsChangeLogs to fetch.
     */
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSettingsChangeLogs
    **/
    _count?: true | ProjectSettingsChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectSettingsChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSettingsChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSettingsChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSettingsChangeLogMaxAggregateInputType
  }

  export type GetProjectSettingsChangeLogAggregateType<T extends ProjectSettingsChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSettingsChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSettingsChangeLog[P]>
      : GetScalarType<T[P], AggregateProjectSettingsChangeLog[P]>
  }




  export type ProjectSettingsChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSettingsChangeLogWhereInput
    orderBy?: ProjectSettingsChangeLogOrderByWithAggregationInput | ProjectSettingsChangeLogOrderByWithAggregationInput[]
    by: ProjectSettingsChangeLogScalarFieldEnum[] | ProjectSettingsChangeLogScalarFieldEnum
    having?: ProjectSettingsChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSettingsChangeLogCountAggregateInputType | true
    _avg?: ProjectSettingsChangeLogAvgAggregateInputType
    _sum?: ProjectSettingsChangeLogSumAggregateInputType
    _min?: ProjectSettingsChangeLogMinAggregateInputType
    _max?: ProjectSettingsChangeLogMaxAggregateInputType
  }

  export type ProjectSettingsChangeLogGroupByOutputType = {
    id: number
    projectId: number
    settingKey: string
    category: string
    oldValue: string | null
    newValue: string
    reason: string | null
    changedBy: number
    settingId: number
    createdAt: Date
    _count: ProjectSettingsChangeLogCountAggregateOutputType | null
    _avg: ProjectSettingsChangeLogAvgAggregateOutputType | null
    _sum: ProjectSettingsChangeLogSumAggregateOutputType | null
    _min: ProjectSettingsChangeLogMinAggregateOutputType | null
    _max: ProjectSettingsChangeLogMaxAggregateOutputType | null
  }

  type GetProjectSettingsChangeLogGroupByPayload<T extends ProjectSettingsChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSettingsChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSettingsChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSettingsChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSettingsChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSettingsChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    settingKey?: boolean
    category?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    changedBy?: boolean
    settingId?: boolean
    createdAt?: boolean
    setting?: boolean | ProjectSettingDefaultArgs<ExtArgs>
    changer?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSettingsChangeLog"]>


  export type ProjectSettingsChangeLogSelectScalar = {
    id?: boolean
    projectId?: boolean
    settingKey?: boolean
    category?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    changedBy?: boolean
    settingId?: boolean
    createdAt?: boolean
  }

  export type ProjectSettingsChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting?: boolean | ProjectSettingDefaultArgs<ExtArgs>
    changer?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectSettingsChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSettingsChangeLog"
    objects: {
      setting: Prisma.$ProjectSettingPayload<ExtArgs>
      changer: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      settingKey: string
      category: string
      oldValue: string | null
      newValue: string
      reason: string | null
      changedBy: number
      settingId: number
      createdAt: Date
    }, ExtArgs["result"]["projectSettingsChangeLog"]>
    composites: {}
  }

  type ProjectSettingsChangeLogGetPayload<S extends boolean | null | undefined | ProjectSettingsChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload, S>

  type ProjectSettingsChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectSettingsChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectSettingsChangeLogCountAggregateInputType | true
    }

  export interface ProjectSettingsChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSettingsChangeLog'], meta: { name: 'ProjectSettingsChangeLog' } }
    /**
     * Find zero or one ProjectSettingsChangeLog that matches the filter.
     * @param {ProjectSettingsChangeLogFindUniqueArgs} args - Arguments to find a ProjectSettingsChangeLog
     * @example
     * // Get one ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSettingsChangeLogFindUniqueArgs>(args: SelectSubset<T, ProjectSettingsChangeLogFindUniqueArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectSettingsChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectSettingsChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ProjectSettingsChangeLog
     * @example
     * // Get one ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSettingsChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectSettingsChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogFindFirstArgs} args - Arguments to find a ProjectSettingsChangeLog
     * @example
     * // Get one ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSettingsChangeLogFindFirstArgs>(args?: SelectSubset<T, ProjectSettingsChangeLogFindFirstArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectSettingsChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogFindFirstOrThrowArgs} args - Arguments to find a ProjectSettingsChangeLog
     * @example
     * // Get one ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSettingsChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSettingsChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectSettingsChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSettingsChangeLogs
     * const projectSettingsChangeLogs = await prisma.projectSettingsChangeLog.findMany()
     * 
     * // Get first 10 ProjectSettingsChangeLogs
     * const projectSettingsChangeLogs = await prisma.projectSettingsChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectSettingsChangeLogWithIdOnly = await prisma.projectSettingsChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectSettingsChangeLogFindManyArgs>(args?: SelectSubset<T, ProjectSettingsChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectSettingsChangeLog.
     * @param {ProjectSettingsChangeLogCreateArgs} args - Arguments to create a ProjectSettingsChangeLog.
     * @example
     * // Create one ProjectSettingsChangeLog
     * const ProjectSettingsChangeLog = await prisma.projectSettingsChangeLog.create({
     *   data: {
     *     // ... data to create a ProjectSettingsChangeLog
     *   }
     * })
     * 
     */
    create<T extends ProjectSettingsChangeLogCreateArgs>(args: SelectSubset<T, ProjectSettingsChangeLogCreateArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectSettingsChangeLogs.
     * @param {ProjectSettingsChangeLogCreateManyArgs} args - Arguments to create many ProjectSettingsChangeLogs.
     * @example
     * // Create many ProjectSettingsChangeLogs
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSettingsChangeLogCreateManyArgs>(args?: SelectSubset<T, ProjectSettingsChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectSettingsChangeLog.
     * @param {ProjectSettingsChangeLogDeleteArgs} args - Arguments to delete one ProjectSettingsChangeLog.
     * @example
     * // Delete one ProjectSettingsChangeLog
     * const ProjectSettingsChangeLog = await prisma.projectSettingsChangeLog.delete({
     *   where: {
     *     // ... filter to delete one ProjectSettingsChangeLog
     *   }
     * })
     * 
     */
    delete<T extends ProjectSettingsChangeLogDeleteArgs>(args: SelectSubset<T, ProjectSettingsChangeLogDeleteArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectSettingsChangeLog.
     * @param {ProjectSettingsChangeLogUpdateArgs} args - Arguments to update one ProjectSettingsChangeLog.
     * @example
     * // Update one ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSettingsChangeLogUpdateArgs>(args: SelectSubset<T, ProjectSettingsChangeLogUpdateArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectSettingsChangeLogs.
     * @param {ProjectSettingsChangeLogDeleteManyArgs} args - Arguments to filter ProjectSettingsChangeLogs to delete.
     * @example
     * // Delete a few ProjectSettingsChangeLogs
     * const { count } = await prisma.projectSettingsChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSettingsChangeLogDeleteManyArgs>(args?: SelectSubset<T, ProjectSettingsChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSettingsChangeLogs
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSettingsChangeLogUpdateManyArgs>(args: SelectSubset<T, ProjectSettingsChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectSettingsChangeLog.
     * @param {ProjectSettingsChangeLogUpsertArgs} args - Arguments to update or create a ProjectSettingsChangeLog.
     * @example
     * // Update or create a ProjectSettingsChangeLog
     * const projectSettingsChangeLog = await prisma.projectSettingsChangeLog.upsert({
     *   create: {
     *     // ... data to create a ProjectSettingsChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSettingsChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSettingsChangeLogUpsertArgs>(args: SelectSubset<T, ProjectSettingsChangeLogUpsertArgs<ExtArgs>>): Prisma__ProjectSettingsChangeLogClient<$Result.GetResult<Prisma.$ProjectSettingsChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectSettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogCountArgs} args - Arguments to filter ProjectSettingsChangeLogs to count.
     * @example
     * // Count the number of ProjectSettingsChangeLogs
     * const count = await prisma.projectSettingsChangeLog.count({
     *   where: {
     *     // ... the filter for the ProjectSettingsChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ProjectSettingsChangeLogCountArgs>(
      args?: Subset<T, ProjectSettingsChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSettingsChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSettingsChangeLogAggregateArgs>(args: Subset<T, ProjectSettingsChangeLogAggregateArgs>): Prisma.PrismaPromise<GetProjectSettingsChangeLogAggregateType<T>>

    /**
     * Group by ProjectSettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSettingsChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSettingsChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSettingsChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSettingsChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSettingsChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSettingsChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSettingsChangeLog model
   */
  readonly fields: ProjectSettingsChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSettingsChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSettingsChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting<T extends ProjectSettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectSettingDefaultArgs<ExtArgs>>): Prisma__ProjectSettingClient<$Result.GetResult<Prisma.$ProjectSettingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSettingsChangeLog model
   */ 
  interface ProjectSettingsChangeLogFieldRefs {
    readonly id: FieldRef<"ProjectSettingsChangeLog", 'Int'>
    readonly projectId: FieldRef<"ProjectSettingsChangeLog", 'Int'>
    readonly settingKey: FieldRef<"ProjectSettingsChangeLog", 'String'>
    readonly category: FieldRef<"ProjectSettingsChangeLog", 'String'>
    readonly oldValue: FieldRef<"ProjectSettingsChangeLog", 'String'>
    readonly newValue: FieldRef<"ProjectSettingsChangeLog", 'String'>
    readonly reason: FieldRef<"ProjectSettingsChangeLog", 'String'>
    readonly changedBy: FieldRef<"ProjectSettingsChangeLog", 'Int'>
    readonly settingId: FieldRef<"ProjectSettingsChangeLog", 'Int'>
    readonly createdAt: FieldRef<"ProjectSettingsChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSettingsChangeLog findUnique
   */
  export type ProjectSettingsChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingsChangeLog to fetch.
     */
    where: ProjectSettingsChangeLogWhereUniqueInput
  }

  /**
   * ProjectSettingsChangeLog findUniqueOrThrow
   */
  export type ProjectSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingsChangeLog to fetch.
     */
    where: ProjectSettingsChangeLogWhereUniqueInput
  }

  /**
   * ProjectSettingsChangeLog findFirst
   */
  export type ProjectSettingsChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingsChangeLog to fetch.
     */
    where?: ProjectSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingsChangeLogs to fetch.
     */
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettingsChangeLogs.
     */
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettingsChangeLogs.
     */
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * ProjectSettingsChangeLog findFirstOrThrow
   */
  export type ProjectSettingsChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingsChangeLog to fetch.
     */
    where?: ProjectSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingsChangeLogs to fetch.
     */
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSettingsChangeLogs.
     */
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSettingsChangeLogs.
     */
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * ProjectSettingsChangeLog findMany
   */
  export type ProjectSettingsChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSettingsChangeLogs to fetch.
     */
    where?: ProjectSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSettingsChangeLogs to fetch.
     */
    orderBy?: ProjectSettingsChangeLogOrderByWithRelationInput | ProjectSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSettingsChangeLogs.
     */
    cursor?: ProjectSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSettingsChangeLogs.
     */
    skip?: number
    distinct?: ProjectSettingsChangeLogScalarFieldEnum | ProjectSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * ProjectSettingsChangeLog create
   */
  export type ProjectSettingsChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSettingsChangeLog.
     */
    data: XOR<ProjectSettingsChangeLogCreateInput, ProjectSettingsChangeLogUncheckedCreateInput>
  }

  /**
   * ProjectSettingsChangeLog createMany
   */
  export type ProjectSettingsChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSettingsChangeLogs.
     */
    data: ProjectSettingsChangeLogCreateManyInput | ProjectSettingsChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSettingsChangeLog update
   */
  export type ProjectSettingsChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSettingsChangeLog.
     */
    data: XOR<ProjectSettingsChangeLogUpdateInput, ProjectSettingsChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ProjectSettingsChangeLog to update.
     */
    where: ProjectSettingsChangeLogWhereUniqueInput
  }

  /**
   * ProjectSettingsChangeLog updateMany
   */
  export type ProjectSettingsChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSettingsChangeLogs.
     */
    data: XOR<ProjectSettingsChangeLogUpdateManyMutationInput, ProjectSettingsChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSettingsChangeLogs to update
     */
    where?: ProjectSettingsChangeLogWhereInput
  }

  /**
   * ProjectSettingsChangeLog upsert
   */
  export type ProjectSettingsChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSettingsChangeLog to update in case it exists.
     */
    where: ProjectSettingsChangeLogWhereUniqueInput
    /**
     * In case the ProjectSettingsChangeLog found by the `where` argument doesn't exist, create a new ProjectSettingsChangeLog with this data.
     */
    create: XOR<ProjectSettingsChangeLogCreateInput, ProjectSettingsChangeLogUncheckedCreateInput>
    /**
     * In case the ProjectSettingsChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSettingsChangeLogUpdateInput, ProjectSettingsChangeLogUncheckedUpdateInput>
  }

  /**
   * ProjectSettingsChangeLog delete
   */
  export type ProjectSettingsChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ProjectSettingsChangeLog to delete.
     */
    where: ProjectSettingsChangeLogWhereUniqueInput
  }

  /**
   * ProjectSettingsChangeLog deleteMany
   */
  export type ProjectSettingsChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSettingsChangeLogs to delete
     */
    where?: ProjectSettingsChangeLogWhereInput
  }

  /**
   * ProjectSettingsChangeLog without action
   */
  export type ProjectSettingsChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSettingsChangeLog
     */
    select?: ProjectSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSettingsChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model UserSetting
   */

  export type AggregateUserSetting = {
    _count: UserSettingCountAggregateOutputType | null
    _avg: UserSettingAvgAggregateOutputType | null
    _sum: UserSettingSumAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  export type UserSettingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    updatedBy: number | null
  }

  export type UserSettingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    updatedBy: number | null
  }

  export type UserSettingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
    value: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserSettingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    key: string | null
    value: string | null
    category: string | null
    updatedAt: Date | null
    updatedBy: number | null
  }

  export type UserSettingCountAggregateOutputType = {
    id: number
    userId: number
    key: number
    value: number
    category: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type UserSettingAvgAggregateInputType = {
    id?: true
    userId?: true
    updatedBy?: true
  }

  export type UserSettingSumAggregateInputType = {
    id?: true
    userId?: true
    updatedBy?: true
  }

  export type UserSettingMinAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserSettingMaxAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type UserSettingCountAggregateInputType = {
    id?: true
    userId?: true
    key?: true
    value?: true
    category?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type UserSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSetting to aggregate.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingMaxAggregateInputType
  }

  export type GetUserSettingAggregateType<T extends UserSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSetting[P]>
      : GetScalarType<T[P], AggregateUserSetting[P]>
  }




  export type UserSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithAggregationInput | UserSettingOrderByWithAggregationInput[]
    by: UserSettingScalarFieldEnum[] | UserSettingScalarFieldEnum
    having?: UserSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingCountAggregateInputType | true
    _avg?: UserSettingAvgAggregateInputType
    _sum?: UserSettingSumAggregateInputType
    _min?: UserSettingMinAggregateInputType
    _max?: UserSettingMaxAggregateInputType
  }

  export type UserSettingGroupByOutputType = {
    id: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt: Date
    updatedBy: number
    _count: UserSettingCountAggregateOutputType | null
    _avg: UserSettingAvgAggregateOutputType | null
    _sum: UserSettingSumAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  type GetUserSettingGroupByPayload<T extends UserSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    updater?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeLogs?: boolean | UserSetting$changeLogsArgs<ExtArgs>
    _count?: boolean | UserSettingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>


  export type UserSettingSelectScalar = {
    id?: boolean
    userId?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type UserSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updater?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    changeLogs?: boolean | UserSetting$changeLogsArgs<ExtArgs>
    _count?: boolean | UserSettingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSetting"
    objects: {
      updater: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      changeLogs: Prisma.$UserSettingsChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      key: string
      value: string
      category: string
      updatedAt: Date
      updatedBy: number
    }, ExtArgs["result"]["userSetting"]>
    composites: {}
  }

  type UserSettingGetPayload<S extends boolean | null | undefined | UserSettingDefaultArgs> = $Result.GetResult<Prisma.$UserSettingPayload, S>

  type UserSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingCountAggregateInputType | true
    }

  export interface UserSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSetting'], meta: { name: 'UserSetting' } }
    /**
     * Find zero or one UserSetting that matches the filter.
     * @param {UserSettingFindUniqueArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingFindUniqueArgs>(args: SelectSubset<T, UserSettingFindUniqueArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingFindUniqueOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingFindFirstArgs>(args?: SelectSubset<T, UserSettingFindFirstArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSetting.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingWithIdOnly = await prisma.userSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingFindManyArgs>(args?: SelectSubset<T, UserSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSetting.
     * @param {UserSettingCreateArgs} args - Arguments to create a UserSetting.
     * @example
     * // Create one UserSetting
     * const UserSetting = await prisma.userSetting.create({
     *   data: {
     *     // ... data to create a UserSetting
     *   }
     * })
     * 
     */
    create<T extends UserSettingCreateArgs>(args: SelectSubset<T, UserSettingCreateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingCreateManyArgs>(args?: SelectSubset<T, UserSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSetting.
     * @param {UserSettingDeleteArgs} args - Arguments to delete one UserSetting.
     * @example
     * // Delete one UserSetting
     * const UserSetting = await prisma.userSetting.delete({
     *   where: {
     *     // ... filter to delete one UserSetting
     *   }
     * })
     * 
     */
    delete<T extends UserSettingDeleteArgs>(args: SelectSubset<T, UserSettingDeleteArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSetting.
     * @param {UserSettingUpdateArgs} args - Arguments to update one UserSetting.
     * @example
     * // Update one UserSetting
     * const userSetting = await prisma.userSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingUpdateArgs>(args: SelectSubset<T, UserSettingUpdateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingDeleteManyArgs>(args?: SelectSubset<T, UserSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingUpdateManyArgs>(args: SelectSubset<T, UserSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSetting.
     * @param {UserSettingUpsertArgs} args - Arguments to update or create a UserSetting.
     * @example
     * // Update or create a UserSetting
     * const userSetting = await prisma.userSetting.upsert({
     *   create: {
     *     // ... data to create a UserSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingUpsertArgs>(args: SelectSubset<T, UserSettingUpsertArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSetting.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingCountArgs>(
      args?: Subset<T, UserSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingAggregateArgs>(args: Subset<T, UserSettingAggregateArgs>): Prisma.PrismaPromise<GetUserSettingAggregateType<T>>

    /**
     * Group by UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSetting model
   */
  readonly fields: UserSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    updater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changeLogs<T extends UserSetting$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, UserSetting$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSetting model
   */ 
  interface UserSettingFieldRefs {
    readonly id: FieldRef<"UserSetting", 'Int'>
    readonly userId: FieldRef<"UserSetting", 'Int'>
    readonly key: FieldRef<"UserSetting", 'String'>
    readonly value: FieldRef<"UserSetting", 'String'>
    readonly category: FieldRef<"UserSetting", 'String'>
    readonly updatedAt: FieldRef<"UserSetting", 'DateTime'>
    readonly updatedBy: FieldRef<"UserSetting", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserSetting findUnique
   */
  export type UserSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findUniqueOrThrow
   */
  export type UserSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findFirst
   */
  export type UserSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findFirstOrThrow
   */
  export type UserSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findMany
   */
  export type UserSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting create
   */
  export type UserSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSetting.
     */
    data: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
  }

  /**
   * UserSetting createMany
   */
  export type UserSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSetting update
   */
  export type UserSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSetting.
     */
    data: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
    /**
     * Choose, which UserSetting to update.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting updateMany
   */
  export type UserSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
  }

  /**
   * UserSetting upsert
   */
  export type UserSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSetting to update in case it exists.
     */
    where: UserSettingWhereUniqueInput
    /**
     * In case the UserSetting found by the `where` argument doesn't exist, create a new UserSetting with this data.
     */
    create: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
    /**
     * In case the UserSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
  }

  /**
   * UserSetting delete
   */
  export type UserSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter which UserSetting to delete.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting deleteMany
   */
  export type UserSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingWhereInput
  }

  /**
   * UserSetting.changeLogs
   */
  export type UserSetting$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    where?: UserSettingsChangeLogWhereInput
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    cursor?: UserSettingsChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * UserSetting without action
   */
  export type UserSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
  }


  /**
   * Model UserSettingsChangeLog
   */

  export type AggregateUserSettingsChangeLog = {
    _count: UserSettingsChangeLogCountAggregateOutputType | null
    _avg: UserSettingsChangeLogAvgAggregateOutputType | null
    _sum: UserSettingsChangeLogSumAggregateOutputType | null
    _min: UserSettingsChangeLogMinAggregateOutputType | null
    _max: UserSettingsChangeLogMaxAggregateOutputType | null
  }

  export type UserSettingsChangeLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    changedBy: number | null
    settingId: number | null
  }

  export type UserSettingsChangeLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    changedBy: number | null
    settingId: number | null
  }

  export type UserSettingsChangeLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    settingKey: string | null
    category: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    changedBy: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type UserSettingsChangeLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    settingKey: string | null
    category: string | null
    oldValue: string | null
    newValue: string | null
    reason: string | null
    changedBy: number | null
    settingId: number | null
    createdAt: Date | null
  }

  export type UserSettingsChangeLogCountAggregateOutputType = {
    id: number
    userId: number
    settingKey: number
    category: number
    oldValue: number
    newValue: number
    reason: number
    changedBy: number
    settingId: number
    createdAt: number
    _all: number
  }


  export type UserSettingsChangeLogAvgAggregateInputType = {
    id?: true
    userId?: true
    changedBy?: true
    settingId?: true
  }

  export type UserSettingsChangeLogSumAggregateInputType = {
    id?: true
    userId?: true
    changedBy?: true
    settingId?: true
  }

  export type UserSettingsChangeLogMinAggregateInputType = {
    id?: true
    userId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
  }

  export type UserSettingsChangeLogMaxAggregateInputType = {
    id?: true
    userId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
  }

  export type UserSettingsChangeLogCountAggregateInputType = {
    id?: true
    userId?: true
    settingKey?: true
    category?: true
    oldValue?: true
    newValue?: true
    reason?: true
    changedBy?: true
    settingId?: true
    createdAt?: true
    _all?: true
  }

  export type UserSettingsChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettingsChangeLog to aggregate.
     */
    where?: UserSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettingsChangeLogs to fetch.
     */
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettingsChangeLogs
    **/
    _count?: true | UserSettingsChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsChangeLogMaxAggregateInputType
  }

  export type GetUserSettingsChangeLogAggregateType<T extends UserSettingsChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettingsChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettingsChangeLog[P]>
      : GetScalarType<T[P], AggregateUserSettingsChangeLog[P]>
  }




  export type UserSettingsChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsChangeLogWhereInput
    orderBy?: UserSettingsChangeLogOrderByWithAggregationInput | UserSettingsChangeLogOrderByWithAggregationInput[]
    by: UserSettingsChangeLogScalarFieldEnum[] | UserSettingsChangeLogScalarFieldEnum
    having?: UserSettingsChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsChangeLogCountAggregateInputType | true
    _avg?: UserSettingsChangeLogAvgAggregateInputType
    _sum?: UserSettingsChangeLogSumAggregateInputType
    _min?: UserSettingsChangeLogMinAggregateInputType
    _max?: UserSettingsChangeLogMaxAggregateInputType
  }

  export type UserSettingsChangeLogGroupByOutputType = {
    id: number
    userId: number
    settingKey: string
    category: string
    oldValue: string | null
    newValue: string
    reason: string | null
    changedBy: number
    settingId: number
    createdAt: Date
    _count: UserSettingsChangeLogCountAggregateOutputType | null
    _avg: UserSettingsChangeLogAvgAggregateOutputType | null
    _sum: UserSettingsChangeLogSumAggregateOutputType | null
    _min: UserSettingsChangeLogMinAggregateOutputType | null
    _max: UserSettingsChangeLogMaxAggregateOutputType | null
  }

  type GetUserSettingsChangeLogGroupByPayload<T extends UserSettingsChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    settingKey?: boolean
    category?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    changedBy?: boolean
    settingId?: boolean
    createdAt?: boolean
    setting?: boolean | UserSettingDefaultArgs<ExtArgs>
    changer?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettingsChangeLog"]>


  export type UserSettingsChangeLogSelectScalar = {
    id?: boolean
    userId?: boolean
    settingKey?: boolean
    category?: boolean
    oldValue?: boolean
    newValue?: boolean
    reason?: boolean
    changedBy?: boolean
    settingId?: boolean
    createdAt?: boolean
  }

  export type UserSettingsChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setting?: boolean | UserSettingDefaultArgs<ExtArgs>
    changer?: boolean | UserDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettingsChangeLog"
    objects: {
      setting: Prisma.$UserSettingPayload<ExtArgs>
      changer: Prisma.$UserPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      settingKey: string
      category: string
      oldValue: string | null
      newValue: string
      reason: string | null
      changedBy: number
      settingId: number
      createdAt: Date
    }, ExtArgs["result"]["userSettingsChangeLog"]>
    composites: {}
  }

  type UserSettingsChangeLogGetPayload<S extends boolean | null | undefined | UserSettingsChangeLogDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsChangeLogPayload, S>

  type UserSettingsChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsChangeLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsChangeLogCountAggregateInputType | true
    }

  export interface UserSettingsChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettingsChangeLog'], meta: { name: 'UserSettingsChangeLog' } }
    /**
     * Find zero or one UserSettingsChangeLog that matches the filter.
     * @param {UserSettingsChangeLogFindUniqueArgs} args - Arguments to find a UserSettingsChangeLog
     * @example
     * // Get one UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsChangeLogFindUniqueArgs>(args: SelectSubset<T, UserSettingsChangeLogFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettingsChangeLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsChangeLogFindUniqueOrThrowArgs} args - Arguments to find a UserSettingsChangeLog
     * @example
     * // Get one UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettingsChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogFindFirstArgs} args - Arguments to find a UserSettingsChangeLog
     * @example
     * // Get one UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsChangeLogFindFirstArgs>(args?: SelectSubset<T, UserSettingsChangeLogFindFirstArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettingsChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogFindFirstOrThrowArgs} args - Arguments to find a UserSettingsChangeLog
     * @example
     * // Get one UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettingsChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettingsChangeLogs
     * const userSettingsChangeLogs = await prisma.userSettingsChangeLog.findMany()
     * 
     * // Get first 10 UserSettingsChangeLogs
     * const userSettingsChangeLogs = await prisma.userSettingsChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsChangeLogWithIdOnly = await prisma.userSettingsChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsChangeLogFindManyArgs>(args?: SelectSubset<T, UserSettingsChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettingsChangeLog.
     * @param {UserSettingsChangeLogCreateArgs} args - Arguments to create a UserSettingsChangeLog.
     * @example
     * // Create one UserSettingsChangeLog
     * const UserSettingsChangeLog = await prisma.userSettingsChangeLog.create({
     *   data: {
     *     // ... data to create a UserSettingsChangeLog
     *   }
     * })
     * 
     */
    create<T extends UserSettingsChangeLogCreateArgs>(args: SelectSubset<T, UserSettingsChangeLogCreateArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettingsChangeLogs.
     * @param {UserSettingsChangeLogCreateManyArgs} args - Arguments to create many UserSettingsChangeLogs.
     * @example
     * // Create many UserSettingsChangeLogs
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsChangeLogCreateManyArgs>(args?: SelectSubset<T, UserSettingsChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSettingsChangeLog.
     * @param {UserSettingsChangeLogDeleteArgs} args - Arguments to delete one UserSettingsChangeLog.
     * @example
     * // Delete one UserSettingsChangeLog
     * const UserSettingsChangeLog = await prisma.userSettingsChangeLog.delete({
     *   where: {
     *     // ... filter to delete one UserSettingsChangeLog
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsChangeLogDeleteArgs>(args: SelectSubset<T, UserSettingsChangeLogDeleteArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettingsChangeLog.
     * @param {UserSettingsChangeLogUpdateArgs} args - Arguments to update one UserSettingsChangeLog.
     * @example
     * // Update one UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsChangeLogUpdateArgs>(args: SelectSubset<T, UserSettingsChangeLogUpdateArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettingsChangeLogs.
     * @param {UserSettingsChangeLogDeleteManyArgs} args - Arguments to filter UserSettingsChangeLogs to delete.
     * @example
     * // Delete a few UserSettingsChangeLogs
     * const { count } = await prisma.userSettingsChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsChangeLogDeleteManyArgs>(args?: SelectSubset<T, UserSettingsChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettingsChangeLogs
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsChangeLogUpdateManyArgs>(args: SelectSubset<T, UserSettingsChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettingsChangeLog.
     * @param {UserSettingsChangeLogUpsertArgs} args - Arguments to update or create a UserSettingsChangeLog.
     * @example
     * // Update or create a UserSettingsChangeLog
     * const userSettingsChangeLog = await prisma.userSettingsChangeLog.upsert({
     *   create: {
     *     // ... data to create a UserSettingsChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettingsChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsChangeLogUpsertArgs>(args: SelectSubset<T, UserSettingsChangeLogUpsertArgs<ExtArgs>>): Prisma__UserSettingsChangeLogClient<$Result.GetResult<Prisma.$UserSettingsChangeLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettingsChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogCountArgs} args - Arguments to filter UserSettingsChangeLogs to count.
     * @example
     * // Count the number of UserSettingsChangeLogs
     * const count = await prisma.userSettingsChangeLog.count({
     *   where: {
     *     // ... the filter for the UserSettingsChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsChangeLogCountArgs>(
      args?: Subset<T, UserSettingsChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsChangeLogAggregateArgs>(args: Subset<T, UserSettingsChangeLogAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsChangeLogAggregateType<T>>

    /**
     * Group by UserSettingsChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettingsChangeLog model
   */
  readonly fields: UserSettingsChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettingsChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    setting<T extends UserSettingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserSettingDefaultArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettingsChangeLog model
   */ 
  interface UserSettingsChangeLogFieldRefs {
    readonly id: FieldRef<"UserSettingsChangeLog", 'Int'>
    readonly userId: FieldRef<"UserSettingsChangeLog", 'Int'>
    readonly settingKey: FieldRef<"UserSettingsChangeLog", 'String'>
    readonly category: FieldRef<"UserSettingsChangeLog", 'String'>
    readonly oldValue: FieldRef<"UserSettingsChangeLog", 'String'>
    readonly newValue: FieldRef<"UserSettingsChangeLog", 'String'>
    readonly reason: FieldRef<"UserSettingsChangeLog", 'String'>
    readonly changedBy: FieldRef<"UserSettingsChangeLog", 'Int'>
    readonly settingId: FieldRef<"UserSettingsChangeLog", 'Int'>
    readonly createdAt: FieldRef<"UserSettingsChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettingsChangeLog findUnique
   */
  export type UserSettingsChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which UserSettingsChangeLog to fetch.
     */
    where: UserSettingsChangeLogWhereUniqueInput
  }

  /**
   * UserSettingsChangeLog findUniqueOrThrow
   */
  export type UserSettingsChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which UserSettingsChangeLog to fetch.
     */
    where: UserSettingsChangeLogWhereUniqueInput
  }

  /**
   * UserSettingsChangeLog findFirst
   */
  export type UserSettingsChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which UserSettingsChangeLog to fetch.
     */
    where?: UserSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettingsChangeLogs to fetch.
     */
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettingsChangeLogs.
     */
    cursor?: UserSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettingsChangeLogs.
     */
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * UserSettingsChangeLog findFirstOrThrow
   */
  export type UserSettingsChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which UserSettingsChangeLog to fetch.
     */
    where?: UserSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettingsChangeLogs to fetch.
     */
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettingsChangeLogs.
     */
    cursor?: UserSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettingsChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettingsChangeLogs.
     */
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * UserSettingsChangeLog findMany
   */
  export type UserSettingsChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which UserSettingsChangeLogs to fetch.
     */
    where?: UserSettingsChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettingsChangeLogs to fetch.
     */
    orderBy?: UserSettingsChangeLogOrderByWithRelationInput | UserSettingsChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettingsChangeLogs.
     */
    cursor?: UserSettingsChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettingsChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettingsChangeLogs.
     */
    skip?: number
    distinct?: UserSettingsChangeLogScalarFieldEnum | UserSettingsChangeLogScalarFieldEnum[]
  }

  /**
   * UserSettingsChangeLog create
   */
  export type UserSettingsChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettingsChangeLog.
     */
    data: XOR<UserSettingsChangeLogCreateInput, UserSettingsChangeLogUncheckedCreateInput>
  }

  /**
   * UserSettingsChangeLog createMany
   */
  export type UserSettingsChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettingsChangeLogs.
     */
    data: UserSettingsChangeLogCreateManyInput | UserSettingsChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettingsChangeLog update
   */
  export type UserSettingsChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettingsChangeLog.
     */
    data: XOR<UserSettingsChangeLogUpdateInput, UserSettingsChangeLogUncheckedUpdateInput>
    /**
     * Choose, which UserSettingsChangeLog to update.
     */
    where: UserSettingsChangeLogWhereUniqueInput
  }

  /**
   * UserSettingsChangeLog updateMany
   */
  export type UserSettingsChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettingsChangeLogs.
     */
    data: XOR<UserSettingsChangeLogUpdateManyMutationInput, UserSettingsChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which UserSettingsChangeLogs to update
     */
    where?: UserSettingsChangeLogWhereInput
  }

  /**
   * UserSettingsChangeLog upsert
   */
  export type UserSettingsChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettingsChangeLog to update in case it exists.
     */
    where: UserSettingsChangeLogWhereUniqueInput
    /**
     * In case the UserSettingsChangeLog found by the `where` argument doesn't exist, create a new UserSettingsChangeLog with this data.
     */
    create: XOR<UserSettingsChangeLogCreateInput, UserSettingsChangeLogUncheckedCreateInput>
    /**
     * In case the UserSettingsChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsChangeLogUpdateInput, UserSettingsChangeLogUncheckedUpdateInput>
  }

  /**
   * UserSettingsChangeLog delete
   */
  export type UserSettingsChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
    /**
     * Filter which UserSettingsChangeLog to delete.
     */
    where: UserSettingsChangeLogWhereUniqueInput
  }

  /**
   * UserSettingsChangeLog deleteMany
   */
  export type UserSettingsChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettingsChangeLogs to delete
     */
    where?: UserSettingsChangeLogWhereInput
  }

  /**
   * UserSettingsChangeLog without action
   */
  export type UserSettingsChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettingsChangeLog
     */
    select?: UserSettingsChangeLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model ProjectNotification
   */

  export type AggregateProjectNotification = {
    _count: ProjectNotificationCountAggregateOutputType | null
    _avg: ProjectNotificationAvgAggregateOutputType | null
    _sum: ProjectNotificationSumAggregateOutputType | null
    _min: ProjectNotificationMinAggregateOutputType | null
    _max: ProjectNotificationMaxAggregateOutputType | null
  }

  export type ProjectNotificationAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    entityId: number | null
  }

  export type ProjectNotificationSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    entityId: number | null
  }

  export type ProjectNotificationMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    type: string | null
    entityType: string | null
    entityId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    soundRequired: boolean | null
    isUrgent: boolean | null
    requiresAcknowledgment: boolean | null
    acknowledgedAt: Date | null
    createdAt: Date | null
  }

  export type ProjectNotificationMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    type: string | null
    entityType: string | null
    entityId: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    soundRequired: boolean | null
    isUrgent: boolean | null
    requiresAcknowledgment: boolean | null
    acknowledgedAt: Date | null
    createdAt: Date | null
  }

  export type ProjectNotificationCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    type: number
    entityType: number
    entityId: number
    title: number
    message: number
    isRead: number
    soundRequired: number
    isUrgent: number
    requiresAcknowledgment: number
    acknowledgedAt: number
    createdAt: number
    _all: number
  }


  export type ProjectNotificationAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    entityId?: true
  }

  export type ProjectNotificationSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    entityId?: true
  }

  export type ProjectNotificationMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    title?: true
    message?: true
    isRead?: true
    soundRequired?: true
    isUrgent?: true
    requiresAcknowledgment?: true
    acknowledgedAt?: true
    createdAt?: true
  }

  export type ProjectNotificationMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    title?: true
    message?: true
    isRead?: true
    soundRequired?: true
    isUrgent?: true
    requiresAcknowledgment?: true
    acknowledgedAt?: true
    createdAt?: true
  }

  export type ProjectNotificationCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    type?: true
    entityType?: true
    entityId?: true
    title?: true
    message?: true
    isRead?: true
    soundRequired?: true
    isUrgent?: true
    requiresAcknowledgment?: true
    acknowledgedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotification to aggregate.
     */
    where?: ProjectNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotifications to fetch.
     */
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectNotifications
    **/
    _count?: true | ProjectNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectNotificationMaxAggregateInputType
  }

  export type GetProjectNotificationAggregateType<T extends ProjectNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectNotification[P]>
      : GetScalarType<T[P], AggregateProjectNotification[P]>
  }




  export type ProjectNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationWhereInput
    orderBy?: ProjectNotificationOrderByWithAggregationInput | ProjectNotificationOrderByWithAggregationInput[]
    by: ProjectNotificationScalarFieldEnum[] | ProjectNotificationScalarFieldEnum
    having?: ProjectNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectNotificationCountAggregateInputType | true
    _avg?: ProjectNotificationAvgAggregateInputType
    _sum?: ProjectNotificationSumAggregateInputType
    _min?: ProjectNotificationMinAggregateInputType
    _max?: ProjectNotificationMaxAggregateInputType
  }

  export type ProjectNotificationGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    type: string
    entityType: string
    entityId: number | null
    title: string
    message: string
    isRead: boolean
    soundRequired: boolean
    isUrgent: boolean
    requiresAcknowledgment: boolean
    acknowledgedAt: Date | null
    createdAt: Date
    _count: ProjectNotificationCountAggregateOutputType | null
    _avg: ProjectNotificationAvgAggregateOutputType | null
    _sum: ProjectNotificationSumAggregateOutputType | null
    _min: ProjectNotificationMinAggregateOutputType | null
    _max: ProjectNotificationMaxAggregateOutputType | null
  }

  type GetProjectNotificationGroupByPayload<T extends ProjectNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ProjectNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    type?: boolean
    entityType?: boolean
    entityId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectNotification"]>


  export type ProjectNotificationSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    type?: boolean
    entityType?: boolean
    entityId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: boolean
    createdAt?: boolean
  }

  export type ProjectNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      type: string
      entityType: string
      entityId: number | null
      title: string
      message: string
      isRead: boolean
      soundRequired: boolean
      isUrgent: boolean
      requiresAcknowledgment: boolean
      acknowledgedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["projectNotification"]>
    composites: {}
  }

  type ProjectNotificationGetPayload<S extends boolean | null | undefined | ProjectNotificationDefaultArgs> = $Result.GetResult<Prisma.$ProjectNotificationPayload, S>

  type ProjectNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectNotificationCountAggregateInputType | true
    }

  export interface ProjectNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectNotification'], meta: { name: 'ProjectNotification' } }
    /**
     * Find zero or one ProjectNotification that matches the filter.
     * @param {ProjectNotificationFindUniqueArgs} args - Arguments to find a ProjectNotification
     * @example
     * // Get one ProjectNotification
     * const projectNotification = await prisma.projectNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectNotificationFindUniqueArgs>(args: SelectSubset<T, ProjectNotificationFindUniqueArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectNotificationFindUniqueOrThrowArgs} args - Arguments to find a ProjectNotification
     * @example
     * // Get one ProjectNotification
     * const projectNotification = await prisma.projectNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationFindFirstArgs} args - Arguments to find a ProjectNotification
     * @example
     * // Get one ProjectNotification
     * const projectNotification = await prisma.projectNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectNotificationFindFirstArgs>(args?: SelectSubset<T, ProjectNotificationFindFirstArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationFindFirstOrThrowArgs} args - Arguments to find a ProjectNotification
     * @example
     * // Get one ProjectNotification
     * const projectNotification = await prisma.projectNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectNotifications
     * const projectNotifications = await prisma.projectNotification.findMany()
     * 
     * // Get first 10 ProjectNotifications
     * const projectNotifications = await prisma.projectNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectNotificationWithIdOnly = await prisma.projectNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectNotificationFindManyArgs>(args?: SelectSubset<T, ProjectNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectNotification.
     * @param {ProjectNotificationCreateArgs} args - Arguments to create a ProjectNotification.
     * @example
     * // Create one ProjectNotification
     * const ProjectNotification = await prisma.projectNotification.create({
     *   data: {
     *     // ... data to create a ProjectNotification
     *   }
     * })
     * 
     */
    create<T extends ProjectNotificationCreateArgs>(args: SelectSubset<T, ProjectNotificationCreateArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectNotifications.
     * @param {ProjectNotificationCreateManyArgs} args - Arguments to create many ProjectNotifications.
     * @example
     * // Create many ProjectNotifications
     * const projectNotification = await prisma.projectNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectNotificationCreateManyArgs>(args?: SelectSubset<T, ProjectNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectNotification.
     * @param {ProjectNotificationDeleteArgs} args - Arguments to delete one ProjectNotification.
     * @example
     * // Delete one ProjectNotification
     * const ProjectNotification = await prisma.projectNotification.delete({
     *   where: {
     *     // ... filter to delete one ProjectNotification
     *   }
     * })
     * 
     */
    delete<T extends ProjectNotificationDeleteArgs>(args: SelectSubset<T, ProjectNotificationDeleteArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectNotification.
     * @param {ProjectNotificationUpdateArgs} args - Arguments to update one ProjectNotification.
     * @example
     * // Update one ProjectNotification
     * const projectNotification = await prisma.projectNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectNotificationUpdateArgs>(args: SelectSubset<T, ProjectNotificationUpdateArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectNotifications.
     * @param {ProjectNotificationDeleteManyArgs} args - Arguments to filter ProjectNotifications to delete.
     * @example
     * // Delete a few ProjectNotifications
     * const { count } = await prisma.projectNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectNotificationDeleteManyArgs>(args?: SelectSubset<T, ProjectNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectNotifications
     * const projectNotification = await prisma.projectNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectNotificationUpdateManyArgs>(args: SelectSubset<T, ProjectNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectNotification.
     * @param {ProjectNotificationUpsertArgs} args - Arguments to update or create a ProjectNotification.
     * @example
     * // Update or create a ProjectNotification
     * const projectNotification = await prisma.projectNotification.upsert({
     *   create: {
     *     // ... data to create a ProjectNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectNotification we want to update
     *   }
     * })
     */
    upsert<T extends ProjectNotificationUpsertArgs>(args: SelectSubset<T, ProjectNotificationUpsertArgs<ExtArgs>>): Prisma__ProjectNotificationClient<$Result.GetResult<Prisma.$ProjectNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationCountArgs} args - Arguments to filter ProjectNotifications to count.
     * @example
     * // Count the number of ProjectNotifications
     * const count = await prisma.projectNotification.count({
     *   where: {
     *     // ... the filter for the ProjectNotifications we want to count
     *   }
     * })
    **/
    count<T extends ProjectNotificationCountArgs>(
      args?: Subset<T, ProjectNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectNotificationAggregateArgs>(args: Subset<T, ProjectNotificationAggregateArgs>): Prisma.PrismaPromise<GetProjectNotificationAggregateType<T>>

    /**
     * Group by ProjectNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ProjectNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectNotification model
   */
  readonly fields: ProjectNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectNotification model
   */ 
  interface ProjectNotificationFieldRefs {
    readonly id: FieldRef<"ProjectNotification", 'Int'>
    readonly projectId: FieldRef<"ProjectNotification", 'Int'>
    readonly userId: FieldRef<"ProjectNotification", 'Int'>
    readonly type: FieldRef<"ProjectNotification", 'String'>
    readonly entityType: FieldRef<"ProjectNotification", 'String'>
    readonly entityId: FieldRef<"ProjectNotification", 'Int'>
    readonly title: FieldRef<"ProjectNotification", 'String'>
    readonly message: FieldRef<"ProjectNotification", 'String'>
    readonly isRead: FieldRef<"ProjectNotification", 'Boolean'>
    readonly soundRequired: FieldRef<"ProjectNotification", 'Boolean'>
    readonly isUrgent: FieldRef<"ProjectNotification", 'Boolean'>
    readonly requiresAcknowledgment: FieldRef<"ProjectNotification", 'Boolean'>
    readonly acknowledgedAt: FieldRef<"ProjectNotification", 'DateTime'>
    readonly createdAt: FieldRef<"ProjectNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectNotification findUnique
   */
  export type ProjectNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotification to fetch.
     */
    where: ProjectNotificationWhereUniqueInput
  }

  /**
   * ProjectNotification findUniqueOrThrow
   */
  export type ProjectNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotification to fetch.
     */
    where: ProjectNotificationWhereUniqueInput
  }

  /**
   * ProjectNotification findFirst
   */
  export type ProjectNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotification to fetch.
     */
    where?: ProjectNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotifications to fetch.
     */
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotifications.
     */
    cursor?: ProjectNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotifications.
     */
    distinct?: ProjectNotificationScalarFieldEnum | ProjectNotificationScalarFieldEnum[]
  }

  /**
   * ProjectNotification findFirstOrThrow
   */
  export type ProjectNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotification to fetch.
     */
    where?: ProjectNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotifications to fetch.
     */
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotifications.
     */
    cursor?: ProjectNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotifications.
     */
    distinct?: ProjectNotificationScalarFieldEnum | ProjectNotificationScalarFieldEnum[]
  }

  /**
   * ProjectNotification findMany
   */
  export type ProjectNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotifications to fetch.
     */
    where?: ProjectNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotifications to fetch.
     */
    orderBy?: ProjectNotificationOrderByWithRelationInput | ProjectNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectNotifications.
     */
    cursor?: ProjectNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotifications.
     */
    skip?: number
    distinct?: ProjectNotificationScalarFieldEnum | ProjectNotificationScalarFieldEnum[]
  }

  /**
   * ProjectNotification create
   */
  export type ProjectNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectNotification.
     */
    data: XOR<ProjectNotificationCreateInput, ProjectNotificationUncheckedCreateInput>
  }

  /**
   * ProjectNotification createMany
   */
  export type ProjectNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectNotifications.
     */
    data: ProjectNotificationCreateManyInput | ProjectNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectNotification update
   */
  export type ProjectNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectNotification.
     */
    data: XOR<ProjectNotificationUpdateInput, ProjectNotificationUncheckedUpdateInput>
    /**
     * Choose, which ProjectNotification to update.
     */
    where: ProjectNotificationWhereUniqueInput
  }

  /**
   * ProjectNotification updateMany
   */
  export type ProjectNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectNotifications.
     */
    data: XOR<ProjectNotificationUpdateManyMutationInput, ProjectNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ProjectNotifications to update
     */
    where?: ProjectNotificationWhereInput
  }

  /**
   * ProjectNotification upsert
   */
  export type ProjectNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectNotification to update in case it exists.
     */
    where: ProjectNotificationWhereUniqueInput
    /**
     * In case the ProjectNotification found by the `where` argument doesn't exist, create a new ProjectNotification with this data.
     */
    create: XOR<ProjectNotificationCreateInput, ProjectNotificationUncheckedCreateInput>
    /**
     * In case the ProjectNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectNotificationUpdateInput, ProjectNotificationUncheckedUpdateInput>
  }

  /**
   * ProjectNotification delete
   */
  export type ProjectNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
    /**
     * Filter which ProjectNotification to delete.
     */
    where: ProjectNotificationWhereUniqueInput
  }

  /**
   * ProjectNotification deleteMany
   */
  export type ProjectNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotifications to delete
     */
    where?: ProjectNotificationWhereInput
  }

  /**
   * ProjectNotification without action
   */
  export type ProjectNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotification
     */
    select?: ProjectNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationInclude<ExtArgs> | null
  }


  /**
   * Model UrgentProjectAcknowledgement
   */

  export type AggregateUrgentProjectAcknowledgement = {
    _count: UrgentProjectAcknowledgementCountAggregateOutputType | null
    _avg: UrgentProjectAcknowledgementAvgAggregateOutputType | null
    _sum: UrgentProjectAcknowledgementSumAggregateOutputType | null
    _min: UrgentProjectAcknowledgementMinAggregateOutputType | null
    _max: UrgentProjectAcknowledgementMaxAggregateOutputType | null
  }

  export type UrgentProjectAcknowledgementAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type UrgentProjectAcknowledgementSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type UrgentProjectAcknowledgementMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    acknowledgedAt: Date | null
  }

  export type UrgentProjectAcknowledgementMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    acknowledgedAt: Date | null
  }

  export type UrgentProjectAcknowledgementCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    acknowledgedAt: number
    _all: number
  }


  export type UrgentProjectAcknowledgementAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type UrgentProjectAcknowledgementSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type UrgentProjectAcknowledgementMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    acknowledgedAt?: true
  }

  export type UrgentProjectAcknowledgementMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    acknowledgedAt?: true
  }

  export type UrgentProjectAcknowledgementCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    acknowledgedAt?: true
    _all?: true
  }

  export type UrgentProjectAcknowledgementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UrgentProjectAcknowledgement to aggregate.
     */
    where?: UrgentProjectAcknowledgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UrgentProjectAcknowledgements to fetch.
     */
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UrgentProjectAcknowledgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UrgentProjectAcknowledgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UrgentProjectAcknowledgements
    **/
    _count?: true | UrgentProjectAcknowledgementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UrgentProjectAcknowledgementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UrgentProjectAcknowledgementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UrgentProjectAcknowledgementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UrgentProjectAcknowledgementMaxAggregateInputType
  }

  export type GetUrgentProjectAcknowledgementAggregateType<T extends UrgentProjectAcknowledgementAggregateArgs> = {
        [P in keyof T & keyof AggregateUrgentProjectAcknowledgement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUrgentProjectAcknowledgement[P]>
      : GetScalarType<T[P], AggregateUrgentProjectAcknowledgement[P]>
  }




  export type UrgentProjectAcknowledgementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UrgentProjectAcknowledgementWhereInput
    orderBy?: UrgentProjectAcknowledgementOrderByWithAggregationInput | UrgentProjectAcknowledgementOrderByWithAggregationInput[]
    by: UrgentProjectAcknowledgementScalarFieldEnum[] | UrgentProjectAcknowledgementScalarFieldEnum
    having?: UrgentProjectAcknowledgementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UrgentProjectAcknowledgementCountAggregateInputType | true
    _avg?: UrgentProjectAcknowledgementAvgAggregateInputType
    _sum?: UrgentProjectAcknowledgementSumAggregateInputType
    _min?: UrgentProjectAcknowledgementMinAggregateInputType
    _max?: UrgentProjectAcknowledgementMaxAggregateInputType
  }

  export type UrgentProjectAcknowledgementGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    acknowledgedAt: Date
    _count: UrgentProjectAcknowledgementCountAggregateOutputType | null
    _avg: UrgentProjectAcknowledgementAvgAggregateOutputType | null
    _sum: UrgentProjectAcknowledgementSumAggregateOutputType | null
    _min: UrgentProjectAcknowledgementMinAggregateOutputType | null
    _max: UrgentProjectAcknowledgementMaxAggregateOutputType | null
  }

  type GetUrgentProjectAcknowledgementGroupByPayload<T extends UrgentProjectAcknowledgementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UrgentProjectAcknowledgementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UrgentProjectAcknowledgementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UrgentProjectAcknowledgementGroupByOutputType[P]>
            : GetScalarType<T[P], UrgentProjectAcknowledgementGroupByOutputType[P]>
        }
      >
    >


  export type UrgentProjectAcknowledgementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    acknowledgedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["urgentProjectAcknowledgement"]>


  export type UrgentProjectAcknowledgementSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    acknowledgedAt?: boolean
  }

  export type UrgentProjectAcknowledgementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UrgentProjectAcknowledgementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UrgentProjectAcknowledgement"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      acknowledgedAt: Date
    }, ExtArgs["result"]["urgentProjectAcknowledgement"]>
    composites: {}
  }

  type UrgentProjectAcknowledgementGetPayload<S extends boolean | null | undefined | UrgentProjectAcknowledgementDefaultArgs> = $Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload, S>

  type UrgentProjectAcknowledgementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UrgentProjectAcknowledgementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UrgentProjectAcknowledgementCountAggregateInputType | true
    }

  export interface UrgentProjectAcknowledgementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UrgentProjectAcknowledgement'], meta: { name: 'UrgentProjectAcknowledgement' } }
    /**
     * Find zero or one UrgentProjectAcknowledgement that matches the filter.
     * @param {UrgentProjectAcknowledgementFindUniqueArgs} args - Arguments to find a UrgentProjectAcknowledgement
     * @example
     * // Get one UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UrgentProjectAcknowledgementFindUniqueArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementFindUniqueArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UrgentProjectAcknowledgement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UrgentProjectAcknowledgementFindUniqueOrThrowArgs} args - Arguments to find a UrgentProjectAcknowledgement
     * @example
     * // Get one UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UrgentProjectAcknowledgementFindUniqueOrThrowArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UrgentProjectAcknowledgement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementFindFirstArgs} args - Arguments to find a UrgentProjectAcknowledgement
     * @example
     * // Get one UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UrgentProjectAcknowledgementFindFirstArgs>(args?: SelectSubset<T, UrgentProjectAcknowledgementFindFirstArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UrgentProjectAcknowledgement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementFindFirstOrThrowArgs} args - Arguments to find a UrgentProjectAcknowledgement
     * @example
     * // Get one UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UrgentProjectAcknowledgementFindFirstOrThrowArgs>(args?: SelectSubset<T, UrgentProjectAcknowledgementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UrgentProjectAcknowledgements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UrgentProjectAcknowledgements
     * const urgentProjectAcknowledgements = await prisma.urgentProjectAcknowledgement.findMany()
     * 
     * // Get first 10 UrgentProjectAcknowledgements
     * const urgentProjectAcknowledgements = await prisma.urgentProjectAcknowledgement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const urgentProjectAcknowledgementWithIdOnly = await prisma.urgentProjectAcknowledgement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UrgentProjectAcknowledgementFindManyArgs>(args?: SelectSubset<T, UrgentProjectAcknowledgementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UrgentProjectAcknowledgement.
     * @param {UrgentProjectAcknowledgementCreateArgs} args - Arguments to create a UrgentProjectAcknowledgement.
     * @example
     * // Create one UrgentProjectAcknowledgement
     * const UrgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.create({
     *   data: {
     *     // ... data to create a UrgentProjectAcknowledgement
     *   }
     * })
     * 
     */
    create<T extends UrgentProjectAcknowledgementCreateArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementCreateArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UrgentProjectAcknowledgements.
     * @param {UrgentProjectAcknowledgementCreateManyArgs} args - Arguments to create many UrgentProjectAcknowledgements.
     * @example
     * // Create many UrgentProjectAcknowledgements
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UrgentProjectAcknowledgementCreateManyArgs>(args?: SelectSubset<T, UrgentProjectAcknowledgementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UrgentProjectAcknowledgement.
     * @param {UrgentProjectAcknowledgementDeleteArgs} args - Arguments to delete one UrgentProjectAcknowledgement.
     * @example
     * // Delete one UrgentProjectAcknowledgement
     * const UrgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.delete({
     *   where: {
     *     // ... filter to delete one UrgentProjectAcknowledgement
     *   }
     * })
     * 
     */
    delete<T extends UrgentProjectAcknowledgementDeleteArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementDeleteArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UrgentProjectAcknowledgement.
     * @param {UrgentProjectAcknowledgementUpdateArgs} args - Arguments to update one UrgentProjectAcknowledgement.
     * @example
     * // Update one UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UrgentProjectAcknowledgementUpdateArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementUpdateArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UrgentProjectAcknowledgements.
     * @param {UrgentProjectAcknowledgementDeleteManyArgs} args - Arguments to filter UrgentProjectAcknowledgements to delete.
     * @example
     * // Delete a few UrgentProjectAcknowledgements
     * const { count } = await prisma.urgentProjectAcknowledgement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UrgentProjectAcknowledgementDeleteManyArgs>(args?: SelectSubset<T, UrgentProjectAcknowledgementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UrgentProjectAcknowledgements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UrgentProjectAcknowledgements
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UrgentProjectAcknowledgementUpdateManyArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UrgentProjectAcknowledgement.
     * @param {UrgentProjectAcknowledgementUpsertArgs} args - Arguments to update or create a UrgentProjectAcknowledgement.
     * @example
     * // Update or create a UrgentProjectAcknowledgement
     * const urgentProjectAcknowledgement = await prisma.urgentProjectAcknowledgement.upsert({
     *   create: {
     *     // ... data to create a UrgentProjectAcknowledgement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UrgentProjectAcknowledgement we want to update
     *   }
     * })
     */
    upsert<T extends UrgentProjectAcknowledgementUpsertArgs>(args: SelectSubset<T, UrgentProjectAcknowledgementUpsertArgs<ExtArgs>>): Prisma__UrgentProjectAcknowledgementClient<$Result.GetResult<Prisma.$UrgentProjectAcknowledgementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UrgentProjectAcknowledgements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementCountArgs} args - Arguments to filter UrgentProjectAcknowledgements to count.
     * @example
     * // Count the number of UrgentProjectAcknowledgements
     * const count = await prisma.urgentProjectAcknowledgement.count({
     *   where: {
     *     // ... the filter for the UrgentProjectAcknowledgements we want to count
     *   }
     * })
    **/
    count<T extends UrgentProjectAcknowledgementCountArgs>(
      args?: Subset<T, UrgentProjectAcknowledgementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UrgentProjectAcknowledgementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UrgentProjectAcknowledgement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UrgentProjectAcknowledgementAggregateArgs>(args: Subset<T, UrgentProjectAcknowledgementAggregateArgs>): Prisma.PrismaPromise<GetUrgentProjectAcknowledgementAggregateType<T>>

    /**
     * Group by UrgentProjectAcknowledgement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UrgentProjectAcknowledgementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UrgentProjectAcknowledgementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UrgentProjectAcknowledgementGroupByArgs['orderBy'] }
        : { orderBy?: UrgentProjectAcknowledgementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UrgentProjectAcknowledgementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUrgentProjectAcknowledgementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UrgentProjectAcknowledgement model
   */
  readonly fields: UrgentProjectAcknowledgementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UrgentProjectAcknowledgement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UrgentProjectAcknowledgementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UrgentProjectAcknowledgement model
   */ 
  interface UrgentProjectAcknowledgementFieldRefs {
    readonly id: FieldRef<"UrgentProjectAcknowledgement", 'Int'>
    readonly projectId: FieldRef<"UrgentProjectAcknowledgement", 'Int'>
    readonly userId: FieldRef<"UrgentProjectAcknowledgement", 'Int'>
    readonly acknowledgedAt: FieldRef<"UrgentProjectAcknowledgement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UrgentProjectAcknowledgement findUnique
   */
  export type UrgentProjectAcknowledgementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter, which UrgentProjectAcknowledgement to fetch.
     */
    where: UrgentProjectAcknowledgementWhereUniqueInput
  }

  /**
   * UrgentProjectAcknowledgement findUniqueOrThrow
   */
  export type UrgentProjectAcknowledgementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter, which UrgentProjectAcknowledgement to fetch.
     */
    where: UrgentProjectAcknowledgementWhereUniqueInput
  }

  /**
   * UrgentProjectAcknowledgement findFirst
   */
  export type UrgentProjectAcknowledgementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter, which UrgentProjectAcknowledgement to fetch.
     */
    where?: UrgentProjectAcknowledgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UrgentProjectAcknowledgements to fetch.
     */
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UrgentProjectAcknowledgements.
     */
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UrgentProjectAcknowledgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UrgentProjectAcknowledgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UrgentProjectAcknowledgements.
     */
    distinct?: UrgentProjectAcknowledgementScalarFieldEnum | UrgentProjectAcknowledgementScalarFieldEnum[]
  }

  /**
   * UrgentProjectAcknowledgement findFirstOrThrow
   */
  export type UrgentProjectAcknowledgementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter, which UrgentProjectAcknowledgement to fetch.
     */
    where?: UrgentProjectAcknowledgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UrgentProjectAcknowledgements to fetch.
     */
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UrgentProjectAcknowledgements.
     */
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UrgentProjectAcknowledgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UrgentProjectAcknowledgements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UrgentProjectAcknowledgements.
     */
    distinct?: UrgentProjectAcknowledgementScalarFieldEnum | UrgentProjectAcknowledgementScalarFieldEnum[]
  }

  /**
   * UrgentProjectAcknowledgement findMany
   */
  export type UrgentProjectAcknowledgementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter, which UrgentProjectAcknowledgements to fetch.
     */
    where?: UrgentProjectAcknowledgementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UrgentProjectAcknowledgements to fetch.
     */
    orderBy?: UrgentProjectAcknowledgementOrderByWithRelationInput | UrgentProjectAcknowledgementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UrgentProjectAcknowledgements.
     */
    cursor?: UrgentProjectAcknowledgementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UrgentProjectAcknowledgements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UrgentProjectAcknowledgements.
     */
    skip?: number
    distinct?: UrgentProjectAcknowledgementScalarFieldEnum | UrgentProjectAcknowledgementScalarFieldEnum[]
  }

  /**
   * UrgentProjectAcknowledgement create
   */
  export type UrgentProjectAcknowledgementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * The data needed to create a UrgentProjectAcknowledgement.
     */
    data: XOR<UrgentProjectAcknowledgementCreateInput, UrgentProjectAcknowledgementUncheckedCreateInput>
  }

  /**
   * UrgentProjectAcknowledgement createMany
   */
  export type UrgentProjectAcknowledgementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UrgentProjectAcknowledgements.
     */
    data: UrgentProjectAcknowledgementCreateManyInput | UrgentProjectAcknowledgementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UrgentProjectAcknowledgement update
   */
  export type UrgentProjectAcknowledgementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * The data needed to update a UrgentProjectAcknowledgement.
     */
    data: XOR<UrgentProjectAcknowledgementUpdateInput, UrgentProjectAcknowledgementUncheckedUpdateInput>
    /**
     * Choose, which UrgentProjectAcknowledgement to update.
     */
    where: UrgentProjectAcknowledgementWhereUniqueInput
  }

  /**
   * UrgentProjectAcknowledgement updateMany
   */
  export type UrgentProjectAcknowledgementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UrgentProjectAcknowledgements.
     */
    data: XOR<UrgentProjectAcknowledgementUpdateManyMutationInput, UrgentProjectAcknowledgementUncheckedUpdateManyInput>
    /**
     * Filter which UrgentProjectAcknowledgements to update
     */
    where?: UrgentProjectAcknowledgementWhereInput
  }

  /**
   * UrgentProjectAcknowledgement upsert
   */
  export type UrgentProjectAcknowledgementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * The filter to search for the UrgentProjectAcknowledgement to update in case it exists.
     */
    where: UrgentProjectAcknowledgementWhereUniqueInput
    /**
     * In case the UrgentProjectAcknowledgement found by the `where` argument doesn't exist, create a new UrgentProjectAcknowledgement with this data.
     */
    create: XOR<UrgentProjectAcknowledgementCreateInput, UrgentProjectAcknowledgementUncheckedCreateInput>
    /**
     * In case the UrgentProjectAcknowledgement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UrgentProjectAcknowledgementUpdateInput, UrgentProjectAcknowledgementUncheckedUpdateInput>
  }

  /**
   * UrgentProjectAcknowledgement delete
   */
  export type UrgentProjectAcknowledgementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
    /**
     * Filter which UrgentProjectAcknowledgement to delete.
     */
    where: UrgentProjectAcknowledgementWhereUniqueInput
  }

  /**
   * UrgentProjectAcknowledgement deleteMany
   */
  export type UrgentProjectAcknowledgementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UrgentProjectAcknowledgements to delete
     */
    where?: UrgentProjectAcknowledgementWhereInput
  }

  /**
   * UrgentProjectAcknowledgement without action
   */
  export type UrgentProjectAcknowledgementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UrgentProjectAcknowledgement
     */
    select?: UrgentProjectAcknowledgementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UrgentProjectAcknowledgementInclude<ExtArgs> | null
  }


  /**
   * Model ProjectNotificationPreference
   */

  export type AggregateProjectNotificationPreference = {
    _count: ProjectNotificationPreferenceCountAggregateOutputType | null
    _avg: ProjectNotificationPreferenceAvgAggregateOutputType | null
    _sum: ProjectNotificationPreferenceSumAggregateOutputType | null
    _min: ProjectNotificationPreferenceMinAggregateOutputType | null
    _max: ProjectNotificationPreferenceMaxAggregateOutputType | null
  }

  export type ProjectNotificationPreferenceAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectNotificationPreferenceSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
  }

  export type ProjectNotificationPreferenceMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    soundEnabled: boolean | null
    taskNotifications: boolean | null
    dependencyNotifications: boolean | null
    todayTaskNotifications: boolean | null
    projectAdminNotifications: boolean | null
    updatedAt: Date | null
  }

  export type ProjectNotificationPreferenceMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    userId: number | null
    soundEnabled: boolean | null
    taskNotifications: boolean | null
    dependencyNotifications: boolean | null
    todayTaskNotifications: boolean | null
    projectAdminNotifications: boolean | null
    updatedAt: Date | null
  }

  export type ProjectNotificationPreferenceCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    soundEnabled: number
    taskNotifications: number
    dependencyNotifications: number
    todayTaskNotifications: number
    projectAdminNotifications: number
    updatedAt: number
    _all: number
  }


  export type ProjectNotificationPreferenceAvgAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectNotificationPreferenceSumAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
  }

  export type ProjectNotificationPreferenceMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    soundEnabled?: true
    taskNotifications?: true
    dependencyNotifications?: true
    todayTaskNotifications?: true
    projectAdminNotifications?: true
    updatedAt?: true
  }

  export type ProjectNotificationPreferenceMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    soundEnabled?: true
    taskNotifications?: true
    dependencyNotifications?: true
    todayTaskNotifications?: true
    projectAdminNotifications?: true
    updatedAt?: true
  }

  export type ProjectNotificationPreferenceCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    soundEnabled?: true
    taskNotifications?: true
    dependencyNotifications?: true
    todayTaskNotifications?: true
    projectAdminNotifications?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectNotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotificationPreference to aggregate.
     */
    where?: ProjectNotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotificationPreferences to fetch.
     */
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectNotificationPreferences
    **/
    _count?: true | ProjectNotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectNotificationPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectNotificationPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectNotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectNotificationPreferenceMaxAggregateInputType
  }

  export type GetProjectNotificationPreferenceAggregateType<T extends ProjectNotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectNotificationPreference[P]>
      : GetScalarType<T[P], AggregateProjectNotificationPreference[P]>
  }




  export type ProjectNotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectNotificationPreferenceWhereInput
    orderBy?: ProjectNotificationPreferenceOrderByWithAggregationInput | ProjectNotificationPreferenceOrderByWithAggregationInput[]
    by: ProjectNotificationPreferenceScalarFieldEnum[] | ProjectNotificationPreferenceScalarFieldEnum
    having?: ProjectNotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectNotificationPreferenceCountAggregateInputType | true
    _avg?: ProjectNotificationPreferenceAvgAggregateInputType
    _sum?: ProjectNotificationPreferenceSumAggregateInputType
    _min?: ProjectNotificationPreferenceMinAggregateInputType
    _max?: ProjectNotificationPreferenceMaxAggregateInputType
  }

  export type ProjectNotificationPreferenceGroupByOutputType = {
    id: number
    projectId: number
    userId: number
    soundEnabled: boolean
    taskNotifications: boolean
    dependencyNotifications: boolean
    todayTaskNotifications: boolean
    projectAdminNotifications: boolean
    updatedAt: Date
    _count: ProjectNotificationPreferenceCountAggregateOutputType | null
    _avg: ProjectNotificationPreferenceAvgAggregateOutputType | null
    _sum: ProjectNotificationPreferenceSumAggregateOutputType | null
    _min: ProjectNotificationPreferenceMinAggregateOutputType | null
    _max: ProjectNotificationPreferenceMaxAggregateOutputType | null
  }

  type GetProjectNotificationPreferenceGroupByPayload<T extends ProjectNotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectNotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectNotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectNotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectNotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type ProjectNotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectNotificationPreference"]>


  export type ProjectNotificationPreferenceSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: boolean
  }

  export type ProjectNotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectNotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectNotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      userId: number
      soundEnabled: boolean
      taskNotifications: boolean
      dependencyNotifications: boolean
      todayTaskNotifications: boolean
      projectAdminNotifications: boolean
      updatedAt: Date
    }, ExtArgs["result"]["projectNotificationPreference"]>
    composites: {}
  }

  type ProjectNotificationPreferenceGetPayload<S extends boolean | null | undefined | ProjectNotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$ProjectNotificationPreferencePayload, S>

  type ProjectNotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectNotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectNotificationPreferenceCountAggregateInputType | true
    }

  export interface ProjectNotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectNotificationPreference'], meta: { name: 'ProjectNotificationPreference' } }
    /**
     * Find zero or one ProjectNotificationPreference that matches the filter.
     * @param {ProjectNotificationPreferenceFindUniqueArgs} args - Arguments to find a ProjectNotificationPreference
     * @example
     * // Get one ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectNotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, ProjectNotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectNotificationPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectNotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a ProjectNotificationPreference
     * @example
     * // Get one ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectNotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectNotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectNotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceFindFirstArgs} args - Arguments to find a ProjectNotificationPreference
     * @example
     * // Get one ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectNotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, ProjectNotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectNotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a ProjectNotificationPreference
     * @example
     * // Get one ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectNotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectNotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectNotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectNotificationPreferences
     * const projectNotificationPreferences = await prisma.projectNotificationPreference.findMany()
     * 
     * // Get first 10 ProjectNotificationPreferences
     * const projectNotificationPreferences = await prisma.projectNotificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectNotificationPreferenceWithIdOnly = await prisma.projectNotificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectNotificationPreferenceFindManyArgs>(args?: SelectSubset<T, ProjectNotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectNotificationPreference.
     * @param {ProjectNotificationPreferenceCreateArgs} args - Arguments to create a ProjectNotificationPreference.
     * @example
     * // Create one ProjectNotificationPreference
     * const ProjectNotificationPreference = await prisma.projectNotificationPreference.create({
     *   data: {
     *     // ... data to create a ProjectNotificationPreference
     *   }
     * })
     * 
     */
    create<T extends ProjectNotificationPreferenceCreateArgs>(args: SelectSubset<T, ProjectNotificationPreferenceCreateArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectNotificationPreferences.
     * @param {ProjectNotificationPreferenceCreateManyArgs} args - Arguments to create many ProjectNotificationPreferences.
     * @example
     * // Create many ProjectNotificationPreferences
     * const projectNotificationPreference = await prisma.projectNotificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectNotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, ProjectNotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectNotificationPreference.
     * @param {ProjectNotificationPreferenceDeleteArgs} args - Arguments to delete one ProjectNotificationPreference.
     * @example
     * // Delete one ProjectNotificationPreference
     * const ProjectNotificationPreference = await prisma.projectNotificationPreference.delete({
     *   where: {
     *     // ... filter to delete one ProjectNotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends ProjectNotificationPreferenceDeleteArgs>(args: SelectSubset<T, ProjectNotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectNotificationPreference.
     * @param {ProjectNotificationPreferenceUpdateArgs} args - Arguments to update one ProjectNotificationPreference.
     * @example
     * // Update one ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectNotificationPreferenceUpdateArgs>(args: SelectSubset<T, ProjectNotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectNotificationPreferences.
     * @param {ProjectNotificationPreferenceDeleteManyArgs} args - Arguments to filter ProjectNotificationPreferences to delete.
     * @example
     * // Delete a few ProjectNotificationPreferences
     * const { count } = await prisma.projectNotificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectNotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, ProjectNotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectNotificationPreferences
     * const projectNotificationPreference = await prisma.projectNotificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectNotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, ProjectNotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectNotificationPreference.
     * @param {ProjectNotificationPreferenceUpsertArgs} args - Arguments to update or create a ProjectNotificationPreference.
     * @example
     * // Update or create a ProjectNotificationPreference
     * const projectNotificationPreference = await prisma.projectNotificationPreference.upsert({
     *   create: {
     *     // ... data to create a ProjectNotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectNotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends ProjectNotificationPreferenceUpsertArgs>(args: SelectSubset<T, ProjectNotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__ProjectNotificationPreferenceClient<$Result.GetResult<Prisma.$ProjectNotificationPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceCountArgs} args - Arguments to filter ProjectNotificationPreferences to count.
     * @example
     * // Count the number of ProjectNotificationPreferences
     * const count = await prisma.projectNotificationPreference.count({
     *   where: {
     *     // ... the filter for the ProjectNotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends ProjectNotificationPreferenceCountArgs>(
      args?: Subset<T, ProjectNotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectNotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectNotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectNotificationPreferenceAggregateArgs>(args: Subset<T, ProjectNotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetProjectNotificationPreferenceAggregateType<T>>

    /**
     * Group by ProjectNotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectNotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectNotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectNotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: ProjectNotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectNotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectNotificationPreference model
   */
  readonly fields: ProjectNotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectNotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectNotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectNotificationPreference model
   */ 
  interface ProjectNotificationPreferenceFieldRefs {
    readonly id: FieldRef<"ProjectNotificationPreference", 'Int'>
    readonly projectId: FieldRef<"ProjectNotificationPreference", 'Int'>
    readonly userId: FieldRef<"ProjectNotificationPreference", 'Int'>
    readonly soundEnabled: FieldRef<"ProjectNotificationPreference", 'Boolean'>
    readonly taskNotifications: FieldRef<"ProjectNotificationPreference", 'Boolean'>
    readonly dependencyNotifications: FieldRef<"ProjectNotificationPreference", 'Boolean'>
    readonly todayTaskNotifications: FieldRef<"ProjectNotificationPreference", 'Boolean'>
    readonly projectAdminNotifications: FieldRef<"ProjectNotificationPreference", 'Boolean'>
    readonly updatedAt: FieldRef<"ProjectNotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectNotificationPreference findUnique
   */
  export type ProjectNotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotificationPreference to fetch.
     */
    where: ProjectNotificationPreferenceWhereUniqueInput
  }

  /**
   * ProjectNotificationPreference findUniqueOrThrow
   */
  export type ProjectNotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotificationPreference to fetch.
     */
    where: ProjectNotificationPreferenceWhereUniqueInput
  }

  /**
   * ProjectNotificationPreference findFirst
   */
  export type ProjectNotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotificationPreference to fetch.
     */
    where?: ProjectNotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotificationPreferences to fetch.
     */
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotificationPreferences.
     */
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotificationPreferences.
     */
    distinct?: ProjectNotificationPreferenceScalarFieldEnum | ProjectNotificationPreferenceScalarFieldEnum[]
  }

  /**
   * ProjectNotificationPreference findFirstOrThrow
   */
  export type ProjectNotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotificationPreference to fetch.
     */
    where?: ProjectNotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotificationPreferences to fetch.
     */
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectNotificationPreferences.
     */
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectNotificationPreferences.
     */
    distinct?: ProjectNotificationPreferenceScalarFieldEnum | ProjectNotificationPreferenceScalarFieldEnum[]
  }

  /**
   * ProjectNotificationPreference findMany
   */
  export type ProjectNotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectNotificationPreferences to fetch.
     */
    where?: ProjectNotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectNotificationPreferences to fetch.
     */
    orderBy?: ProjectNotificationPreferenceOrderByWithRelationInput | ProjectNotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectNotificationPreferences.
     */
    cursor?: ProjectNotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectNotificationPreferences.
     */
    skip?: number
    distinct?: ProjectNotificationPreferenceScalarFieldEnum | ProjectNotificationPreferenceScalarFieldEnum[]
  }

  /**
   * ProjectNotificationPreference create
   */
  export type ProjectNotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectNotificationPreference.
     */
    data: XOR<ProjectNotificationPreferenceCreateInput, ProjectNotificationPreferenceUncheckedCreateInput>
  }

  /**
   * ProjectNotificationPreference createMany
   */
  export type ProjectNotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectNotificationPreferences.
     */
    data: ProjectNotificationPreferenceCreateManyInput | ProjectNotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectNotificationPreference update
   */
  export type ProjectNotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectNotificationPreference.
     */
    data: XOR<ProjectNotificationPreferenceUpdateInput, ProjectNotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which ProjectNotificationPreference to update.
     */
    where: ProjectNotificationPreferenceWhereUniqueInput
  }

  /**
   * ProjectNotificationPreference updateMany
   */
  export type ProjectNotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectNotificationPreferences.
     */
    data: XOR<ProjectNotificationPreferenceUpdateManyMutationInput, ProjectNotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which ProjectNotificationPreferences to update
     */
    where?: ProjectNotificationPreferenceWhereInput
  }

  /**
   * ProjectNotificationPreference upsert
   */
  export type ProjectNotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectNotificationPreference to update in case it exists.
     */
    where: ProjectNotificationPreferenceWhereUniqueInput
    /**
     * In case the ProjectNotificationPreference found by the `where` argument doesn't exist, create a new ProjectNotificationPreference with this data.
     */
    create: XOR<ProjectNotificationPreferenceCreateInput, ProjectNotificationPreferenceUncheckedCreateInput>
    /**
     * In case the ProjectNotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectNotificationPreferenceUpdateInput, ProjectNotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * ProjectNotificationPreference delete
   */
  export type ProjectNotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which ProjectNotificationPreference to delete.
     */
    where: ProjectNotificationPreferenceWhereUniqueInput
  }

  /**
   * ProjectNotificationPreference deleteMany
   */
  export type ProjectNotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectNotificationPreferences to delete
     */
    where?: ProjectNotificationPreferenceWhereInput
  }

  /**
   * ProjectNotificationPreference without action
   */
  export type ProjectNotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectNotificationPreference
     */
    select?: ProjectNotificationPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectNotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    userId: number | null
    role: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberSumAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
  }

  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: number
    teamId: number
    userId: number
    role: string
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>


  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      userId: number
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'Int'>
    readonly teamId: FieldRef<"TeamMember", 'Int'>
    readonly userId: FieldRef<"TeamMember", 'Int'>
    readonly role: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTeam
   */

  export type AggregateProjectTeam = {
    _count: ProjectTeamCountAggregateOutputType | null
    _avg: ProjectTeamAvgAggregateOutputType | null
    _sum: ProjectTeamSumAggregateOutputType | null
    _min: ProjectTeamMinAggregateOutputType | null
    _max: ProjectTeamMaxAggregateOutputType | null
  }

  export type ProjectTeamAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    teamId: number | null
  }

  export type ProjectTeamSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    teamId: number | null
  }

  export type ProjectTeamMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    teamId: number | null
    assignedAt: Date | null
  }

  export type ProjectTeamMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    teamId: number | null
    assignedAt: Date | null
  }

  export type ProjectTeamCountAggregateOutputType = {
    id: number
    projectId: number
    teamId: number
    assignedAt: number
    _all: number
  }


  export type ProjectTeamAvgAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
  }

  export type ProjectTeamSumAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
  }

  export type ProjectTeamMinAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    assignedAt?: true
  }

  export type ProjectTeamMaxAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    assignedAt?: true
  }

  export type ProjectTeamCountAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    assignedAt?: true
    _all?: true
  }

  export type ProjectTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTeam to aggregate.
     */
    where?: ProjectTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeams to fetch.
     */
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTeams
    **/
    _count?: true | ProjectTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTeamMaxAggregateInputType
  }

  export type GetProjectTeamAggregateType<T extends ProjectTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTeam[P]>
      : GetScalarType<T[P], AggregateProjectTeam[P]>
  }




  export type ProjectTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTeamWhereInput
    orderBy?: ProjectTeamOrderByWithAggregationInput | ProjectTeamOrderByWithAggregationInput[]
    by: ProjectTeamScalarFieldEnum[] | ProjectTeamScalarFieldEnum
    having?: ProjectTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTeamCountAggregateInputType | true
    _avg?: ProjectTeamAvgAggregateInputType
    _sum?: ProjectTeamSumAggregateInputType
    _min?: ProjectTeamMinAggregateInputType
    _max?: ProjectTeamMaxAggregateInputType
  }

  export type ProjectTeamGroupByOutputType = {
    id: number
    projectId: number
    teamId: number
    assignedAt: Date
    _count: ProjectTeamCountAggregateOutputType | null
    _avg: ProjectTeamAvgAggregateOutputType | null
    _sum: ProjectTeamSumAggregateOutputType | null
    _min: ProjectTeamMinAggregateOutputType | null
    _max: ProjectTeamMaxAggregateOutputType | null
  }

  type GetProjectTeamGroupByPayload<T extends ProjectTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTeamGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTeamGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    assignedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTeam"]>


  export type ProjectTeamSelectScalar = {
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    assignedAt?: boolean
  }

  export type ProjectTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $ProjectTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTeam"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      teamId: number
      assignedAt: Date
    }, ExtArgs["result"]["projectTeam"]>
    composites: {}
  }

  type ProjectTeamGetPayload<S extends boolean | null | undefined | ProjectTeamDefaultArgs> = $Result.GetResult<Prisma.$ProjectTeamPayload, S>

  type ProjectTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectTeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectTeamCountAggregateInputType | true
    }

  export interface ProjectTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTeam'], meta: { name: 'ProjectTeam' } }
    /**
     * Find zero or one ProjectTeam that matches the filter.
     * @param {ProjectTeamFindUniqueArgs} args - Arguments to find a ProjectTeam
     * @example
     * // Get one ProjectTeam
     * const projectTeam = await prisma.projectTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTeamFindUniqueArgs>(args: SelectSubset<T, ProjectTeamFindUniqueArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectTeam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectTeamFindUniqueOrThrowArgs} args - Arguments to find a ProjectTeam
     * @example
     * // Get one ProjectTeam
     * const projectTeam = await prisma.projectTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamFindFirstArgs} args - Arguments to find a ProjectTeam
     * @example
     * // Get one ProjectTeam
     * const projectTeam = await prisma.projectTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTeamFindFirstArgs>(args?: SelectSubset<T, ProjectTeamFindFirstArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamFindFirstOrThrowArgs} args - Arguments to find a ProjectTeam
     * @example
     * // Get one ProjectTeam
     * const projectTeam = await prisma.projectTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTeams
     * const projectTeams = await prisma.projectTeam.findMany()
     * 
     * // Get first 10 ProjectTeams
     * const projectTeams = await prisma.projectTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTeamWithIdOnly = await prisma.projectTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTeamFindManyArgs>(args?: SelectSubset<T, ProjectTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectTeam.
     * @param {ProjectTeamCreateArgs} args - Arguments to create a ProjectTeam.
     * @example
     * // Create one ProjectTeam
     * const ProjectTeam = await prisma.projectTeam.create({
     *   data: {
     *     // ... data to create a ProjectTeam
     *   }
     * })
     * 
     */
    create<T extends ProjectTeamCreateArgs>(args: SelectSubset<T, ProjectTeamCreateArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectTeams.
     * @param {ProjectTeamCreateManyArgs} args - Arguments to create many ProjectTeams.
     * @example
     * // Create many ProjectTeams
     * const projectTeam = await prisma.projectTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTeamCreateManyArgs>(args?: SelectSubset<T, ProjectTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTeam.
     * @param {ProjectTeamDeleteArgs} args - Arguments to delete one ProjectTeam.
     * @example
     * // Delete one ProjectTeam
     * const ProjectTeam = await prisma.projectTeam.delete({
     *   where: {
     *     // ... filter to delete one ProjectTeam
     *   }
     * })
     * 
     */
    delete<T extends ProjectTeamDeleteArgs>(args: SelectSubset<T, ProjectTeamDeleteArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectTeam.
     * @param {ProjectTeamUpdateArgs} args - Arguments to update one ProjectTeam.
     * @example
     * // Update one ProjectTeam
     * const projectTeam = await prisma.projectTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTeamUpdateArgs>(args: SelectSubset<T, ProjectTeamUpdateArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectTeams.
     * @param {ProjectTeamDeleteManyArgs} args - Arguments to filter ProjectTeams to delete.
     * @example
     * // Delete a few ProjectTeams
     * const { count } = await prisma.projectTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTeamDeleteManyArgs>(args?: SelectSubset<T, ProjectTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTeams
     * const projectTeam = await prisma.projectTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTeamUpdateManyArgs>(args: SelectSubset<T, ProjectTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTeam.
     * @param {ProjectTeamUpsertArgs} args - Arguments to update or create a ProjectTeam.
     * @example
     * // Update or create a ProjectTeam
     * const projectTeam = await prisma.projectTeam.upsert({
     *   create: {
     *     // ... data to create a ProjectTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTeam we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTeamUpsertArgs>(args: SelectSubset<T, ProjectTeamUpsertArgs<ExtArgs>>): Prisma__ProjectTeamClient<$Result.GetResult<Prisma.$ProjectTeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamCountArgs} args - Arguments to filter ProjectTeams to count.
     * @example
     * // Count the number of ProjectTeams
     * const count = await prisma.projectTeam.count({
     *   where: {
     *     // ... the filter for the ProjectTeams we want to count
     *   }
     * })
    **/
    count<T extends ProjectTeamCountArgs>(
      args?: Subset<T, ProjectTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTeamAggregateArgs>(args: Subset<T, ProjectTeamAggregateArgs>): Prisma.PrismaPromise<GetProjectTeamAggregateType<T>>

    /**
     * Group by ProjectTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTeamGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTeam model
   */
  readonly fields: ProjectTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTeam model
   */ 
  interface ProjectTeamFieldRefs {
    readonly id: FieldRef<"ProjectTeam", 'Int'>
    readonly projectId: FieldRef<"ProjectTeam", 'Int'>
    readonly teamId: FieldRef<"ProjectTeam", 'Int'>
    readonly assignedAt: FieldRef<"ProjectTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTeam findUnique
   */
  export type ProjectTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeam to fetch.
     */
    where: ProjectTeamWhereUniqueInput
  }

  /**
   * ProjectTeam findUniqueOrThrow
   */
  export type ProjectTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeam to fetch.
     */
    where: ProjectTeamWhereUniqueInput
  }

  /**
   * ProjectTeam findFirst
   */
  export type ProjectTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeam to fetch.
     */
    where?: ProjectTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeams to fetch.
     */
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTeams.
     */
    cursor?: ProjectTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTeams.
     */
    distinct?: ProjectTeamScalarFieldEnum | ProjectTeamScalarFieldEnum[]
  }

  /**
   * ProjectTeam findFirstOrThrow
   */
  export type ProjectTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeam to fetch.
     */
    where?: ProjectTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeams to fetch.
     */
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTeams.
     */
    cursor?: ProjectTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTeams.
     */
    distinct?: ProjectTeamScalarFieldEnum | ProjectTeamScalarFieldEnum[]
  }

  /**
   * ProjectTeam findMany
   */
  export type ProjectTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTeams to fetch.
     */
    where?: ProjectTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTeams to fetch.
     */
    orderBy?: ProjectTeamOrderByWithRelationInput | ProjectTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTeams.
     */
    cursor?: ProjectTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTeams.
     */
    skip?: number
    distinct?: ProjectTeamScalarFieldEnum | ProjectTeamScalarFieldEnum[]
  }

  /**
   * ProjectTeam create
   */
  export type ProjectTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTeam.
     */
    data: XOR<ProjectTeamCreateInput, ProjectTeamUncheckedCreateInput>
  }

  /**
   * ProjectTeam createMany
   */
  export type ProjectTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTeams.
     */
    data: ProjectTeamCreateManyInput | ProjectTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTeam update
   */
  export type ProjectTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTeam.
     */
    data: XOR<ProjectTeamUpdateInput, ProjectTeamUncheckedUpdateInput>
    /**
     * Choose, which ProjectTeam to update.
     */
    where: ProjectTeamWhereUniqueInput
  }

  /**
   * ProjectTeam updateMany
   */
  export type ProjectTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTeams.
     */
    data: XOR<ProjectTeamUpdateManyMutationInput, ProjectTeamUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTeams to update
     */
    where?: ProjectTeamWhereInput
  }

  /**
   * ProjectTeam upsert
   */
  export type ProjectTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTeam to update in case it exists.
     */
    where: ProjectTeamWhereUniqueInput
    /**
     * In case the ProjectTeam found by the `where` argument doesn't exist, create a new ProjectTeam with this data.
     */
    create: XOR<ProjectTeamCreateInput, ProjectTeamUncheckedCreateInput>
    /**
     * In case the ProjectTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTeamUpdateInput, ProjectTeamUncheckedUpdateInput>
  }

  /**
   * ProjectTeam delete
   */
  export type ProjectTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
    /**
     * Filter which ProjectTeam to delete.
     */
    where: ProjectTeamWhereUniqueInput
  }

  /**
   * ProjectTeam deleteMany
   */
  export type ProjectTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTeams to delete
     */
    where?: ProjectTeamWhereInput
  }

  /**
   * ProjectTeam without action
   */
  export type ProjectTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTeam
     */
    select?: ProjectTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTeamInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isSystemRole: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isSystemRole: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystemRole: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystemRole?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isSystemRole: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystemRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isSystemRole: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystemRole: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
    description: string | null
    module: string | null
    category: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
    description: string | null
    module: string | null
    category: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    module: number
    category: number
    createdAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    category?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    category?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    module?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    key: string
    name: string
    description: string | null
    module: string
    category: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    category?: boolean
    createdAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>


  export type PermissionSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      name: string
      description: string | null
      module: string
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly key: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    permissionId: number | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>


  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      permissionId: number
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    scopeId: number | null
    assignedBy: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    scopeId: number | null
    assignedBy: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    scopeType: string | null
    scopeId: number | null
    assignedAt: Date | null
    assignedBy: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    scopeType: string | null
    scopeId: number | null
    assignedAt: Date | null
    assignedBy: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    scopeType: number
    scopeId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    scopeId?: true
    assignedBy?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    scopeId?: true
    assignedBy?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    scopeType?: true
    scopeId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    scopeType?: true
    scopeId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    scopeType?: true
    scopeId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    scopeType: string | null
    scopeId: number | null
    assignedAt: Date
    assignedBy: number | null
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    scopeType?: boolean
    scopeId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assigner?: boolean | UserRole$assignerArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>


  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    scopeType?: boolean
    scopeId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    assigner?: boolean | UserRole$assignerArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
      assigner: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
      scopeType: string | null
      scopeId: number | null
      assignedAt: Date
      assignedBy: number | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assigner<T extends UserRole$assignerArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$assignerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'Int'>
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly scopeType: FieldRef<"UserRole", 'String'>
    readonly scopeId: FieldRef<"UserRole", 'Int'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole.assigner
   */
  export type UserRole$assignerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model ProjectType
   */

  export type AggregateProjectType = {
    _count: ProjectTypeCountAggregateOutputType | null
    _avg: ProjectTypeAvgAggregateOutputType | null
    _sum: ProjectTypeSumAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  export type ProjectTypeAvgAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type ProjectTypeSumAggregateOutputType = {
    id: number | null
    displayOrder: number | null
  }

  export type ProjectTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
    color: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    displayOrder: number | null
    color: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    displayOrder: number
    color: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectTypeAvgAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type ProjectTypeSumAggregateInputType = {
    id?: true
    displayOrder?: true
  }

  export type ProjectTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
    color?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
    color?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    displayOrder?: true
    color?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectType to aggregate.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTypes
    **/
    _count?: true | ProjectTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type GetProjectTypeAggregateType<T extends ProjectTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectType[P]>
      : GetScalarType<T[P], AggregateProjectType[P]>
  }




  export type ProjectTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTypeWhereInput
    orderBy?: ProjectTypeOrderByWithAggregationInput | ProjectTypeOrderByWithAggregationInput[]
    by: ProjectTypeScalarFieldEnum[] | ProjectTypeScalarFieldEnum
    having?: ProjectTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTypeCountAggregateInputType | true
    _avg?: ProjectTypeAvgAggregateInputType
    _sum?: ProjectTypeSumAggregateInputType
    _min?: ProjectTypeMinAggregateInputType
    _max?: ProjectTypeMaxAggregateInputType
  }

  export type ProjectTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    displayOrder: number
    color: string | null
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectTypeCountAggregateOutputType | null
    _avg: ProjectTypeAvgAggregateOutputType | null
    _sum: ProjectTypeSumAggregateOutputType | null
    _min: ProjectTypeMinAggregateOutputType | null
    _max: ProjectTypeMaxAggregateOutputType | null
  }

  type GetProjectTypeGroupByPayload<T extends ProjectTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | ProjectType$projectsArgs<ExtArgs>
    _count?: boolean | ProjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectType"]>


  export type ProjectTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    displayOrder?: boolean
    color?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectType$projectsArgs<ExtArgs>
    _count?: boolean | ProjectTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectType"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      displayOrder: number
      color: string | null
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectType"]>
    composites: {}
  }

  type ProjectTypeGetPayload<S extends boolean | null | undefined | ProjectTypeDefaultArgs> = $Result.GetResult<Prisma.$ProjectTypePayload, S>

  type ProjectTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectTypeCountAggregateInputType | true
    }

  export interface ProjectTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectType'], meta: { name: 'ProjectType' } }
    /**
     * Find zero or one ProjectType that matches the filter.
     * @param {ProjectTypeFindUniqueArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTypeFindUniqueArgs>(args: SelectSubset<T, ProjectTypeFindUniqueArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectTypeFindUniqueOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTypeFindFirstArgs>(args?: SelectSubset<T, ProjectTypeFindFirstArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindFirstOrThrowArgs} args - Arguments to find a ProjectType
     * @example
     * // Get one ProjectType
     * const projectType = await prisma.projectType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTypes
     * const projectTypes = await prisma.projectType.findMany()
     * 
     * // Get first 10 ProjectTypes
     * const projectTypes = await prisma.projectType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTypeWithIdOnly = await prisma.projectType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTypeFindManyArgs>(args?: SelectSubset<T, ProjectTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectType.
     * @param {ProjectTypeCreateArgs} args - Arguments to create a ProjectType.
     * @example
     * // Create one ProjectType
     * const ProjectType = await prisma.projectType.create({
     *   data: {
     *     // ... data to create a ProjectType
     *   }
     * })
     * 
     */
    create<T extends ProjectTypeCreateArgs>(args: SelectSubset<T, ProjectTypeCreateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectTypes.
     * @param {ProjectTypeCreateManyArgs} args - Arguments to create many ProjectTypes.
     * @example
     * // Create many ProjectTypes
     * const projectType = await prisma.projectType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTypeCreateManyArgs>(args?: SelectSubset<T, ProjectTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectType.
     * @param {ProjectTypeDeleteArgs} args - Arguments to delete one ProjectType.
     * @example
     * // Delete one ProjectType
     * const ProjectType = await prisma.projectType.delete({
     *   where: {
     *     // ... filter to delete one ProjectType
     *   }
     * })
     * 
     */
    delete<T extends ProjectTypeDeleteArgs>(args: SelectSubset<T, ProjectTypeDeleteArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectType.
     * @param {ProjectTypeUpdateArgs} args - Arguments to update one ProjectType.
     * @example
     * // Update one ProjectType
     * const projectType = await prisma.projectType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTypeUpdateArgs>(args: SelectSubset<T, ProjectTypeUpdateArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectTypes.
     * @param {ProjectTypeDeleteManyArgs} args - Arguments to filter ProjectTypes to delete.
     * @example
     * // Delete a few ProjectTypes
     * const { count } = await prisma.projectType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTypeDeleteManyArgs>(args?: SelectSubset<T, ProjectTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTypes
     * const projectType = await prisma.projectType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTypeUpdateManyArgs>(args: SelectSubset<T, ProjectTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectType.
     * @param {ProjectTypeUpsertArgs} args - Arguments to update or create a ProjectType.
     * @example
     * // Update or create a ProjectType
     * const projectType = await prisma.projectType.upsert({
     *   create: {
     *     // ... data to create a ProjectType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectType we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTypeUpsertArgs>(args: SelectSubset<T, ProjectTypeUpsertArgs<ExtArgs>>): Prisma__ProjectTypeClient<$Result.GetResult<Prisma.$ProjectTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeCountArgs} args - Arguments to filter ProjectTypes to count.
     * @example
     * // Count the number of ProjectTypes
     * const count = await prisma.projectType.count({
     *   where: {
     *     // ... the filter for the ProjectTypes we want to count
     *   }
     * })
    **/
    count<T extends ProjectTypeCountArgs>(
      args?: Subset<T, ProjectTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTypeAggregateArgs>(args: Subset<T, ProjectTypeAggregateArgs>): Prisma.PrismaPromise<GetProjectTypeAggregateType<T>>

    /**
     * Group by ProjectType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectType model
   */
  readonly fields: ProjectTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectType$projectsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectType$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectType model
   */ 
  interface ProjectTypeFieldRefs {
    readonly id: FieldRef<"ProjectType", 'Int'>
    readonly name: FieldRef<"ProjectType", 'String'>
    readonly description: FieldRef<"ProjectType", 'String'>
    readonly isActive: FieldRef<"ProjectType", 'Boolean'>
    readonly displayOrder: FieldRef<"ProjectType", 'Int'>
    readonly color: FieldRef<"ProjectType", 'String'>
    readonly icon: FieldRef<"ProjectType", 'String'>
    readonly createdAt: FieldRef<"ProjectType", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectType findUnique
   */
  export type ProjectTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findUniqueOrThrow
   */
  export type ProjectTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType findFirst
   */
  export type ProjectTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findFirstOrThrow
   */
  export type ProjectTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectType to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTypes.
     */
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType findMany
   */
  export type ProjectTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTypes to fetch.
     */
    where?: ProjectTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTypes to fetch.
     */
    orderBy?: ProjectTypeOrderByWithRelationInput | ProjectTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTypes.
     */
    cursor?: ProjectTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTypes.
     */
    skip?: number
    distinct?: ProjectTypeScalarFieldEnum | ProjectTypeScalarFieldEnum[]
  }

  /**
   * ProjectType create
   */
  export type ProjectTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectType.
     */
    data: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
  }

  /**
   * ProjectType createMany
   */
  export type ProjectTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTypes.
     */
    data: ProjectTypeCreateManyInput | ProjectTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectType update
   */
  export type ProjectTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectType.
     */
    data: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
    /**
     * Choose, which ProjectType to update.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType updateMany
   */
  export type ProjectTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTypes.
     */
    data: XOR<ProjectTypeUpdateManyMutationInput, ProjectTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTypes to update
     */
    where?: ProjectTypeWhereInput
  }

  /**
   * ProjectType upsert
   */
  export type ProjectTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectType to update in case it exists.
     */
    where: ProjectTypeWhereUniqueInput
    /**
     * In case the ProjectType found by the `where` argument doesn't exist, create a new ProjectType with this data.
     */
    create: XOR<ProjectTypeCreateInput, ProjectTypeUncheckedCreateInput>
    /**
     * In case the ProjectType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTypeUpdateInput, ProjectTypeUncheckedUpdateInput>
  }

  /**
   * ProjectType delete
   */
  export type ProjectTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
    /**
     * Filter which ProjectType to delete.
     */
    where: ProjectTypeWhereUniqueInput
  }

  /**
   * ProjectType deleteMany
   */
  export type ProjectTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTypes to delete
     */
    where?: ProjectTypeWhereInput
  }

  /**
   * ProjectType.projects
   */
  export type ProjectType$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * ProjectType without action
   */
  export type ProjectTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectType
     */
    select?: ProjectTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTypeInclude<ExtArgs> | null
  }


  /**
   * Model ProjectStatus
   */

  export type AggregateProjectStatus = {
    _count: ProjectStatusCountAggregateOutputType | null
    _avg: ProjectStatusAvgAggregateOutputType | null
    _sum: ProjectStatusSumAggregateOutputType | null
    _min: ProjectStatusMinAggregateOutputType | null
    _max: ProjectStatusMaxAggregateOutputType | null
  }

  export type ProjectStatusAvgAggregateOutputType = {
    id: number | null
    orderIndex: number | null
  }

  export type ProjectStatusSumAggregateOutputType = {
    id: number | null
    orderIndex: number | null
  }

  export type ProjectStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    isDefault: boolean | null
    isFinal: boolean | null
    isUrgent: boolean | null
    orderIndex: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    isDefault: boolean | null
    isFinal: boolean | null
    isUrgent: boolean | null
    orderIndex: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectStatusCountAggregateOutputType = {
    id: number
    name: number
    color: number
    isDefault: number
    isFinal: number
    isUrgent: number
    orderIndex: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectStatusAvgAggregateInputType = {
    id?: true
    orderIndex?: true
  }

  export type ProjectStatusSumAggregateInputType = {
    id?: true
    orderIndex?: true
  }

  export type ProjectStatusMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isUrgent?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isUrgent?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectStatusCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isUrgent?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatus to aggregate.
     */
    where?: ProjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStatuses
    **/
    _count?: true | ProjectStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatusMaxAggregateInputType
  }

  export type GetProjectStatusAggregateType<T extends ProjectStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStatus[P]>
      : GetScalarType<T[P], AggregateProjectStatus[P]>
  }




  export type ProjectStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatusWhereInput
    orderBy?: ProjectStatusOrderByWithAggregationInput | ProjectStatusOrderByWithAggregationInput[]
    by: ProjectStatusScalarFieldEnum[] | ProjectStatusScalarFieldEnum
    having?: ProjectStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatusCountAggregateInputType | true
    _avg?: ProjectStatusAvgAggregateInputType
    _sum?: ProjectStatusSumAggregateInputType
    _min?: ProjectStatusMinAggregateInputType
    _max?: ProjectStatusMaxAggregateInputType
  }

  export type ProjectStatusGroupByOutputType = {
    id: number
    name: string
    color: string
    isDefault: boolean
    isFinal: boolean
    isUrgent: boolean
    orderIndex: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProjectStatusCountAggregateOutputType | null
    _avg: ProjectStatusAvgAggregateOutputType | null
    _sum: ProjectStatusSumAggregateOutputType | null
    _min: ProjectStatusMinAggregateOutputType | null
    _max: ProjectStatusMaxAggregateOutputType | null
  }

  type GetProjectStatusGroupByPayload<T extends ProjectStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatusGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | ProjectStatus$projectsArgs<ExtArgs>
    _count?: boolean | ProjectStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectStatus"]>


  export type ProjectStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | ProjectStatus$projectsArgs<ExtArgs>
    _count?: boolean | ProjectStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStatus"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      isDefault: boolean
      isFinal: boolean
      isUrgent: boolean
      orderIndex: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectStatus"]>
    composites: {}
  }

  type ProjectStatusGetPayload<S extends boolean | null | undefined | ProjectStatusDefaultArgs> = $Result.GetResult<Prisma.$ProjectStatusPayload, S>

  type ProjectStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectStatusCountAggregateInputType | true
    }

  export interface ProjectStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStatus'], meta: { name: 'ProjectStatus' } }
    /**
     * Find zero or one ProjectStatus that matches the filter.
     * @param {ProjectStatusFindUniqueArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatusFindUniqueArgs>(args: SelectSubset<T, ProjectStatusFindUniqueArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectStatusFindUniqueOrThrowArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindFirstArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatusFindFirstArgs>(args?: SelectSubset<T, ProjectStatusFindFirstArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindFirstOrThrowArgs} args - Arguments to find a ProjectStatus
     * @example
     * // Get one ProjectStatus
     * const projectStatus = await prisma.projectStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStatuses
     * const projectStatuses = await prisma.projectStatus.findMany()
     * 
     * // Get first 10 ProjectStatuses
     * const projectStatuses = await prisma.projectStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatusWithIdOnly = await prisma.projectStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStatusFindManyArgs>(args?: SelectSubset<T, ProjectStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectStatus.
     * @param {ProjectStatusCreateArgs} args - Arguments to create a ProjectStatus.
     * @example
     * // Create one ProjectStatus
     * const ProjectStatus = await prisma.projectStatus.create({
     *   data: {
     *     // ... data to create a ProjectStatus
     *   }
     * })
     * 
     */
    create<T extends ProjectStatusCreateArgs>(args: SelectSubset<T, ProjectStatusCreateArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectStatuses.
     * @param {ProjectStatusCreateManyArgs} args - Arguments to create many ProjectStatuses.
     * @example
     * // Create many ProjectStatuses
     * const projectStatus = await prisma.projectStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStatusCreateManyArgs>(args?: SelectSubset<T, ProjectStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectStatus.
     * @param {ProjectStatusDeleteArgs} args - Arguments to delete one ProjectStatus.
     * @example
     * // Delete one ProjectStatus
     * const ProjectStatus = await prisma.projectStatus.delete({
     *   where: {
     *     // ... filter to delete one ProjectStatus
     *   }
     * })
     * 
     */
    delete<T extends ProjectStatusDeleteArgs>(args: SelectSubset<T, ProjectStatusDeleteArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectStatus.
     * @param {ProjectStatusUpdateArgs} args - Arguments to update one ProjectStatus.
     * @example
     * // Update one ProjectStatus
     * const projectStatus = await prisma.projectStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStatusUpdateArgs>(args: SelectSubset<T, ProjectStatusUpdateArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectStatuses.
     * @param {ProjectStatusDeleteManyArgs} args - Arguments to filter ProjectStatuses to delete.
     * @example
     * // Delete a few ProjectStatuses
     * const { count } = await prisma.projectStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStatusDeleteManyArgs>(args?: SelectSubset<T, ProjectStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStatuses
     * const projectStatus = await prisma.projectStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStatusUpdateManyArgs>(args: SelectSubset<T, ProjectStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectStatus.
     * @param {ProjectStatusUpsertArgs} args - Arguments to update or create a ProjectStatus.
     * @example
     * // Update or create a ProjectStatus
     * const projectStatus = await prisma.projectStatus.upsert({
     *   create: {
     *     // ... data to create a ProjectStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStatus we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatusUpsertArgs>(args: SelectSubset<T, ProjectStatusUpsertArgs<ExtArgs>>): Prisma__ProjectStatusClient<$Result.GetResult<Prisma.$ProjectStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusCountArgs} args - Arguments to filter ProjectStatuses to count.
     * @example
     * // Count the number of ProjectStatuses
     * const count = await prisma.projectStatus.count({
     *   where: {
     *     // ... the filter for the ProjectStatuses we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatusCountArgs>(
      args?: Subset<T, ProjectStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatusAggregateArgs>(args: Subset<T, ProjectStatusAggregateArgs>): Prisma.PrismaPromise<GetProjectStatusAggregateType<T>>

    /**
     * Group by ProjectStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatusGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStatus model
   */
  readonly fields: ProjectStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends ProjectStatus$projectsArgs<ExtArgs> = {}>(args?: Subset<T, ProjectStatus$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStatus model
   */ 
  interface ProjectStatusFieldRefs {
    readonly id: FieldRef<"ProjectStatus", 'Int'>
    readonly name: FieldRef<"ProjectStatus", 'String'>
    readonly color: FieldRef<"ProjectStatus", 'String'>
    readonly isDefault: FieldRef<"ProjectStatus", 'Boolean'>
    readonly isFinal: FieldRef<"ProjectStatus", 'Boolean'>
    readonly isUrgent: FieldRef<"ProjectStatus", 'Boolean'>
    readonly orderIndex: FieldRef<"ProjectStatus", 'Int'>
    readonly isActive: FieldRef<"ProjectStatus", 'Boolean'>
    readonly createdAt: FieldRef<"ProjectStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStatus findUnique
   */
  export type ProjectStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where: ProjectStatusWhereUniqueInput
  }

  /**
   * ProjectStatus findUniqueOrThrow
   */
  export type ProjectStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where: ProjectStatusWhereUniqueInput
  }

  /**
   * ProjectStatus findFirst
   */
  export type ProjectStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where?: ProjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatuses.
     */
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[]
  }

  /**
   * ProjectStatus findFirstOrThrow
   */
  export type ProjectStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatus to fetch.
     */
    where?: ProjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatuses.
     */
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[]
  }

  /**
   * ProjectStatus findMany
   */
  export type ProjectStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProjectStatuses to fetch.
     */
    where?: ProjectStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatuses to fetch.
     */
    orderBy?: ProjectStatusOrderByWithRelationInput | ProjectStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStatuses.
     */
    cursor?: ProjectStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatuses.
     */
    skip?: number
    distinct?: ProjectStatusScalarFieldEnum | ProjectStatusScalarFieldEnum[]
  }

  /**
   * ProjectStatus create
   */
  export type ProjectStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectStatus.
     */
    data: XOR<ProjectStatusCreateInput, ProjectStatusUncheckedCreateInput>
  }

  /**
   * ProjectStatus createMany
   */
  export type ProjectStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStatuses.
     */
    data: ProjectStatusCreateManyInput | ProjectStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectStatus update
   */
  export type ProjectStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectStatus.
     */
    data: XOR<ProjectStatusUpdateInput, ProjectStatusUncheckedUpdateInput>
    /**
     * Choose, which ProjectStatus to update.
     */
    where: ProjectStatusWhereUniqueInput
  }

  /**
   * ProjectStatus updateMany
   */
  export type ProjectStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStatuses.
     */
    data: XOR<ProjectStatusUpdateManyMutationInput, ProjectStatusUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStatuses to update
     */
    where?: ProjectStatusWhereInput
  }

  /**
   * ProjectStatus upsert
   */
  export type ProjectStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectStatus to update in case it exists.
     */
    where: ProjectStatusWhereUniqueInput
    /**
     * In case the ProjectStatus found by the `where` argument doesn't exist, create a new ProjectStatus with this data.
     */
    create: XOR<ProjectStatusCreateInput, ProjectStatusUncheckedCreateInput>
    /**
     * In case the ProjectStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatusUpdateInput, ProjectStatusUncheckedUpdateInput>
  }

  /**
   * ProjectStatus delete
   */
  export type ProjectStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
    /**
     * Filter which ProjectStatus to delete.
     */
    where: ProjectStatusWhereUniqueInput
  }

  /**
   * ProjectStatus deleteMany
   */
  export type ProjectStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatuses to delete
     */
    where?: ProjectStatusWhereInput
  }

  /**
   * ProjectStatus.projects
   */
  export type ProjectStatus$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * ProjectStatus without action
   */
  export type ProjectStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatus
     */
    select?: ProjectStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectStatusInclude<ExtArgs> | null
  }


  /**
   * Model TaskStatus
   */

  export type AggregateTaskStatus = {
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  export type TaskStatusAvgAggregateOutputType = {
    id: number | null
    orderIndex: number | null
  }

  export type TaskStatusSumAggregateOutputType = {
    id: number | null
    orderIndex: number | null
  }

  export type TaskStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    isDefault: boolean | null
    isFinal: boolean | null
    isBlocking: boolean | null
    orderIndex: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
    isDefault: boolean | null
    isFinal: boolean | null
    isBlocking: boolean | null
    orderIndex: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskStatusCountAggregateOutputType = {
    id: number
    name: number
    color: number
    isDefault: number
    isFinal: number
    isBlocking: number
    orderIndex: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskStatusAvgAggregateInputType = {
    id?: true
    orderIndex?: true
  }

  export type TaskStatusSumAggregateInputType = {
    id?: true
    orderIndex?: true
  }

  export type TaskStatusMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isBlocking?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskStatusMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isBlocking?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskStatusCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    isDefault?: true
    isFinal?: true
    isBlocking?: true
    orderIndex?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatus to aggregate.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskStatuses
    **/
    _count?: true | TaskStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskStatusMaxAggregateInputType
  }

  export type GetTaskStatusAggregateType<T extends TaskStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskStatus[P]>
      : GetScalarType<T[P], AggregateTaskStatus[P]>
  }




  export type TaskStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskStatusWhereInput
    orderBy?: TaskStatusOrderByWithAggregationInput | TaskStatusOrderByWithAggregationInput[]
    by: TaskStatusScalarFieldEnum[] | TaskStatusScalarFieldEnum
    having?: TaskStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskStatusCountAggregateInputType | true
    _avg?: TaskStatusAvgAggregateInputType
    _sum?: TaskStatusSumAggregateInputType
    _min?: TaskStatusMinAggregateInputType
    _max?: TaskStatusMaxAggregateInputType
  }

  export type TaskStatusGroupByOutputType = {
    id: number
    name: string
    color: string
    isDefault: boolean
    isFinal: boolean
    isBlocking: boolean
    orderIndex: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaskStatusCountAggregateOutputType | null
    _avg: TaskStatusAvgAggregateOutputType | null
    _sum: TaskStatusSumAggregateOutputType | null
    _min: TaskStatusMinAggregateOutputType | null
    _max: TaskStatusMaxAggregateOutputType | null
  }

  type GetTaskStatusGroupByPayload<T extends TaskStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TaskStatusGroupByOutputType[P]>
        }
      >
    >


  export type TaskStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskStatus"]>


  export type TaskStatusSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TaskStatus$tasksArgs<ExtArgs>
    _count?: boolean | TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TaskStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskStatus"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
      isDefault: boolean
      isFinal: boolean
      isBlocking: boolean
      orderIndex: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taskStatus"]>
    composites: {}
  }

  type TaskStatusGetPayload<S extends boolean | null | undefined | TaskStatusDefaultArgs> = $Result.GetResult<Prisma.$TaskStatusPayload, S>

  type TaskStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskStatusCountAggregateInputType | true
    }

  export interface TaskStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskStatus'], meta: { name: 'TaskStatus' } }
    /**
     * Find zero or one TaskStatus that matches the filter.
     * @param {TaskStatusFindUniqueArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskStatusFindUniqueArgs>(args: SelectSubset<T, TaskStatusFindUniqueArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskStatusFindUniqueOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskStatusFindFirstArgs>(args?: SelectSubset<T, TaskStatusFindFirstArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindFirstOrThrowArgs} args - Arguments to find a TaskStatus
     * @example
     * // Get one TaskStatus
     * const taskStatus = await prisma.taskStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany()
     * 
     * // Get first 10 TaskStatuses
     * const taskStatuses = await prisma.taskStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskStatusWithIdOnly = await prisma.taskStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskStatusFindManyArgs>(args?: SelectSubset<T, TaskStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskStatus.
     * @param {TaskStatusCreateArgs} args - Arguments to create a TaskStatus.
     * @example
     * // Create one TaskStatus
     * const TaskStatus = await prisma.taskStatus.create({
     *   data: {
     *     // ... data to create a TaskStatus
     *   }
     * })
     * 
     */
    create<T extends TaskStatusCreateArgs>(args: SelectSubset<T, TaskStatusCreateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskStatuses.
     * @param {TaskStatusCreateManyArgs} args - Arguments to create many TaskStatuses.
     * @example
     * // Create many TaskStatuses
     * const taskStatus = await prisma.taskStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskStatusCreateManyArgs>(args?: SelectSubset<T, TaskStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskStatus.
     * @param {TaskStatusDeleteArgs} args - Arguments to delete one TaskStatus.
     * @example
     * // Delete one TaskStatus
     * const TaskStatus = await prisma.taskStatus.delete({
     *   where: {
     *     // ... filter to delete one TaskStatus
     *   }
     * })
     * 
     */
    delete<T extends TaskStatusDeleteArgs>(args: SelectSubset<T, TaskStatusDeleteArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskStatus.
     * @param {TaskStatusUpdateArgs} args - Arguments to update one TaskStatus.
     * @example
     * // Update one TaskStatus
     * const taskStatus = await prisma.taskStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskStatusUpdateArgs>(args: SelectSubset<T, TaskStatusUpdateArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskStatuses.
     * @param {TaskStatusDeleteManyArgs} args - Arguments to filter TaskStatuses to delete.
     * @example
     * // Delete a few TaskStatuses
     * const { count } = await prisma.taskStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskStatusDeleteManyArgs>(args?: SelectSubset<T, TaskStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskStatuses
     * const taskStatus = await prisma.taskStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskStatusUpdateManyArgs>(args: SelectSubset<T, TaskStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskStatus.
     * @param {TaskStatusUpsertArgs} args - Arguments to update or create a TaskStatus.
     * @example
     * // Update or create a TaskStatus
     * const taskStatus = await prisma.taskStatus.upsert({
     *   create: {
     *     // ... data to create a TaskStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskStatus we want to update
     *   }
     * })
     */
    upsert<T extends TaskStatusUpsertArgs>(args: SelectSubset<T, TaskStatusUpsertArgs<ExtArgs>>): Prisma__TaskStatusClient<$Result.GetResult<Prisma.$TaskStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusCountArgs} args - Arguments to filter TaskStatuses to count.
     * @example
     * // Count the number of TaskStatuses
     * const count = await prisma.taskStatus.count({
     *   where: {
     *     // ... the filter for the TaskStatuses we want to count
     *   }
     * })
    **/
    count<T extends TaskStatusCountArgs>(
      args?: Subset<T, TaskStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskStatusAggregateArgs>(args: Subset<T, TaskStatusAggregateArgs>): Prisma.PrismaPromise<GetTaskStatusAggregateType<T>>

    /**
     * Group by TaskStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskStatusGroupByArgs['orderBy'] }
        : { orderBy?: TaskStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskStatus model
   */
  readonly fields: TaskStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends TaskStatus$tasksArgs<ExtArgs> = {}>(args?: Subset<T, TaskStatus$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskStatus model
   */ 
  interface TaskStatusFieldRefs {
    readonly id: FieldRef<"TaskStatus", 'Int'>
    readonly name: FieldRef<"TaskStatus", 'String'>
    readonly color: FieldRef<"TaskStatus", 'String'>
    readonly isDefault: FieldRef<"TaskStatus", 'Boolean'>
    readonly isFinal: FieldRef<"TaskStatus", 'Boolean'>
    readonly isBlocking: FieldRef<"TaskStatus", 'Boolean'>
    readonly orderIndex: FieldRef<"TaskStatus", 'Int'>
    readonly isActive: FieldRef<"TaskStatus", 'Boolean'>
    readonly createdAt: FieldRef<"TaskStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"TaskStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskStatus findUnique
   */
  export type TaskStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findUniqueOrThrow
   */
  export type TaskStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus findFirst
   */
  export type TaskStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findFirstOrThrow
   */
  export type TaskStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatus to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskStatuses.
     */
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus findMany
   */
  export type TaskStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter, which TaskStatuses to fetch.
     */
    where?: TaskStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskStatuses to fetch.
     */
    orderBy?: TaskStatusOrderByWithRelationInput | TaskStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskStatuses.
     */
    cursor?: TaskStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskStatuses.
     */
    skip?: number
    distinct?: TaskStatusScalarFieldEnum | TaskStatusScalarFieldEnum[]
  }

  /**
   * TaskStatus create
   */
  export type TaskStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskStatus.
     */
    data: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
  }

  /**
   * TaskStatus createMany
   */
  export type TaskStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskStatuses.
     */
    data: TaskStatusCreateManyInput | TaskStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskStatus update
   */
  export type TaskStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskStatus.
     */
    data: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
    /**
     * Choose, which TaskStatus to update.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus updateMany
   */
  export type TaskStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskStatuses.
     */
    data: XOR<TaskStatusUpdateManyMutationInput, TaskStatusUncheckedUpdateManyInput>
    /**
     * Filter which TaskStatuses to update
     */
    where?: TaskStatusWhereInput
  }

  /**
   * TaskStatus upsert
   */
  export type TaskStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskStatus to update in case it exists.
     */
    where: TaskStatusWhereUniqueInput
    /**
     * In case the TaskStatus found by the `where` argument doesn't exist, create a new TaskStatus with this data.
     */
    create: XOR<TaskStatusCreateInput, TaskStatusUncheckedCreateInput>
    /**
     * In case the TaskStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskStatusUpdateInput, TaskStatusUncheckedUpdateInput>
  }

  /**
   * TaskStatus delete
   */
  export type TaskStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
    /**
     * Filter which TaskStatus to delete.
     */
    where: TaskStatusWhereUniqueInput
  }

  /**
   * TaskStatus deleteMany
   */
  export type TaskStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskStatuses to delete
     */
    where?: TaskStatusWhereInput
  }

  /**
   * TaskStatus.tasks
   */
  export type TaskStatus$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskStatus without action
   */
  export type TaskStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskStatus
     */
    select?: TaskStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskStatusInclude<ExtArgs> | null
  }


  /**
   * Model StatSnapshot
   */

  export type AggregateStatSnapshot = {
    _count: StatSnapshotCountAggregateOutputType | null
    _avg: StatSnapshotAvgAggregateOutputType | null
    _sum: StatSnapshotSumAggregateOutputType | null
    _min: StatSnapshotMinAggregateOutputType | null
    _max: StatSnapshotMaxAggregateOutputType | null
  }

  export type StatSnapshotAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    value: number | null
  }

  export type StatSnapshotSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    value: number | null
  }

  export type StatSnapshotMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    metricKey: string | null
    value: number | null
    date: Date | null
    createdAt: Date | null
  }

  export type StatSnapshotMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    metricKey: string | null
    value: number | null
    date: Date | null
    createdAt: Date | null
  }

  export type StatSnapshotCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    metricKey: number
    value: number
    date: number
    createdAt: number
    _all: number
  }


  export type StatSnapshotAvgAggregateInputType = {
    id?: true
    entityId?: true
    value?: true
  }

  export type StatSnapshotSumAggregateInputType = {
    id?: true
    entityId?: true
    value?: true
  }

  export type StatSnapshotMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricKey?: true
    value?: true
    date?: true
    createdAt?: true
  }

  export type StatSnapshotMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricKey?: true
    value?: true
    date?: true
    createdAt?: true
  }

  export type StatSnapshotCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    metricKey?: true
    value?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type StatSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatSnapshot to aggregate.
     */
    where?: StatSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatSnapshots to fetch.
     */
    orderBy?: StatSnapshotOrderByWithRelationInput | StatSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatSnapshots
    **/
    _count?: true | StatSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatSnapshotMaxAggregateInputType
  }

  export type GetStatSnapshotAggregateType<T extends StatSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateStatSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatSnapshot[P]>
      : GetScalarType<T[P], AggregateStatSnapshot[P]>
  }




  export type StatSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatSnapshotWhereInput
    orderBy?: StatSnapshotOrderByWithAggregationInput | StatSnapshotOrderByWithAggregationInput[]
    by: StatSnapshotScalarFieldEnum[] | StatSnapshotScalarFieldEnum
    having?: StatSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatSnapshotCountAggregateInputType | true
    _avg?: StatSnapshotAvgAggregateInputType
    _sum?: StatSnapshotSumAggregateInputType
    _min?: StatSnapshotMinAggregateInputType
    _max?: StatSnapshotMaxAggregateInputType
  }

  export type StatSnapshotGroupByOutputType = {
    id: number
    entityType: string
    entityId: number | null
    metricKey: string
    value: number
    date: Date
    createdAt: Date
    _count: StatSnapshotCountAggregateOutputType | null
    _avg: StatSnapshotAvgAggregateOutputType | null
    _sum: StatSnapshotSumAggregateOutputType | null
    _min: StatSnapshotMinAggregateOutputType | null
    _max: StatSnapshotMaxAggregateOutputType | null
  }

  type GetStatSnapshotGroupByPayload<T extends StatSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], StatSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type StatSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricKey?: boolean
    value?: boolean
    date?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["statSnapshot"]>


  export type StatSnapshotSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    metricKey?: boolean
    value?: boolean
    date?: boolean
    createdAt?: boolean
  }


  export type $StatSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number | null
      metricKey: string
      value: number
      date: Date
      createdAt: Date
    }, ExtArgs["result"]["statSnapshot"]>
    composites: {}
  }

  type StatSnapshotGetPayload<S extends boolean | null | undefined | StatSnapshotDefaultArgs> = $Result.GetResult<Prisma.$StatSnapshotPayload, S>

  type StatSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatSnapshotCountAggregateInputType | true
    }

  export interface StatSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatSnapshot'], meta: { name: 'StatSnapshot' } }
    /**
     * Find zero or one StatSnapshot that matches the filter.
     * @param {StatSnapshotFindUniqueArgs} args - Arguments to find a StatSnapshot
     * @example
     * // Get one StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatSnapshotFindUniqueArgs>(args: SelectSubset<T, StatSnapshotFindUniqueArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatSnapshotFindUniqueOrThrowArgs} args - Arguments to find a StatSnapshot
     * @example
     * // Get one StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, StatSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotFindFirstArgs} args - Arguments to find a StatSnapshot
     * @example
     * // Get one StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatSnapshotFindFirstArgs>(args?: SelectSubset<T, StatSnapshotFindFirstArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotFindFirstOrThrowArgs} args - Arguments to find a StatSnapshot
     * @example
     * // Get one StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, StatSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatSnapshots
     * const statSnapshots = await prisma.statSnapshot.findMany()
     * 
     * // Get first 10 StatSnapshots
     * const statSnapshots = await prisma.statSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statSnapshotWithIdOnly = await prisma.statSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatSnapshotFindManyArgs>(args?: SelectSubset<T, StatSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatSnapshot.
     * @param {StatSnapshotCreateArgs} args - Arguments to create a StatSnapshot.
     * @example
     * // Create one StatSnapshot
     * const StatSnapshot = await prisma.statSnapshot.create({
     *   data: {
     *     // ... data to create a StatSnapshot
     *   }
     * })
     * 
     */
    create<T extends StatSnapshotCreateArgs>(args: SelectSubset<T, StatSnapshotCreateArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatSnapshots.
     * @param {StatSnapshotCreateManyArgs} args - Arguments to create many StatSnapshots.
     * @example
     * // Create many StatSnapshots
     * const statSnapshot = await prisma.statSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatSnapshotCreateManyArgs>(args?: SelectSubset<T, StatSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatSnapshot.
     * @param {StatSnapshotDeleteArgs} args - Arguments to delete one StatSnapshot.
     * @example
     * // Delete one StatSnapshot
     * const StatSnapshot = await prisma.statSnapshot.delete({
     *   where: {
     *     // ... filter to delete one StatSnapshot
     *   }
     * })
     * 
     */
    delete<T extends StatSnapshotDeleteArgs>(args: SelectSubset<T, StatSnapshotDeleteArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatSnapshot.
     * @param {StatSnapshotUpdateArgs} args - Arguments to update one StatSnapshot.
     * @example
     * // Update one StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatSnapshotUpdateArgs>(args: SelectSubset<T, StatSnapshotUpdateArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatSnapshots.
     * @param {StatSnapshotDeleteManyArgs} args - Arguments to filter StatSnapshots to delete.
     * @example
     * // Delete a few StatSnapshots
     * const { count } = await prisma.statSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatSnapshotDeleteManyArgs>(args?: SelectSubset<T, StatSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatSnapshots
     * const statSnapshot = await prisma.statSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatSnapshotUpdateManyArgs>(args: SelectSubset<T, StatSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatSnapshot.
     * @param {StatSnapshotUpsertArgs} args - Arguments to update or create a StatSnapshot.
     * @example
     * // Update or create a StatSnapshot
     * const statSnapshot = await prisma.statSnapshot.upsert({
     *   create: {
     *     // ... data to create a StatSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends StatSnapshotUpsertArgs>(args: SelectSubset<T, StatSnapshotUpsertArgs<ExtArgs>>): Prisma__StatSnapshotClient<$Result.GetResult<Prisma.$StatSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotCountArgs} args - Arguments to filter StatSnapshots to count.
     * @example
     * // Count the number of StatSnapshots
     * const count = await prisma.statSnapshot.count({
     *   where: {
     *     // ... the filter for the StatSnapshots we want to count
     *   }
     * })
    **/
    count<T extends StatSnapshotCountArgs>(
      args?: Subset<T, StatSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatSnapshotAggregateArgs>(args: Subset<T, StatSnapshotAggregateArgs>): Prisma.PrismaPromise<GetStatSnapshotAggregateType<T>>

    /**
     * Group by StatSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: StatSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatSnapshot model
   */
  readonly fields: StatSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatSnapshot model
   */ 
  interface StatSnapshotFieldRefs {
    readonly id: FieldRef<"StatSnapshot", 'Int'>
    readonly entityType: FieldRef<"StatSnapshot", 'String'>
    readonly entityId: FieldRef<"StatSnapshot", 'Int'>
    readonly metricKey: FieldRef<"StatSnapshot", 'String'>
    readonly value: FieldRef<"StatSnapshot", 'Float'>
    readonly date: FieldRef<"StatSnapshot", 'DateTime'>
    readonly createdAt: FieldRef<"StatSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatSnapshot findUnique
   */
  export type StatSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which StatSnapshot to fetch.
     */
    where: StatSnapshotWhereUniqueInput
  }

  /**
   * StatSnapshot findUniqueOrThrow
   */
  export type StatSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which StatSnapshot to fetch.
     */
    where: StatSnapshotWhereUniqueInput
  }

  /**
   * StatSnapshot findFirst
   */
  export type StatSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which StatSnapshot to fetch.
     */
    where?: StatSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatSnapshots to fetch.
     */
    orderBy?: StatSnapshotOrderByWithRelationInput | StatSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatSnapshots.
     */
    cursor?: StatSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatSnapshots.
     */
    distinct?: StatSnapshotScalarFieldEnum | StatSnapshotScalarFieldEnum[]
  }

  /**
   * StatSnapshot findFirstOrThrow
   */
  export type StatSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which StatSnapshot to fetch.
     */
    where?: StatSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatSnapshots to fetch.
     */
    orderBy?: StatSnapshotOrderByWithRelationInput | StatSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatSnapshots.
     */
    cursor?: StatSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatSnapshots.
     */
    distinct?: StatSnapshotScalarFieldEnum | StatSnapshotScalarFieldEnum[]
  }

  /**
   * StatSnapshot findMany
   */
  export type StatSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which StatSnapshots to fetch.
     */
    where?: StatSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatSnapshots to fetch.
     */
    orderBy?: StatSnapshotOrderByWithRelationInput | StatSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatSnapshots.
     */
    cursor?: StatSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatSnapshots.
     */
    skip?: number
    distinct?: StatSnapshotScalarFieldEnum | StatSnapshotScalarFieldEnum[]
  }

  /**
   * StatSnapshot create
   */
  export type StatSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * The data needed to create a StatSnapshot.
     */
    data: XOR<StatSnapshotCreateInput, StatSnapshotUncheckedCreateInput>
  }

  /**
   * StatSnapshot createMany
   */
  export type StatSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatSnapshots.
     */
    data: StatSnapshotCreateManyInput | StatSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatSnapshot update
   */
  export type StatSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * The data needed to update a StatSnapshot.
     */
    data: XOR<StatSnapshotUpdateInput, StatSnapshotUncheckedUpdateInput>
    /**
     * Choose, which StatSnapshot to update.
     */
    where: StatSnapshotWhereUniqueInput
  }

  /**
   * StatSnapshot updateMany
   */
  export type StatSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatSnapshots.
     */
    data: XOR<StatSnapshotUpdateManyMutationInput, StatSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which StatSnapshots to update
     */
    where?: StatSnapshotWhereInput
  }

  /**
   * StatSnapshot upsert
   */
  export type StatSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * The filter to search for the StatSnapshot to update in case it exists.
     */
    where: StatSnapshotWhereUniqueInput
    /**
     * In case the StatSnapshot found by the `where` argument doesn't exist, create a new StatSnapshot with this data.
     */
    create: XOR<StatSnapshotCreateInput, StatSnapshotUncheckedCreateInput>
    /**
     * In case the StatSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatSnapshotUpdateInput, StatSnapshotUncheckedUpdateInput>
  }

  /**
   * StatSnapshot delete
   */
  export type StatSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
    /**
     * Filter which StatSnapshot to delete.
     */
    where: StatSnapshotWhereUniqueInput
  }

  /**
   * StatSnapshot deleteMany
   */
  export type StatSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatSnapshots to delete
     */
    where?: StatSnapshotWhereInput
  }

  /**
   * StatSnapshot without action
   */
  export type StatSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatSnapshot
     */
    select?: StatSnapshotSelect<ExtArgs> | null
  }


  /**
   * Model ProductivitySnapshot
   */

  export type AggregateProductivitySnapshot = {
    _count: ProductivitySnapshotCountAggregateOutputType | null
    _avg: ProductivitySnapshotAvgAggregateOutputType | null
    _sum: ProductivitySnapshotSumAggregateOutputType | null
    _min: ProductivitySnapshotMinAggregateOutputType | null
    _max: ProductivitySnapshotMaxAggregateOutputType | null
  }

  export type ProductivitySnapshotAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    score: number | null
  }

  export type ProductivitySnapshotSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    score: number | null
  }

  export type ProductivitySnapshotMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    period: string | null
    startDate: Date | null
    endDate: Date | null
    score: number | null
    breakdown: string | null
    createdAt: Date | null
  }

  export type ProductivitySnapshotMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    period: string | null
    startDate: Date | null
    endDate: Date | null
    score: number | null
    breakdown: string | null
    createdAt: Date | null
  }

  export type ProductivitySnapshotCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    period: number
    startDate: number
    endDate: number
    score: number
    breakdown: number
    createdAt: number
    _all: number
  }


  export type ProductivitySnapshotAvgAggregateInputType = {
    id?: true
    entityId?: true
    score?: true
  }

  export type ProductivitySnapshotSumAggregateInputType = {
    id?: true
    entityId?: true
    score?: true
  }

  export type ProductivitySnapshotMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    startDate?: true
    endDate?: true
    score?: true
    breakdown?: true
    createdAt?: true
  }

  export type ProductivitySnapshotMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    startDate?: true
    endDate?: true
    score?: true
    breakdown?: true
    createdAt?: true
  }

  export type ProductivitySnapshotCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    period?: true
    startDate?: true
    endDate?: true
    score?: true
    breakdown?: true
    createdAt?: true
    _all?: true
  }

  export type ProductivitySnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductivitySnapshot to aggregate.
     */
    where?: ProductivitySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductivitySnapshots to fetch.
     */
    orderBy?: ProductivitySnapshotOrderByWithRelationInput | ProductivitySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductivitySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductivitySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductivitySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductivitySnapshots
    **/
    _count?: true | ProductivitySnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductivitySnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductivitySnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductivitySnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductivitySnapshotMaxAggregateInputType
  }

  export type GetProductivitySnapshotAggregateType<T extends ProductivitySnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateProductivitySnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductivitySnapshot[P]>
      : GetScalarType<T[P], AggregateProductivitySnapshot[P]>
  }




  export type ProductivitySnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductivitySnapshotWhereInput
    orderBy?: ProductivitySnapshotOrderByWithAggregationInput | ProductivitySnapshotOrderByWithAggregationInput[]
    by: ProductivitySnapshotScalarFieldEnum[] | ProductivitySnapshotScalarFieldEnum
    having?: ProductivitySnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductivitySnapshotCountAggregateInputType | true
    _avg?: ProductivitySnapshotAvgAggregateInputType
    _sum?: ProductivitySnapshotSumAggregateInputType
    _min?: ProductivitySnapshotMinAggregateInputType
    _max?: ProductivitySnapshotMaxAggregateInputType
  }

  export type ProductivitySnapshotGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    period: string
    startDate: Date
    endDate: Date
    score: number
    breakdown: string
    createdAt: Date
    _count: ProductivitySnapshotCountAggregateOutputType | null
    _avg: ProductivitySnapshotAvgAggregateOutputType | null
    _sum: ProductivitySnapshotSumAggregateOutputType | null
    _min: ProductivitySnapshotMinAggregateOutputType | null
    _max: ProductivitySnapshotMaxAggregateOutputType | null
  }

  type GetProductivitySnapshotGroupByPayload<T extends ProductivitySnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductivitySnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductivitySnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductivitySnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], ProductivitySnapshotGroupByOutputType[P]>
        }
      >
    >


  export type ProductivitySnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    score?: boolean
    breakdown?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productivitySnapshot"]>


  export type ProductivitySnapshotSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    score?: boolean
    breakdown?: boolean
    createdAt?: boolean
  }


  export type $ProductivitySnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductivitySnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      period: string
      startDate: Date
      endDate: Date
      score: number
      breakdown: string
      createdAt: Date
    }, ExtArgs["result"]["productivitySnapshot"]>
    composites: {}
  }

  type ProductivitySnapshotGetPayload<S extends boolean | null | undefined | ProductivitySnapshotDefaultArgs> = $Result.GetResult<Prisma.$ProductivitySnapshotPayload, S>

  type ProductivitySnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductivitySnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductivitySnapshotCountAggregateInputType | true
    }

  export interface ProductivitySnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductivitySnapshot'], meta: { name: 'ProductivitySnapshot' } }
    /**
     * Find zero or one ProductivitySnapshot that matches the filter.
     * @param {ProductivitySnapshotFindUniqueArgs} args - Arguments to find a ProductivitySnapshot
     * @example
     * // Get one ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductivitySnapshotFindUniqueArgs>(args: SelectSubset<T, ProductivitySnapshotFindUniqueArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductivitySnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductivitySnapshotFindUniqueOrThrowArgs} args - Arguments to find a ProductivitySnapshot
     * @example
     * // Get one ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductivitySnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductivitySnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductivitySnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotFindFirstArgs} args - Arguments to find a ProductivitySnapshot
     * @example
     * // Get one ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductivitySnapshotFindFirstArgs>(args?: SelectSubset<T, ProductivitySnapshotFindFirstArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductivitySnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotFindFirstOrThrowArgs} args - Arguments to find a ProductivitySnapshot
     * @example
     * // Get one ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductivitySnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductivitySnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductivitySnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductivitySnapshots
     * const productivitySnapshots = await prisma.productivitySnapshot.findMany()
     * 
     * // Get first 10 ProductivitySnapshots
     * const productivitySnapshots = await prisma.productivitySnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productivitySnapshotWithIdOnly = await prisma.productivitySnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductivitySnapshotFindManyArgs>(args?: SelectSubset<T, ProductivitySnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductivitySnapshot.
     * @param {ProductivitySnapshotCreateArgs} args - Arguments to create a ProductivitySnapshot.
     * @example
     * // Create one ProductivitySnapshot
     * const ProductivitySnapshot = await prisma.productivitySnapshot.create({
     *   data: {
     *     // ... data to create a ProductivitySnapshot
     *   }
     * })
     * 
     */
    create<T extends ProductivitySnapshotCreateArgs>(args: SelectSubset<T, ProductivitySnapshotCreateArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductivitySnapshots.
     * @param {ProductivitySnapshotCreateManyArgs} args - Arguments to create many ProductivitySnapshots.
     * @example
     * // Create many ProductivitySnapshots
     * const productivitySnapshot = await prisma.productivitySnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductivitySnapshotCreateManyArgs>(args?: SelectSubset<T, ProductivitySnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductivitySnapshot.
     * @param {ProductivitySnapshotDeleteArgs} args - Arguments to delete one ProductivitySnapshot.
     * @example
     * // Delete one ProductivitySnapshot
     * const ProductivitySnapshot = await prisma.productivitySnapshot.delete({
     *   where: {
     *     // ... filter to delete one ProductivitySnapshot
     *   }
     * })
     * 
     */
    delete<T extends ProductivitySnapshotDeleteArgs>(args: SelectSubset<T, ProductivitySnapshotDeleteArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductivitySnapshot.
     * @param {ProductivitySnapshotUpdateArgs} args - Arguments to update one ProductivitySnapshot.
     * @example
     * // Update one ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductivitySnapshotUpdateArgs>(args: SelectSubset<T, ProductivitySnapshotUpdateArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductivitySnapshots.
     * @param {ProductivitySnapshotDeleteManyArgs} args - Arguments to filter ProductivitySnapshots to delete.
     * @example
     * // Delete a few ProductivitySnapshots
     * const { count } = await prisma.productivitySnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductivitySnapshotDeleteManyArgs>(args?: SelectSubset<T, ProductivitySnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductivitySnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductivitySnapshots
     * const productivitySnapshot = await prisma.productivitySnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductivitySnapshotUpdateManyArgs>(args: SelectSubset<T, ProductivitySnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductivitySnapshot.
     * @param {ProductivitySnapshotUpsertArgs} args - Arguments to update or create a ProductivitySnapshot.
     * @example
     * // Update or create a ProductivitySnapshot
     * const productivitySnapshot = await prisma.productivitySnapshot.upsert({
     *   create: {
     *     // ... data to create a ProductivitySnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductivitySnapshot we want to update
     *   }
     * })
     */
    upsert<T extends ProductivitySnapshotUpsertArgs>(args: SelectSubset<T, ProductivitySnapshotUpsertArgs<ExtArgs>>): Prisma__ProductivitySnapshotClient<$Result.GetResult<Prisma.$ProductivitySnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductivitySnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotCountArgs} args - Arguments to filter ProductivitySnapshots to count.
     * @example
     * // Count the number of ProductivitySnapshots
     * const count = await prisma.productivitySnapshot.count({
     *   where: {
     *     // ... the filter for the ProductivitySnapshots we want to count
     *   }
     * })
    **/
    count<T extends ProductivitySnapshotCountArgs>(
      args?: Subset<T, ProductivitySnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductivitySnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductivitySnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductivitySnapshotAggregateArgs>(args: Subset<T, ProductivitySnapshotAggregateArgs>): Prisma.PrismaPromise<GetProductivitySnapshotAggregateType<T>>

    /**
     * Group by ProductivitySnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductivitySnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductivitySnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductivitySnapshotGroupByArgs['orderBy'] }
        : { orderBy?: ProductivitySnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductivitySnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductivitySnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductivitySnapshot model
   */
  readonly fields: ProductivitySnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductivitySnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductivitySnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductivitySnapshot model
   */ 
  interface ProductivitySnapshotFieldRefs {
    readonly id: FieldRef<"ProductivitySnapshot", 'Int'>
    readonly entityType: FieldRef<"ProductivitySnapshot", 'String'>
    readonly entityId: FieldRef<"ProductivitySnapshot", 'Int'>
    readonly period: FieldRef<"ProductivitySnapshot", 'String'>
    readonly startDate: FieldRef<"ProductivitySnapshot", 'DateTime'>
    readonly endDate: FieldRef<"ProductivitySnapshot", 'DateTime'>
    readonly score: FieldRef<"ProductivitySnapshot", 'Float'>
    readonly breakdown: FieldRef<"ProductivitySnapshot", 'String'>
    readonly createdAt: FieldRef<"ProductivitySnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductivitySnapshot findUnique
   */
  export type ProductivitySnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ProductivitySnapshot to fetch.
     */
    where: ProductivitySnapshotWhereUniqueInput
  }

  /**
   * ProductivitySnapshot findUniqueOrThrow
   */
  export type ProductivitySnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ProductivitySnapshot to fetch.
     */
    where: ProductivitySnapshotWhereUniqueInput
  }

  /**
   * ProductivitySnapshot findFirst
   */
  export type ProductivitySnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ProductivitySnapshot to fetch.
     */
    where?: ProductivitySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductivitySnapshots to fetch.
     */
    orderBy?: ProductivitySnapshotOrderByWithRelationInput | ProductivitySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductivitySnapshots.
     */
    cursor?: ProductivitySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductivitySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductivitySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductivitySnapshots.
     */
    distinct?: ProductivitySnapshotScalarFieldEnum | ProductivitySnapshotScalarFieldEnum[]
  }

  /**
   * ProductivitySnapshot findFirstOrThrow
   */
  export type ProductivitySnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ProductivitySnapshot to fetch.
     */
    where?: ProductivitySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductivitySnapshots to fetch.
     */
    orderBy?: ProductivitySnapshotOrderByWithRelationInput | ProductivitySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductivitySnapshots.
     */
    cursor?: ProductivitySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductivitySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductivitySnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductivitySnapshots.
     */
    distinct?: ProductivitySnapshotScalarFieldEnum | ProductivitySnapshotScalarFieldEnum[]
  }

  /**
   * ProductivitySnapshot findMany
   */
  export type ProductivitySnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ProductivitySnapshots to fetch.
     */
    where?: ProductivitySnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductivitySnapshots to fetch.
     */
    orderBy?: ProductivitySnapshotOrderByWithRelationInput | ProductivitySnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductivitySnapshots.
     */
    cursor?: ProductivitySnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductivitySnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductivitySnapshots.
     */
    skip?: number
    distinct?: ProductivitySnapshotScalarFieldEnum | ProductivitySnapshotScalarFieldEnum[]
  }

  /**
   * ProductivitySnapshot create
   */
  export type ProductivitySnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * The data needed to create a ProductivitySnapshot.
     */
    data: XOR<ProductivitySnapshotCreateInput, ProductivitySnapshotUncheckedCreateInput>
  }

  /**
   * ProductivitySnapshot createMany
   */
  export type ProductivitySnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductivitySnapshots.
     */
    data: ProductivitySnapshotCreateManyInput | ProductivitySnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductivitySnapshot update
   */
  export type ProductivitySnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * The data needed to update a ProductivitySnapshot.
     */
    data: XOR<ProductivitySnapshotUpdateInput, ProductivitySnapshotUncheckedUpdateInput>
    /**
     * Choose, which ProductivitySnapshot to update.
     */
    where: ProductivitySnapshotWhereUniqueInput
  }

  /**
   * ProductivitySnapshot updateMany
   */
  export type ProductivitySnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductivitySnapshots.
     */
    data: XOR<ProductivitySnapshotUpdateManyMutationInput, ProductivitySnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ProductivitySnapshots to update
     */
    where?: ProductivitySnapshotWhereInput
  }

  /**
   * ProductivitySnapshot upsert
   */
  export type ProductivitySnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * The filter to search for the ProductivitySnapshot to update in case it exists.
     */
    where: ProductivitySnapshotWhereUniqueInput
    /**
     * In case the ProductivitySnapshot found by the `where` argument doesn't exist, create a new ProductivitySnapshot with this data.
     */
    create: XOR<ProductivitySnapshotCreateInput, ProductivitySnapshotUncheckedCreateInput>
    /**
     * In case the ProductivitySnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductivitySnapshotUpdateInput, ProductivitySnapshotUncheckedUpdateInput>
  }

  /**
   * ProductivitySnapshot delete
   */
  export type ProductivitySnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
    /**
     * Filter which ProductivitySnapshot to delete.
     */
    where: ProductivitySnapshotWhereUniqueInput
  }

  /**
   * ProductivitySnapshot deleteMany
   */
  export type ProductivitySnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductivitySnapshots to delete
     */
    where?: ProductivitySnapshotWhereInput
  }

  /**
   * ProductivitySnapshot without action
   */
  export type ProductivitySnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductivitySnapshot
     */
    select?: ProductivitySnapshotSelect<ExtArgs> | null
  }


  /**
   * Model ForecastSnapshot
   */

  export type AggregateForecastSnapshot = {
    _count: ForecastSnapshotCountAggregateOutputType | null
    _avg: ForecastSnapshotAvgAggregateOutputType | null
    _sum: ForecastSnapshotSumAggregateOutputType | null
    _min: ForecastSnapshotMinAggregateOutputType | null
    _max: ForecastSnapshotMaxAggregateOutputType | null
  }

  export type ForecastSnapshotAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    confidence: number | null
  }

  export type ForecastSnapshotSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    confidence: number | null
  }

  export type ForecastSnapshotMinAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    predictedDate: Date | null
    riskLevel: string | null
    confidence: number | null
    explanation: string | null
    createdAt: Date | null
  }

  export type ForecastSnapshotMaxAggregateOutputType = {
    id: number | null
    entityType: string | null
    entityId: number | null
    predictedDate: Date | null
    riskLevel: string | null
    confidence: number | null
    explanation: string | null
    createdAt: Date | null
  }

  export type ForecastSnapshotCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    predictedDate: number
    riskLevel: number
    confidence: number
    explanation: number
    createdAt: number
    _all: number
  }


  export type ForecastSnapshotAvgAggregateInputType = {
    id?: true
    entityId?: true
    confidence?: true
  }

  export type ForecastSnapshotSumAggregateInputType = {
    id?: true
    entityId?: true
    confidence?: true
  }

  export type ForecastSnapshotMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    predictedDate?: true
    riskLevel?: true
    confidence?: true
    explanation?: true
    createdAt?: true
  }

  export type ForecastSnapshotMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    predictedDate?: true
    riskLevel?: true
    confidence?: true
    explanation?: true
    createdAt?: true
  }

  export type ForecastSnapshotCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    predictedDate?: true
    riskLevel?: true
    confidence?: true
    explanation?: true
    createdAt?: true
    _all?: true
  }

  export type ForecastSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastSnapshot to aggregate.
     */
    where?: ForecastSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastSnapshots to fetch.
     */
    orderBy?: ForecastSnapshotOrderByWithRelationInput | ForecastSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForecastSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForecastSnapshots
    **/
    _count?: true | ForecastSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForecastSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForecastSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForecastSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForecastSnapshotMaxAggregateInputType
  }

  export type GetForecastSnapshotAggregateType<T extends ForecastSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateForecastSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForecastSnapshot[P]>
      : GetScalarType<T[P], AggregateForecastSnapshot[P]>
  }




  export type ForecastSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForecastSnapshotWhereInput
    orderBy?: ForecastSnapshotOrderByWithAggregationInput | ForecastSnapshotOrderByWithAggregationInput[]
    by: ForecastSnapshotScalarFieldEnum[] | ForecastSnapshotScalarFieldEnum
    having?: ForecastSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForecastSnapshotCountAggregateInputType | true
    _avg?: ForecastSnapshotAvgAggregateInputType
    _sum?: ForecastSnapshotSumAggregateInputType
    _min?: ForecastSnapshotMinAggregateInputType
    _max?: ForecastSnapshotMaxAggregateInputType
  }

  export type ForecastSnapshotGroupByOutputType = {
    id: number
    entityType: string
    entityId: number
    predictedDate: Date
    riskLevel: string
    confidence: number
    explanation: string
    createdAt: Date
    _count: ForecastSnapshotCountAggregateOutputType | null
    _avg: ForecastSnapshotAvgAggregateOutputType | null
    _sum: ForecastSnapshotSumAggregateOutputType | null
    _min: ForecastSnapshotMinAggregateOutputType | null
    _max: ForecastSnapshotMaxAggregateOutputType | null
  }

  type GetForecastSnapshotGroupByPayload<T extends ForecastSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForecastSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForecastSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForecastSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], ForecastSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type ForecastSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    predictedDate?: boolean
    riskLevel?: boolean
    confidence?: boolean
    explanation?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["forecastSnapshot"]>


  export type ForecastSnapshotSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    predictedDate?: boolean
    riskLevel?: boolean
    confidence?: boolean
    explanation?: boolean
    createdAt?: boolean
  }


  export type $ForecastSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForecastSnapshot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: string
      entityId: number
      predictedDate: Date
      riskLevel: string
      confidence: number
      explanation: string
      createdAt: Date
    }, ExtArgs["result"]["forecastSnapshot"]>
    composites: {}
  }

  type ForecastSnapshotGetPayload<S extends boolean | null | undefined | ForecastSnapshotDefaultArgs> = $Result.GetResult<Prisma.$ForecastSnapshotPayload, S>

  type ForecastSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForecastSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForecastSnapshotCountAggregateInputType | true
    }

  export interface ForecastSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForecastSnapshot'], meta: { name: 'ForecastSnapshot' } }
    /**
     * Find zero or one ForecastSnapshot that matches the filter.
     * @param {ForecastSnapshotFindUniqueArgs} args - Arguments to find a ForecastSnapshot
     * @example
     * // Get one ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForecastSnapshotFindUniqueArgs>(args: SelectSubset<T, ForecastSnapshotFindUniqueArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForecastSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForecastSnapshotFindUniqueOrThrowArgs} args - Arguments to find a ForecastSnapshot
     * @example
     * // Get one ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForecastSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ForecastSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForecastSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotFindFirstArgs} args - Arguments to find a ForecastSnapshot
     * @example
     * // Get one ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForecastSnapshotFindFirstArgs>(args?: SelectSubset<T, ForecastSnapshotFindFirstArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForecastSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotFindFirstOrThrowArgs} args - Arguments to find a ForecastSnapshot
     * @example
     * // Get one ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForecastSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ForecastSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForecastSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForecastSnapshots
     * const forecastSnapshots = await prisma.forecastSnapshot.findMany()
     * 
     * // Get first 10 ForecastSnapshots
     * const forecastSnapshots = await prisma.forecastSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forecastSnapshotWithIdOnly = await prisma.forecastSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForecastSnapshotFindManyArgs>(args?: SelectSubset<T, ForecastSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForecastSnapshot.
     * @param {ForecastSnapshotCreateArgs} args - Arguments to create a ForecastSnapshot.
     * @example
     * // Create one ForecastSnapshot
     * const ForecastSnapshot = await prisma.forecastSnapshot.create({
     *   data: {
     *     // ... data to create a ForecastSnapshot
     *   }
     * })
     * 
     */
    create<T extends ForecastSnapshotCreateArgs>(args: SelectSubset<T, ForecastSnapshotCreateArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForecastSnapshots.
     * @param {ForecastSnapshotCreateManyArgs} args - Arguments to create many ForecastSnapshots.
     * @example
     * // Create many ForecastSnapshots
     * const forecastSnapshot = await prisma.forecastSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForecastSnapshotCreateManyArgs>(args?: SelectSubset<T, ForecastSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ForecastSnapshot.
     * @param {ForecastSnapshotDeleteArgs} args - Arguments to delete one ForecastSnapshot.
     * @example
     * // Delete one ForecastSnapshot
     * const ForecastSnapshot = await prisma.forecastSnapshot.delete({
     *   where: {
     *     // ... filter to delete one ForecastSnapshot
     *   }
     * })
     * 
     */
    delete<T extends ForecastSnapshotDeleteArgs>(args: SelectSubset<T, ForecastSnapshotDeleteArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForecastSnapshot.
     * @param {ForecastSnapshotUpdateArgs} args - Arguments to update one ForecastSnapshot.
     * @example
     * // Update one ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForecastSnapshotUpdateArgs>(args: SelectSubset<T, ForecastSnapshotUpdateArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForecastSnapshots.
     * @param {ForecastSnapshotDeleteManyArgs} args - Arguments to filter ForecastSnapshots to delete.
     * @example
     * // Delete a few ForecastSnapshots
     * const { count } = await prisma.forecastSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForecastSnapshotDeleteManyArgs>(args?: SelectSubset<T, ForecastSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForecastSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForecastSnapshots
     * const forecastSnapshot = await prisma.forecastSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForecastSnapshotUpdateManyArgs>(args: SelectSubset<T, ForecastSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForecastSnapshot.
     * @param {ForecastSnapshotUpsertArgs} args - Arguments to update or create a ForecastSnapshot.
     * @example
     * // Update or create a ForecastSnapshot
     * const forecastSnapshot = await prisma.forecastSnapshot.upsert({
     *   create: {
     *     // ... data to create a ForecastSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForecastSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends ForecastSnapshotUpsertArgs>(args: SelectSubset<T, ForecastSnapshotUpsertArgs<ExtArgs>>): Prisma__ForecastSnapshotClient<$Result.GetResult<Prisma.$ForecastSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForecastSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotCountArgs} args - Arguments to filter ForecastSnapshots to count.
     * @example
     * // Count the number of ForecastSnapshots
     * const count = await prisma.forecastSnapshot.count({
     *   where: {
     *     // ... the filter for the ForecastSnapshots we want to count
     *   }
     * })
    **/
    count<T extends ForecastSnapshotCountArgs>(
      args?: Subset<T, ForecastSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForecastSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForecastSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForecastSnapshotAggregateArgs>(args: Subset<T, ForecastSnapshotAggregateArgs>): Prisma.PrismaPromise<GetForecastSnapshotAggregateType<T>>

    /**
     * Group by ForecastSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForecastSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForecastSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForecastSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: ForecastSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForecastSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForecastSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForecastSnapshot model
   */
  readonly fields: ForecastSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForecastSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForecastSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForecastSnapshot model
   */ 
  interface ForecastSnapshotFieldRefs {
    readonly id: FieldRef<"ForecastSnapshot", 'Int'>
    readonly entityType: FieldRef<"ForecastSnapshot", 'String'>
    readonly entityId: FieldRef<"ForecastSnapshot", 'Int'>
    readonly predictedDate: FieldRef<"ForecastSnapshot", 'DateTime'>
    readonly riskLevel: FieldRef<"ForecastSnapshot", 'String'>
    readonly confidence: FieldRef<"ForecastSnapshot", 'Float'>
    readonly explanation: FieldRef<"ForecastSnapshot", 'String'>
    readonly createdAt: FieldRef<"ForecastSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForecastSnapshot findUnique
   */
  export type ForecastSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ForecastSnapshot to fetch.
     */
    where: ForecastSnapshotWhereUniqueInput
  }

  /**
   * ForecastSnapshot findUniqueOrThrow
   */
  export type ForecastSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ForecastSnapshot to fetch.
     */
    where: ForecastSnapshotWhereUniqueInput
  }

  /**
   * ForecastSnapshot findFirst
   */
  export type ForecastSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ForecastSnapshot to fetch.
     */
    where?: ForecastSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastSnapshots to fetch.
     */
    orderBy?: ForecastSnapshotOrderByWithRelationInput | ForecastSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastSnapshots.
     */
    cursor?: ForecastSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastSnapshots.
     */
    distinct?: ForecastSnapshotScalarFieldEnum | ForecastSnapshotScalarFieldEnum[]
  }

  /**
   * ForecastSnapshot findFirstOrThrow
   */
  export type ForecastSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ForecastSnapshot to fetch.
     */
    where?: ForecastSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastSnapshots to fetch.
     */
    orderBy?: ForecastSnapshotOrderByWithRelationInput | ForecastSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForecastSnapshots.
     */
    cursor?: ForecastSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForecastSnapshots.
     */
    distinct?: ForecastSnapshotScalarFieldEnum | ForecastSnapshotScalarFieldEnum[]
  }

  /**
   * ForecastSnapshot findMany
   */
  export type ForecastSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter, which ForecastSnapshots to fetch.
     */
    where?: ForecastSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForecastSnapshots to fetch.
     */
    orderBy?: ForecastSnapshotOrderByWithRelationInput | ForecastSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForecastSnapshots.
     */
    cursor?: ForecastSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForecastSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForecastSnapshots.
     */
    skip?: number
    distinct?: ForecastSnapshotScalarFieldEnum | ForecastSnapshotScalarFieldEnum[]
  }

  /**
   * ForecastSnapshot create
   */
  export type ForecastSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * The data needed to create a ForecastSnapshot.
     */
    data: XOR<ForecastSnapshotCreateInput, ForecastSnapshotUncheckedCreateInput>
  }

  /**
   * ForecastSnapshot createMany
   */
  export type ForecastSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForecastSnapshots.
     */
    data: ForecastSnapshotCreateManyInput | ForecastSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForecastSnapshot update
   */
  export type ForecastSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * The data needed to update a ForecastSnapshot.
     */
    data: XOR<ForecastSnapshotUpdateInput, ForecastSnapshotUncheckedUpdateInput>
    /**
     * Choose, which ForecastSnapshot to update.
     */
    where: ForecastSnapshotWhereUniqueInput
  }

  /**
   * ForecastSnapshot updateMany
   */
  export type ForecastSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForecastSnapshots.
     */
    data: XOR<ForecastSnapshotUpdateManyMutationInput, ForecastSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ForecastSnapshots to update
     */
    where?: ForecastSnapshotWhereInput
  }

  /**
   * ForecastSnapshot upsert
   */
  export type ForecastSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * The filter to search for the ForecastSnapshot to update in case it exists.
     */
    where: ForecastSnapshotWhereUniqueInput
    /**
     * In case the ForecastSnapshot found by the `where` argument doesn't exist, create a new ForecastSnapshot with this data.
     */
    create: XOR<ForecastSnapshotCreateInput, ForecastSnapshotUncheckedCreateInput>
    /**
     * In case the ForecastSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForecastSnapshotUpdateInput, ForecastSnapshotUncheckedUpdateInput>
  }

  /**
   * ForecastSnapshot delete
   */
  export type ForecastSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
    /**
     * Filter which ForecastSnapshot to delete.
     */
    where: ForecastSnapshotWhereUniqueInput
  }

  /**
   * ForecastSnapshot deleteMany
   */
  export type ForecastSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForecastSnapshots to delete
     */
    where?: ForecastSnapshotWhereInput
  }

  /**
   * ForecastSnapshot without action
   */
  export type ForecastSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForecastSnapshot
     */
    select?: ForecastSnapshotSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    teamId: 'teamId',
    avatarUrl: 'avatarUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    teamLeadId: 'teamLeadId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    projectTypeId: 'projectTypeId',
    projectStatusId: 'projectStatusId',
    description: 'description',
    scope: 'scope',
    status: 'status',
    priority: 'priority',
    urgentReason: 'urgentReason',
    urgentMarkedAt: 'urgentMarkedAt',
    urgentMarkedById: 'urgentMarkedById',
    startDate: 'startDate',
    endDate: 'endDate',
    projectManagerId: 'projectManagerId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    taskStatusId: 'taskStatusId',
    priority: 'priority',
    dueDate: 'dueDate',
    plannedDate: 'plannedDate',
    estimatedHours: 'estimatedHours',
    actualHours: 'actualHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    teamId: 'teamId',
    createdById: 'createdById',
    deliverableId: 'deliverableId',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const SubtaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    startDate: 'startDate',
    dueDate: 'dueDate',
    estimatedHours: 'estimatedHours',
    actualHours: 'actualHours',
    parentTaskId: 'parentTaskId',
    assignedToId: 'assignedToId',
    teamId: 'teamId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubtaskScalarFieldEnum = (typeof SubtaskScalarFieldEnum)[keyof typeof SubtaskScalarFieldEnum]


  export const SubtaskDependencyScalarFieldEnum: {
    subtaskId: 'subtaskId',
    dependsOnSubtaskId: 'dependsOnSubtaskId',
    dependencyType: 'dependencyType',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type SubtaskDependencyScalarFieldEnum = (typeof SubtaskDependencyScalarFieldEnum)[keyof typeof SubtaskDependencyScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    taskId: 'taskId',
    subtaskId: 'subtaskId',
    userId: 'userId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentMentionScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type CommentMentionScalarFieldEnum = (typeof CommentMentionScalarFieldEnum)[keyof typeof CommentMentionScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const TaskLabelScalarFieldEnum: {
    taskId: 'taskId',
    labelId: 'labelId',
    createdAt: 'createdAt'
  };

  export type TaskLabelScalarFieldEnum = (typeof TaskLabelScalarFieldEnum)[keyof typeof TaskLabelScalarFieldEnum]


  export const TaskDependencyScalarFieldEnum: {
    taskId: 'taskId',
    dependsOnTaskId: 'dependsOnTaskId',
    dependencyType: 'dependencyType',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type TaskDependencyScalarFieldEnum = (typeof TaskDependencyScalarFieldEnum)[keyof typeof TaskDependencyScalarFieldEnum]


  export const TimeLogScalarFieldEnum: {
    id: 'id',
    hoursLogged: 'hoursLogged',
    description: 'description',
    logDate: 'logDate',
    createdAt: 'createdAt',
    userId: 'userId',
    taskId: 'taskId',
    subtaskId: 'subtaskId'
  };

  export type TimeLogScalarFieldEnum = (typeof TimeLogScalarFieldEnum)[keyof typeof TimeLogScalarFieldEnum]


  export const AutomationRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    triggerType: 'triggerType',
    triggerCondition: 'triggerCondition',
    actionType: 'actionType',
    actionConfig: 'actionConfig',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdById: 'createdById',
    teamId: 'teamId'
  };

  export type AutomationRuleScalarFieldEnum = (typeof AutomationRuleScalarFieldEnum)[keyof typeof AutomationRuleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    actionType: 'actionType',
    actionCategory: 'actionCategory',
    actionSummary: 'actionSummary',
    actionDetails: 'actionDetails',
    performedById: 'performedById',
    affectedUserId: 'affectedUserId',
    projectId: 'projectId',
    entityType: 'entityType',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    action: 'action',
    description: 'description',
    userId: 'userId'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const ProjectUserScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    allocationPercentage: 'allocationPercentage',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    createdAt: 'createdAt'
  };

  export type ProjectUserScalarFieldEnum = (typeof ProjectUserScalarFieldEnum)[keyof typeof ProjectUserScalarFieldEnum]


  export const ProjectPhaseScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    sequenceOrder: 'sequenceOrder',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ProjectPhaseScalarFieldEnum = (typeof ProjectPhaseScalarFieldEnum)[keyof typeof ProjectPhaseScalarFieldEnum]


  export const DeliverableScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    acceptanceCriteria: 'acceptanceCriteria',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliverableScalarFieldEnum = (typeof DeliverableScalarFieldEnum)[keyof typeof DeliverableScalarFieldEnum]


  export const ScopeHistoryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    scopeText: 'scopeText',
    changeReason: 'changeReason',
    changedById: 'changedById',
    createdAt: 'createdAt'
  };

  export type ScopeHistoryScalarFieldEnum = (typeof ScopeHistoryScalarFieldEnum)[keyof typeof ScopeHistoryScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    uploadedAt: 'uploadedAt',
    taskId: 'taskId',
    uploadedById: 'uploadedById'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SettingsChangeLogScalarFieldEnum: {
    id: 'id',
    settingKey: 'settingKey',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    userId: 'userId',
    settingId: 'settingId',
    createdAt: 'createdAt'
  };

  export type SettingsChangeLogScalarFieldEnum = (typeof SettingsChangeLogScalarFieldEnum)[keyof typeof SettingsChangeLogScalarFieldEnum]


  export const ProjectSettingScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    key: 'key',
    value: 'value',
    category: 'category',
    enabled: 'enabled',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProjectSettingScalarFieldEnum = (typeof ProjectSettingScalarFieldEnum)[keyof typeof ProjectSettingScalarFieldEnum]


  export const ProjectSettingsChangeLogScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    settingKey: 'settingKey',
    category: 'category',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    changedBy: 'changedBy',
    settingId: 'settingId',
    createdAt: 'createdAt'
  };

  export type ProjectSettingsChangeLogScalarFieldEnum = (typeof ProjectSettingsChangeLogScalarFieldEnum)[keyof typeof ProjectSettingsChangeLogScalarFieldEnum]


  export const UserSettingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    key: 'key',
    value: 'value',
    category: 'category',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type UserSettingScalarFieldEnum = (typeof UserSettingScalarFieldEnum)[keyof typeof UserSettingScalarFieldEnum]


  export const UserSettingsChangeLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    settingKey: 'settingKey',
    category: 'category',
    oldValue: 'oldValue',
    newValue: 'newValue',
    reason: 'reason',
    changedBy: 'changedBy',
    settingId: 'settingId',
    createdAt: 'createdAt'
  };

  export type UserSettingsChangeLogScalarFieldEnum = (typeof UserSettingsChangeLogScalarFieldEnum)[keyof typeof UserSettingsChangeLogScalarFieldEnum]


  export const ProjectNotificationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    type: 'type',
    entityType: 'entityType',
    entityId: 'entityId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    soundRequired: 'soundRequired',
    isUrgent: 'isUrgent',
    requiresAcknowledgment: 'requiresAcknowledgment',
    acknowledgedAt: 'acknowledgedAt',
    createdAt: 'createdAt'
  };

  export type ProjectNotificationScalarFieldEnum = (typeof ProjectNotificationScalarFieldEnum)[keyof typeof ProjectNotificationScalarFieldEnum]


  export const UrgentProjectAcknowledgementScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    acknowledgedAt: 'acknowledgedAt'
  };

  export type UrgentProjectAcknowledgementScalarFieldEnum = (typeof UrgentProjectAcknowledgementScalarFieldEnum)[keyof typeof UrgentProjectAcknowledgementScalarFieldEnum]


  export const ProjectNotificationPreferenceScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    soundEnabled: 'soundEnabled',
    taskNotifications: 'taskNotifications',
    dependencyNotifications: 'dependencyNotifications',
    todayTaskNotifications: 'todayTaskNotifications',
    projectAdminNotifications: 'projectAdminNotifications',
    updatedAt: 'updatedAt'
  };

  export type ProjectNotificationPreferenceScalarFieldEnum = (typeof ProjectNotificationPreferenceScalarFieldEnum)[keyof typeof ProjectNotificationPreferenceScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const ProjectTeamScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    teamId: 'teamId',
    assignedAt: 'assignedAt'
  };

  export type ProjectTeamScalarFieldEnum = (typeof ProjectTeamScalarFieldEnum)[keyof typeof ProjectTeamScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystemRole: 'isSystemRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    module: 'module',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    scopeType: 'scopeType',
    scopeId: 'scopeId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const ProjectTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    displayOrder: 'displayOrder',
    color: 'color',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectTypeScalarFieldEnum = (typeof ProjectTypeScalarFieldEnum)[keyof typeof ProjectTypeScalarFieldEnum]


  export const ProjectStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    isDefault: 'isDefault',
    isFinal: 'isFinal',
    isUrgent: 'isUrgent',
    orderIndex: 'orderIndex',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectStatusScalarFieldEnum = (typeof ProjectStatusScalarFieldEnum)[keyof typeof ProjectStatusScalarFieldEnum]


  export const TaskStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    isDefault: 'isDefault',
    isFinal: 'isFinal',
    isBlocking: 'isBlocking',
    orderIndex: 'orderIndex',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskStatusScalarFieldEnum = (typeof TaskStatusScalarFieldEnum)[keyof typeof TaskStatusScalarFieldEnum]


  export const StatSnapshotScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    metricKey: 'metricKey',
    value: 'value',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type StatSnapshotScalarFieldEnum = (typeof StatSnapshotScalarFieldEnum)[keyof typeof StatSnapshotScalarFieldEnum]


  export const ProductivitySnapshotScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    score: 'score',
    breakdown: 'breakdown',
    createdAt: 'createdAt'
  };

  export type ProductivitySnapshotScalarFieldEnum = (typeof ProductivitySnapshotScalarFieldEnum)[keyof typeof ProductivitySnapshotScalarFieldEnum]


  export const ForecastSnapshotScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    predictedDate: 'predictedDate',
    riskLevel: 'riskLevel',
    confidence: 'confidence',
    explanation: 'explanation',
    createdAt: 'createdAt'
  };

  export type ForecastSnapshotScalarFieldEnum = (typeof ForecastSnapshotScalarFieldEnum)[keyof typeof ForecastSnapshotScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    activityLogsPerformed?: ActivityLogListRelationFilter
    activityLogsAffected?: ActivityLogListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    uploadedFiles?: AttachmentListRelationFilter
    createdRules?: AutomationRuleListRelationFilter
    comments?: CommentListRelationFilter
    commentMentions?: CommentMentionListRelationFilter
    notifications?: NotificationListRelationFilter
    projectNotificationPreferences?: ProjectNotificationPreferenceListRelationFilter
    projectNotifications?: ProjectNotificationListRelationFilter
    projectSettingsUpdated?: ProjectSettingListRelationFilter
    projectSettingsChanged?: ProjectSettingsChangeLogListRelationFilter
    projectsManaged?: ProjectListRelationFilter
    projectsMarkedUrgent?: ProjectListRelationFilter
    settingsChanged?: SettingsChangeLogListRelationFilter
    createdSubtasks?: SubtaskListRelationFilter
    assignedSubtasks?: SubtaskListRelationFilter
    updatedSettings?: SystemSettingListRelationFilter
    tasksCreated?: TaskListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    userSettingsUpdated?: UserSettingListRelationFilter
    userSettings?: UserSettingListRelationFilter
    userSettingsChanged?: UserSettingsChangeLogListRelationFilter
    userSettingsChangeLogs?: UserSettingsChangeLogListRelationFilter
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    assignedTasks?: TaskListRelationFilter
    teamsLed?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    roles?: UserRoleListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    urgentAcknowledgements?: UrgentProjectAcknowledgementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    activityLogsPerformed?: ActivityLogOrderByRelationAggregateInput
    activityLogsAffected?: ActivityLogOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    uploadedFiles?: AttachmentOrderByRelationAggregateInput
    createdRules?: AutomationRuleOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    commentMentions?: CommentMentionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    projectNotificationPreferences?: ProjectNotificationPreferenceOrderByRelationAggregateInput
    projectNotifications?: ProjectNotificationOrderByRelationAggregateInput
    projectSettingsUpdated?: ProjectSettingOrderByRelationAggregateInput
    projectSettingsChanged?: ProjectSettingsChangeLogOrderByRelationAggregateInput
    projectsManaged?: ProjectOrderByRelationAggregateInput
    projectsMarkedUrgent?: ProjectOrderByRelationAggregateInput
    settingsChanged?: SettingsChangeLogOrderByRelationAggregateInput
    createdSubtasks?: SubtaskOrderByRelationAggregateInput
    assignedSubtasks?: SubtaskOrderByRelationAggregateInput
    updatedSettings?: SystemSettingOrderByRelationAggregateInput
    tasksCreated?: TaskOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    userSettingsUpdated?: UserSettingOrderByRelationAggregateInput
    userSettings?: UserSettingOrderByRelationAggregateInput
    userSettingsChanged?: UserSettingsChangeLogOrderByRelationAggregateInput
    userSettingsChangeLogs?: UserSettingsChangeLogOrderByRelationAggregateInput
    team?: TeamOrderByWithRelationInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    teamsLed?: TeamOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    assignedRoles?: UserRoleOrderByRelationAggregateInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    activityLogsPerformed?: ActivityLogListRelationFilter
    activityLogsAffected?: ActivityLogListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    uploadedFiles?: AttachmentListRelationFilter
    createdRules?: AutomationRuleListRelationFilter
    comments?: CommentListRelationFilter
    commentMentions?: CommentMentionListRelationFilter
    notifications?: NotificationListRelationFilter
    projectNotificationPreferences?: ProjectNotificationPreferenceListRelationFilter
    projectNotifications?: ProjectNotificationListRelationFilter
    projectSettingsUpdated?: ProjectSettingListRelationFilter
    projectSettingsChanged?: ProjectSettingsChangeLogListRelationFilter
    projectsManaged?: ProjectListRelationFilter
    projectsMarkedUrgent?: ProjectListRelationFilter
    settingsChanged?: SettingsChangeLogListRelationFilter
    createdSubtasks?: SubtaskListRelationFilter
    assignedSubtasks?: SubtaskListRelationFilter
    updatedSettings?: SystemSettingListRelationFilter
    tasksCreated?: TaskListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    userSettingsUpdated?: UserSettingListRelationFilter
    userSettings?: UserSettingListRelationFilter
    userSettingsChanged?: UserSettingsChangeLogListRelationFilter
    userSettingsChangeLogs?: UserSettingsChangeLogListRelationFilter
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    assignedTasks?: TaskListRelationFilter
    teamsLed?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    roles?: UserRoleListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    urgentAcknowledgements?: UrgentProjectAcknowledgementListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    teamId?: IntNullableWithAggregatesFilter<"User"> | number | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    teamLeadId?: IntNullableFilter<"Team"> | number | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    rules?: AutomationRuleListRelationFilter
    subtasks?: SubtaskListRelationFilter
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
    teamLead?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    members?: TeamMemberListRelationFilter
    projectTeams?: ProjectTeamListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamLeadId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rules?: AutomationRuleOrderByRelationAggregateInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    teamLead?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
    projectTeams?: ProjectTeamOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    teamLeadId?: IntNullableFilter<"Team"> | number | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    rules?: AutomationRuleListRelationFilter
    subtasks?: SubtaskListRelationFilter
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
    teamLead?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    members?: TeamMemberListRelationFilter
    projectTeams?: ProjectTeamListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    teamLeadId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    teamLeadId?: IntNullableWithAggregatesFilter<"Team"> | number | null
    status?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    type?: StringFilter<"Project"> | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
    projectStatusId?: IntNullableFilter<"Project"> | number | null
    description?: StringNullableFilter<"Project"> | string | null
    scope?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    priority?: StringFilter<"Project"> | string
    urgentReason?: StringNullableFilter<"Project"> | string | null
    urgentMarkedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    urgentMarkedById?: IntNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    projectManagerId?: IntNullableFilter<"Project"> | number | null
    createdById?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deliverables?: DeliverableListRelationFilter
    notificationPreferences?: ProjectNotificationPreferenceListRelationFilter
    notifications?: ProjectNotificationListRelationFilter
    phases?: ProjectPhaseListRelationFilter
    settings?: ProjectSettingListRelationFilter
    settingsLogs?: ProjectSettingsChangeLogListRelationFilter
    projectUsers?: ProjectUserListRelationFilter
    projectManager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    urgentMarkedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    projectType?: XOR<ProjectTypeNullableRelationFilter, ProjectTypeWhereInput> | null
    projectStatus?: XOR<ProjectStatusNullableRelationFilter, ProjectStatusWhereInput> | null
    scopeHistory?: ScopeHistoryListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    projectTeams?: ProjectTeamListRelationFilter
    urgentAcknowledgments?: UrgentProjectAcknowledgementListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    projectTypeId?: SortOrderInput | SortOrder
    projectStatusId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    urgentReason?: SortOrderInput | SortOrder
    urgentMarkedAt?: SortOrderInput | SortOrder
    urgentMarkedById?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deliverables?: DeliverableOrderByRelationAggregateInput
    notificationPreferences?: ProjectNotificationPreferenceOrderByRelationAggregateInput
    notifications?: ProjectNotificationOrderByRelationAggregateInput
    phases?: ProjectPhaseOrderByRelationAggregateInput
    settings?: ProjectSettingOrderByRelationAggregateInput
    settingsLogs?: ProjectSettingsChangeLogOrderByRelationAggregateInput
    projectUsers?: ProjectUserOrderByRelationAggregateInput
    projectManager?: UserOrderByWithRelationInput
    urgentMarkedBy?: UserOrderByWithRelationInput
    projectType?: ProjectTypeOrderByWithRelationInput
    projectStatus?: ProjectStatusOrderByWithRelationInput
    scopeHistory?: ScopeHistoryOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    projectTeams?: ProjectTeamOrderByRelationAggregateInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    type?: StringFilter<"Project"> | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
    projectStatusId?: IntNullableFilter<"Project"> | number | null
    description?: StringNullableFilter<"Project"> | string | null
    scope?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    priority?: StringFilter<"Project"> | string
    urgentReason?: StringNullableFilter<"Project"> | string | null
    urgentMarkedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    urgentMarkedById?: IntNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    projectManagerId?: IntNullableFilter<"Project"> | number | null
    createdById?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    deliverables?: DeliverableListRelationFilter
    notificationPreferences?: ProjectNotificationPreferenceListRelationFilter
    notifications?: ProjectNotificationListRelationFilter
    phases?: ProjectPhaseListRelationFilter
    settings?: ProjectSettingListRelationFilter
    settingsLogs?: ProjectSettingsChangeLogListRelationFilter
    projectUsers?: ProjectUserListRelationFilter
    projectManager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    urgentMarkedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    projectType?: XOR<ProjectTypeNullableRelationFilter, ProjectTypeWhereInput> | null
    projectStatus?: XOR<ProjectStatusNullableRelationFilter, ProjectStatusWhereInput> | null
    scopeHistory?: ScopeHistoryListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    projectTeams?: ProjectTeamListRelationFilter
    urgentAcknowledgments?: UrgentProjectAcknowledgementListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    projectTypeId?: SortOrderInput | SortOrder
    projectStatusId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    urgentReason?: SortOrderInput | SortOrder
    urgentMarkedAt?: SortOrderInput | SortOrder
    urgentMarkedById?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    name?: StringWithAggregatesFilter<"Project"> | string
    type?: StringWithAggregatesFilter<"Project"> | string
    projectTypeId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    projectStatusId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    priority?: StringWithAggregatesFilter<"Project"> | string
    urgentReason?: StringNullableWithAggregatesFilter<"Project"> | string | null
    urgentMarkedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    urgentMarkedById?: IntNullableWithAggregatesFilter<"Project"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    projectManagerId?: IntNullableWithAggregatesFilter<"Project"> | number | null
    createdById?: IntNullableWithAggregatesFilter<"Project"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    taskStatusId?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatFilter<"Task"> | number
    actualHours?: FloatFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    projectId?: IntFilter<"Task"> | number
    teamId?: IntNullableFilter<"Task"> | number | null
    createdById?: IntNullableFilter<"Task"> | number | null
    deliverableId?: IntNullableFilter<"Task"> | number | null
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    subtasks?: SubtaskListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    dependencies?: TaskDependencyListRelationFilter
    labels?: TaskLabelListRelationFilter
    deliverable?: XOR<DeliverableNullableRelationFilter, DeliverableWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    taskStatus?: XOR<TaskStatusNullableRelationFilter, TaskStatusWhereInput> | null
    timeLogs?: TimeLogListRelationFilter
    assignees?: UserListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    taskStatusId?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    deliverableId?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    attachments?: AttachmentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    subtasks?: SubtaskOrderByRelationAggregateInput
    dependents?: TaskDependencyOrderByRelationAggregateInput
    dependencies?: TaskDependencyOrderByRelationAggregateInput
    labels?: TaskLabelOrderByRelationAggregateInput
    deliverable?: DeliverableOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    taskStatus?: TaskStatusOrderByWithRelationInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    assignees?: UserOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    taskStatusId?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatFilter<"Task"> | number
    actualHours?: FloatFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    projectId?: IntFilter<"Task"> | number
    teamId?: IntNullableFilter<"Task"> | number | null
    createdById?: IntNullableFilter<"Task"> | number | null
    deliverableId?: IntNullableFilter<"Task"> | number | null
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    attachments?: AttachmentListRelationFilter
    comments?: CommentListRelationFilter
    subtasks?: SubtaskListRelationFilter
    dependents?: TaskDependencyListRelationFilter
    dependencies?: TaskDependencyListRelationFilter
    labels?: TaskLabelListRelationFilter
    deliverable?: XOR<DeliverableNullableRelationFilter, DeliverableWhereInput> | null
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    taskStatus?: XOR<TaskStatusNullableRelationFilter, TaskStatusWhereInput> | null
    timeLogs?: TimeLogListRelationFilter
    assignees?: UserListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    taskStatusId?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    deliverableId?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    taskStatusId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    priority?: StringWithAggregatesFilter<"Task"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    plannedDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    estimatedHours?: FloatWithAggregatesFilter<"Task"> | number
    actualHours?: FloatWithAggregatesFilter<"Task"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    projectId?: IntWithAggregatesFilter<"Task"> | number
    teamId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    createdById?: IntNullableWithAggregatesFilter<"Task"> | number | null
    deliverableId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
  }

  export type SubtaskWhereInput = {
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    id?: IntFilter<"Subtask"> | number
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: StringFilter<"Subtask"> | string
    priority?: StringFilter<"Subtask"> | string
    startDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    estimatedHours?: FloatFilter<"Subtask"> | number
    actualHours?: FloatFilter<"Subtask"> | number
    parentTaskId?: IntFilter<"Subtask"> | number
    assignedToId?: IntNullableFilter<"Subtask"> | number | null
    teamId?: IntNullableFilter<"Subtask"> | number | null
    createdById?: IntFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    comments?: CommentListRelationFilter
    dependencies?: SubtaskDependencyListRelationFilter
    dependents?: SubtaskDependencyListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    parentTask?: XOR<TaskRelationFilter, TaskWhereInput>
    timeLogs?: TimeLogListRelationFilter
  }

  export type SubtaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    dependencies?: SubtaskDependencyOrderByRelationAggregateInput
    dependents?: SubtaskDependencyOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    parentTask?: TaskOrderByWithRelationInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
  }

  export type SubtaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubtaskWhereInput | SubtaskWhereInput[]
    OR?: SubtaskWhereInput[]
    NOT?: SubtaskWhereInput | SubtaskWhereInput[]
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: StringFilter<"Subtask"> | string
    priority?: StringFilter<"Subtask"> | string
    startDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    estimatedHours?: FloatFilter<"Subtask"> | number
    actualHours?: FloatFilter<"Subtask"> | number
    parentTaskId?: IntFilter<"Subtask"> | number
    assignedToId?: IntNullableFilter<"Subtask"> | number | null
    teamId?: IntNullableFilter<"Subtask"> | number | null
    createdById?: IntFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
    comments?: CommentListRelationFilter
    dependencies?: SubtaskDependencyListRelationFilter
    dependents?: SubtaskDependencyListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    parentTask?: XOR<TaskRelationFilter, TaskWhereInput>
    timeLogs?: TimeLogListRelationFilter
  }, "id">

  export type SubtaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubtaskCountOrderByAggregateInput
    _avg?: SubtaskAvgOrderByAggregateInput
    _max?: SubtaskMaxOrderByAggregateInput
    _min?: SubtaskMinOrderByAggregateInput
    _sum?: SubtaskSumOrderByAggregateInput
  }

  export type SubtaskScalarWhereWithAggregatesInput = {
    AND?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    OR?: SubtaskScalarWhereWithAggregatesInput[]
    NOT?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subtask"> | number
    title?: StringWithAggregatesFilter<"Subtask"> | string
    description?: StringNullableWithAggregatesFilter<"Subtask"> | string | null
    status?: StringWithAggregatesFilter<"Subtask"> | string
    priority?: StringWithAggregatesFilter<"Subtask"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Subtask"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Subtask"> | Date | string | null
    estimatedHours?: FloatWithAggregatesFilter<"Subtask"> | number
    actualHours?: FloatWithAggregatesFilter<"Subtask"> | number
    parentTaskId?: IntWithAggregatesFilter<"Subtask"> | number
    assignedToId?: IntNullableWithAggregatesFilter<"Subtask"> | number | null
    teamId?: IntNullableWithAggregatesFilter<"Subtask"> | number | null
    createdById?: IntWithAggregatesFilter<"Subtask"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subtask"> | Date | string
  }

  export type SubtaskDependencyWhereInput = {
    AND?: SubtaskDependencyWhereInput | SubtaskDependencyWhereInput[]
    OR?: SubtaskDependencyWhereInput[]
    NOT?: SubtaskDependencyWhereInput | SubtaskDependencyWhereInput[]
    subtaskId?: IntFilter<"SubtaskDependency"> | number
    dependsOnSubtaskId?: IntFilter<"SubtaskDependency"> | number
    dependencyType?: StringFilter<"SubtaskDependency"> | string
    createdById?: IntFilter<"SubtaskDependency"> | number
    createdAt?: DateTimeFilter<"SubtaskDependency"> | Date | string
    dependsOnSubtask?: XOR<SubtaskRelationFilter, SubtaskWhereInput>
    subtask?: XOR<SubtaskRelationFilter, SubtaskWhereInput>
  }

  export type SubtaskDependencyOrderByWithRelationInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    dependsOnSubtask?: SubtaskOrderByWithRelationInput
    subtask?: SubtaskOrderByWithRelationInput
  }

  export type SubtaskDependencyWhereUniqueInput = Prisma.AtLeast<{
    subtaskId_dependsOnSubtaskId?: SubtaskDependencySubtaskIdDependsOnSubtaskIdCompoundUniqueInput
    AND?: SubtaskDependencyWhereInput | SubtaskDependencyWhereInput[]
    OR?: SubtaskDependencyWhereInput[]
    NOT?: SubtaskDependencyWhereInput | SubtaskDependencyWhereInput[]
    subtaskId?: IntFilter<"SubtaskDependency"> | number
    dependsOnSubtaskId?: IntFilter<"SubtaskDependency"> | number
    dependencyType?: StringFilter<"SubtaskDependency"> | string
    createdById?: IntFilter<"SubtaskDependency"> | number
    createdAt?: DateTimeFilter<"SubtaskDependency"> | Date | string
    dependsOnSubtask?: XOR<SubtaskRelationFilter, SubtaskWhereInput>
    subtask?: XOR<SubtaskRelationFilter, SubtaskWhereInput>
  }, "subtaskId_dependsOnSubtaskId">

  export type SubtaskDependencyOrderByWithAggregationInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: SubtaskDependencyCountOrderByAggregateInput
    _avg?: SubtaskDependencyAvgOrderByAggregateInput
    _max?: SubtaskDependencyMaxOrderByAggregateInput
    _min?: SubtaskDependencyMinOrderByAggregateInput
    _sum?: SubtaskDependencySumOrderByAggregateInput
  }

  export type SubtaskDependencyScalarWhereWithAggregatesInput = {
    AND?: SubtaskDependencyScalarWhereWithAggregatesInput | SubtaskDependencyScalarWhereWithAggregatesInput[]
    OR?: SubtaskDependencyScalarWhereWithAggregatesInput[]
    NOT?: SubtaskDependencyScalarWhereWithAggregatesInput | SubtaskDependencyScalarWhereWithAggregatesInput[]
    subtaskId?: IntWithAggregatesFilter<"SubtaskDependency"> | number
    dependsOnSubtaskId?: IntWithAggregatesFilter<"SubtaskDependency"> | number
    dependencyType?: StringWithAggregatesFilter<"SubtaskDependency"> | string
    createdById?: IntWithAggregatesFilter<"SubtaskDependency"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SubtaskDependency"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    taskId?: IntNullableFilter<"Comment"> | number | null
    subtaskId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
    author?: XOR<UserRelationFilter, UserWhereInput>
    subtask?: XOR<SubtaskNullableRelationFilter, SubtaskWhereInput> | null
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    mentions?: CommentMentionListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrderInput | SortOrder
    subtaskId?: SortOrderInput | SortOrder
    userId?: SortOrder
    author?: UserOrderByWithRelationInput
    subtask?: SubtaskOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    mentions?: CommentMentionOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    taskId?: IntNullableFilter<"Comment"> | number | null
    subtaskId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
    author?: XOR<UserRelationFilter, UserWhereInput>
    subtask?: XOR<SubtaskNullableRelationFilter, SubtaskWhereInput> | null
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    mentions?: CommentMentionListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrderInput | SortOrder
    subtaskId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    taskId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    subtaskId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    userId?: IntWithAggregatesFilter<"Comment"> | number
  }

  export type CommentMentionWhereInput = {
    AND?: CommentMentionWhereInput | CommentMentionWhereInput[]
    OR?: CommentMentionWhereInput[]
    NOT?: CommentMentionWhereInput | CommentMentionWhereInput[]
    id?: IntFilter<"CommentMention"> | number
    commentId?: IntFilter<"CommentMention"> | number
    userId?: IntFilter<"CommentMention"> | number
    createdAt?: DateTimeFilter<"CommentMention"> | Date | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentMentionOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentMentionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    commentId_userId?: CommentMentionCommentIdUserIdCompoundUniqueInput
    AND?: CommentMentionWhereInput | CommentMentionWhereInput[]
    OR?: CommentMentionWhereInput[]
    NOT?: CommentMentionWhereInput | CommentMentionWhereInput[]
    commentId?: IntFilter<"CommentMention"> | number
    userId?: IntFilter<"CommentMention"> | number
    createdAt?: DateTimeFilter<"CommentMention"> | Date | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "commentId_userId">

  export type CommentMentionOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: CommentMentionCountOrderByAggregateInput
    _avg?: CommentMentionAvgOrderByAggregateInput
    _max?: CommentMentionMaxOrderByAggregateInput
    _min?: CommentMentionMinOrderByAggregateInput
    _sum?: CommentMentionSumOrderByAggregateInput
  }

  export type CommentMentionScalarWhereWithAggregatesInput = {
    AND?: CommentMentionScalarWhereWithAggregatesInput | CommentMentionScalarWhereWithAggregatesInput[]
    OR?: CommentMentionScalarWhereWithAggregatesInput[]
    NOT?: CommentMentionScalarWhereWithAggregatesInput | CommentMentionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommentMention"> | number
    commentId?: IntWithAggregatesFilter<"CommentMention"> | number
    userId?: IntWithAggregatesFilter<"CommentMention"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CommentMention"> | Date | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: IntFilter<"Label"> | number
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    createdAt?: DateTimeFilter<"Label"> | Date | string
    tasks?: TaskLabelListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tasks?: TaskLabelOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    color?: StringFilter<"Label"> | string
    description?: StringNullableFilter<"Label"> | string | null
    createdAt?: DateTimeFilter<"Label"> | Date | string
    tasks?: TaskLabelListRelationFilter
  }, "id" | "name">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _avg?: LabelAvgOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
    _sum?: LabelSumOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Label"> | number
    name?: StringWithAggregatesFilter<"Label"> | string
    color?: StringWithAggregatesFilter<"Label"> | string
    description?: StringNullableWithAggregatesFilter<"Label"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
  }

  export type TaskLabelWhereInput = {
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: IntFilter<"TaskLabel"> | number
    labelId?: IntFilter<"TaskLabel"> | number
    createdAt?: DateTimeFilter<"TaskLabel"> | Date | string
    label?: XOR<LabelRelationFilter, LabelWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskLabelOrderByWithRelationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    createdAt?: SortOrder
    label?: LabelOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskLabelWhereUniqueInput = Prisma.AtLeast<{
    taskId_labelId?: TaskLabelTaskIdLabelIdCompoundUniqueInput
    AND?: TaskLabelWhereInput | TaskLabelWhereInput[]
    OR?: TaskLabelWhereInput[]
    NOT?: TaskLabelWhereInput | TaskLabelWhereInput[]
    taskId?: IntFilter<"TaskLabel"> | number
    labelId?: IntFilter<"TaskLabel"> | number
    createdAt?: DateTimeFilter<"TaskLabel"> | Date | string
    label?: XOR<LabelRelationFilter, LabelWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "taskId_labelId">

  export type TaskLabelOrderByWithAggregationInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    createdAt?: SortOrder
    _count?: TaskLabelCountOrderByAggregateInput
    _avg?: TaskLabelAvgOrderByAggregateInput
    _max?: TaskLabelMaxOrderByAggregateInput
    _min?: TaskLabelMinOrderByAggregateInput
    _sum?: TaskLabelSumOrderByAggregateInput
  }

  export type TaskLabelScalarWhereWithAggregatesInput = {
    AND?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    OR?: TaskLabelScalarWhereWithAggregatesInput[]
    NOT?: TaskLabelScalarWhereWithAggregatesInput | TaskLabelScalarWhereWithAggregatesInput[]
    taskId?: IntWithAggregatesFilter<"TaskLabel"> | number
    labelId?: IntWithAggregatesFilter<"TaskLabel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaskLabel"> | Date | string
  }

  export type TaskDependencyWhereInput = {
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    taskId?: IntFilter<"TaskDependency"> | number
    dependsOnTaskId?: IntFilter<"TaskDependency"> | number
    dependencyType?: StringFilter<"TaskDependency"> | string
    createdById?: IntFilter<"TaskDependency"> | number
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
    dependsOnTask?: XOR<TaskRelationFilter, TaskWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskDependencyOrderByWithRelationInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    dependsOnTask?: TaskOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskDependencyWhereUniqueInput = Prisma.AtLeast<{
    taskId_dependsOnTaskId?: TaskDependencyTaskIdDependsOnTaskIdCompoundUniqueInput
    AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    OR?: TaskDependencyWhereInput[]
    NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[]
    taskId?: IntFilter<"TaskDependency"> | number
    dependsOnTaskId?: IntFilter<"TaskDependency"> | number
    dependencyType?: StringFilter<"TaskDependency"> | string
    createdById?: IntFilter<"TaskDependency"> | number
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
    dependsOnTask?: XOR<TaskRelationFilter, TaskWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "taskId_dependsOnTaskId">

  export type TaskDependencyOrderByWithAggregationInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: TaskDependencyCountOrderByAggregateInput
    _avg?: TaskDependencyAvgOrderByAggregateInput
    _max?: TaskDependencyMaxOrderByAggregateInput
    _min?: TaskDependencyMinOrderByAggregateInput
    _sum?: TaskDependencySumOrderByAggregateInput
  }

  export type TaskDependencyScalarWhereWithAggregatesInput = {
    AND?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    OR?: TaskDependencyScalarWhereWithAggregatesInput[]
    NOT?: TaskDependencyScalarWhereWithAggregatesInput | TaskDependencyScalarWhereWithAggregatesInput[]
    taskId?: IntWithAggregatesFilter<"TaskDependency"> | number
    dependsOnTaskId?: IntWithAggregatesFilter<"TaskDependency"> | number
    dependencyType?: StringWithAggregatesFilter<"TaskDependency"> | string
    createdById?: IntWithAggregatesFilter<"TaskDependency"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaskDependency"> | Date | string
  }

  export type TimeLogWhereInput = {
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    id?: IntFilter<"TimeLog"> | number
    hoursLogged?: FloatFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    userId?: IntFilter<"TimeLog"> | number
    taskId?: IntNullableFilter<"TimeLog"> | number | null
    subtaskId?: IntNullableFilter<"TimeLog"> | number | null
    subtask?: XOR<SubtaskNullableRelationFilter, SubtaskWhereInput> | null
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TimeLogOrderByWithRelationInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    description?: SortOrderInput | SortOrder
    logDate?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    subtaskId?: SortOrderInput | SortOrder
    subtask?: SubtaskOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    hoursLogged?: FloatFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    userId?: IntFilter<"TimeLog"> | number
    taskId?: IntNullableFilter<"TimeLog"> | number | null
    subtaskId?: IntNullableFilter<"TimeLog"> | number | null
    subtask?: XOR<SubtaskNullableRelationFilter, SubtaskWhereInput> | null
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    description?: SortOrderInput | SortOrder
    logDate?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    taskId?: SortOrderInput | SortOrder
    subtaskId?: SortOrderInput | SortOrder
    _count?: TimeLogCountOrderByAggregateInput
    _avg?: TimeLogAvgOrderByAggregateInput
    _max?: TimeLogMaxOrderByAggregateInput
    _min?: TimeLogMinOrderByAggregateInput
    _sum?: TimeLogSumOrderByAggregateInput
  }

  export type TimeLogScalarWhereWithAggregatesInput = {
    AND?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    OR?: TimeLogScalarWhereWithAggregatesInput[]
    NOT?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TimeLog"> | number
    hoursLogged?: FloatWithAggregatesFilter<"TimeLog"> | number
    description?: StringNullableWithAggregatesFilter<"TimeLog"> | string | null
    logDate?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    userId?: IntWithAggregatesFilter<"TimeLog"> | number
    taskId?: IntNullableWithAggregatesFilter<"TimeLog"> | number | null
    subtaskId?: IntNullableWithAggregatesFilter<"TimeLog"> | number | null
  }

  export type AutomationRuleWhereInput = {
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    id?: IntFilter<"AutomationRule"> | number
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: StringFilter<"AutomationRule"> | string
    triggerCondition?: StringNullableFilter<"AutomationRule"> | string | null
    actionType?: StringFilter<"AutomationRule"> | string
    actionConfig?: StringNullableFilter<"AutomationRule"> | string | null
    isActive?: BoolFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    createdById?: IntFilter<"AutomationRule"> | number
    teamId?: IntNullableFilter<"AutomationRule"> | number | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AutomationRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerCondition?: SortOrderInput | SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type AutomationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    OR?: AutomationRuleWhereInput[]
    NOT?: AutomationRuleWhereInput | AutomationRuleWhereInput[]
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: StringFilter<"AutomationRule"> | string
    triggerCondition?: StringNullableFilter<"AutomationRule"> | string | null
    actionType?: StringFilter<"AutomationRule"> | string
    actionConfig?: StringNullableFilter<"AutomationRule"> | string | null
    isActive?: BoolFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    createdById?: IntFilter<"AutomationRule"> | number
    teamId?: IntNullableFilter<"AutomationRule"> | number | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AutomationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerCondition?: SortOrderInput | SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrderInput | SortOrder
    _count?: AutomationRuleCountOrderByAggregateInput
    _avg?: AutomationRuleAvgOrderByAggregateInput
    _max?: AutomationRuleMaxOrderByAggregateInput
    _min?: AutomationRuleMinOrderByAggregateInput
    _sum?: AutomationRuleSumOrderByAggregateInput
  }

  export type AutomationRuleScalarWhereWithAggregatesInput = {
    AND?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    OR?: AutomationRuleScalarWhereWithAggregatesInput[]
    NOT?: AutomationRuleScalarWhereWithAggregatesInput | AutomationRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AutomationRule"> | number
    name?: StringWithAggregatesFilter<"AutomationRule"> | string
    description?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    triggerType?: StringWithAggregatesFilter<"AutomationRule"> | string
    triggerCondition?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    actionType?: StringWithAggregatesFilter<"AutomationRule"> | string
    actionConfig?: StringNullableWithAggregatesFilter<"AutomationRule"> | string | null
    isActive?: BoolWithAggregatesFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AutomationRule"> | Date | string
    createdById?: IntWithAggregatesFilter<"AutomationRule"> | number
    teamId?: IntNullableWithAggregatesFilter<"AutomationRule"> | number | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: IntWithAggregatesFilter<"Notification"> | number
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    actionType?: StringNullableFilter<"ActivityLog"> | string | null
    actionCategory?: StringNullableFilter<"ActivityLog"> | string | null
    actionSummary?: StringNullableFilter<"ActivityLog"> | string | null
    actionDetails?: StringNullableFilter<"ActivityLog"> | string | null
    performedById?: IntNullableFilter<"ActivityLog"> | number | null
    affectedUserId?: IntNullableFilter<"ActivityLog"> | number | null
    projectId?: IntNullableFilter<"ActivityLog"> | number | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    entityId?: IntNullableFilter<"ActivityLog"> | number | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    action?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    performedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    affectedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionCategory?: SortOrderInput | SortOrder
    actionSummary?: SortOrderInput | SortOrder
    actionDetails?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    affectedUserId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    action?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    performedBy?: UserOrderByWithRelationInput
    affectedUser?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    actionType?: StringNullableFilter<"ActivityLog"> | string | null
    actionCategory?: StringNullableFilter<"ActivityLog"> | string | null
    actionSummary?: StringNullableFilter<"ActivityLog"> | string | null
    actionDetails?: StringNullableFilter<"ActivityLog"> | string | null
    performedById?: IntNullableFilter<"ActivityLog"> | number | null
    affectedUserId?: IntNullableFilter<"ActivityLog"> | number | null
    projectId?: IntNullableFilter<"ActivityLog"> | number | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    entityId?: IntNullableFilter<"ActivityLog"> | number | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    action?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    performedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    affectedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    actionType?: SortOrderInput | SortOrder
    actionCategory?: SortOrderInput | SortOrder
    actionSummary?: SortOrderInput | SortOrder
    actionDetails?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    affectedUserId?: SortOrderInput | SortOrder
    projectId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    action?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    actionType?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    actionCategory?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    actionSummary?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    actionDetails?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    performedById?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    affectedUserId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    projectId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    entityType?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    entityId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    action?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    description?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
  }

  export type ProjectUserWhereInput = {
    AND?: ProjectUserWhereInput | ProjectUserWhereInput[]
    OR?: ProjectUserWhereInput[]
    NOT?: ProjectUserWhereInput | ProjectUserWhereInput[]
    id?: IntFilter<"ProjectUser"> | number
    projectId?: IntFilter<"ProjectUser"> | number
    userId?: IntFilter<"ProjectUser"> | number
    role?: StringFilter<"ProjectUser"> | string
    allocationPercentage?: IntFilter<"ProjectUser"> | number
    joinedAt?: DateTimeFilter<"ProjectUser"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectUser"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectUser"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectUserOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    allocationPercentage?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId_joinedAt?: ProjectUserProjectIdUserIdJoinedAtCompoundUniqueInput
    AND?: ProjectUserWhereInput | ProjectUserWhereInput[]
    OR?: ProjectUserWhereInput[]
    NOT?: ProjectUserWhereInput | ProjectUserWhereInput[]
    projectId?: IntFilter<"ProjectUser"> | number
    userId?: IntFilter<"ProjectUser"> | number
    role?: StringFilter<"ProjectUser"> | string
    allocationPercentage?: IntFilter<"ProjectUser"> | number
    joinedAt?: DateTimeFilter<"ProjectUser"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectUser"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectUser"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_userId_joinedAt">

  export type ProjectUserOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    allocationPercentage?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProjectUserCountOrderByAggregateInput
    _avg?: ProjectUserAvgOrderByAggregateInput
    _max?: ProjectUserMaxOrderByAggregateInput
    _min?: ProjectUserMinOrderByAggregateInput
    _sum?: ProjectUserSumOrderByAggregateInput
  }

  export type ProjectUserScalarWhereWithAggregatesInput = {
    AND?: ProjectUserScalarWhereWithAggregatesInput | ProjectUserScalarWhereWithAggregatesInput[]
    OR?: ProjectUserScalarWhereWithAggregatesInput[]
    NOT?: ProjectUserScalarWhereWithAggregatesInput | ProjectUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectUser"> | number
    projectId?: IntWithAggregatesFilter<"ProjectUser"> | number
    userId?: IntWithAggregatesFilter<"ProjectUser"> | number
    role?: StringWithAggregatesFilter<"ProjectUser"> | string
    allocationPercentage?: IntWithAggregatesFilter<"ProjectUser"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectUser"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"ProjectUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectUser"> | Date | string
  }

  export type ProjectPhaseWhereInput = {
    AND?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    OR?: ProjectPhaseWhereInput[]
    NOT?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    id?: IntFilter<"ProjectPhase"> | number
    projectId?: IntFilter<"ProjectPhase"> | number
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    sequenceOrder?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectPhaseOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sequenceOrder?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    OR?: ProjectPhaseWhereInput[]
    NOT?: ProjectPhaseWhereInput | ProjectPhaseWhereInput[]
    projectId?: IntFilter<"ProjectPhase"> | number
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    sequenceOrder?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    sequenceOrder?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectPhaseCountOrderByAggregateInput
    _avg?: ProjectPhaseAvgOrderByAggregateInput
    _max?: ProjectPhaseMaxOrderByAggregateInput
    _min?: ProjectPhaseMinOrderByAggregateInput
    _sum?: ProjectPhaseSumOrderByAggregateInput
  }

  export type ProjectPhaseScalarWhereWithAggregatesInput = {
    AND?: ProjectPhaseScalarWhereWithAggregatesInput | ProjectPhaseScalarWhereWithAggregatesInput[]
    OR?: ProjectPhaseScalarWhereWithAggregatesInput[]
    NOT?: ProjectPhaseScalarWhereWithAggregatesInput | ProjectPhaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectPhase"> | number
    projectId?: IntWithAggregatesFilter<"ProjectPhase"> | number
    name?: StringWithAggregatesFilter<"ProjectPhase"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectPhase"> | string | null
    sequenceOrder?: IntWithAggregatesFilter<"ProjectPhase"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"ProjectPhase"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ProjectPhase"> | Date | string | null
    status?: StringWithAggregatesFilter<"ProjectPhase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectPhase"> | Date | string
  }

  export type DeliverableWhereInput = {
    AND?: DeliverableWhereInput | DeliverableWhereInput[]
    OR?: DeliverableWhereInput[]
    NOT?: DeliverableWhereInput | DeliverableWhereInput[]
    id?: IntFilter<"Deliverable"> | number
    projectId?: IntFilter<"Deliverable"> | number
    name?: StringFilter<"Deliverable"> | string
    description?: StringNullableFilter<"Deliverable"> | string | null
    acceptanceCriteria?: StringNullableFilter<"Deliverable"> | string | null
    status?: StringFilter<"Deliverable"> | string
    createdAt?: DateTimeFilter<"Deliverable"> | Date | string
    updatedAt?: DateTimeFilter<"Deliverable"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }

  export type DeliverableOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    acceptanceCriteria?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type DeliverableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeliverableWhereInput | DeliverableWhereInput[]
    OR?: DeliverableWhereInput[]
    NOT?: DeliverableWhereInput | DeliverableWhereInput[]
    projectId?: IntFilter<"Deliverable"> | number
    name?: StringFilter<"Deliverable"> | string
    description?: StringNullableFilter<"Deliverable"> | string | null
    acceptanceCriteria?: StringNullableFilter<"Deliverable"> | string | null
    status?: StringFilter<"Deliverable"> | string
    createdAt?: DateTimeFilter<"Deliverable"> | Date | string
    updatedAt?: DateTimeFilter<"Deliverable"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
  }, "id">

  export type DeliverableOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    acceptanceCriteria?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliverableCountOrderByAggregateInput
    _avg?: DeliverableAvgOrderByAggregateInput
    _max?: DeliverableMaxOrderByAggregateInput
    _min?: DeliverableMinOrderByAggregateInput
    _sum?: DeliverableSumOrderByAggregateInput
  }

  export type DeliverableScalarWhereWithAggregatesInput = {
    AND?: DeliverableScalarWhereWithAggregatesInput | DeliverableScalarWhereWithAggregatesInput[]
    OR?: DeliverableScalarWhereWithAggregatesInput[]
    NOT?: DeliverableScalarWhereWithAggregatesInput | DeliverableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Deliverable"> | number
    projectId?: IntWithAggregatesFilter<"Deliverable"> | number
    name?: StringWithAggregatesFilter<"Deliverable"> | string
    description?: StringNullableWithAggregatesFilter<"Deliverable"> | string | null
    acceptanceCriteria?: StringNullableWithAggregatesFilter<"Deliverable"> | string | null
    status?: StringWithAggregatesFilter<"Deliverable"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Deliverable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deliverable"> | Date | string
  }

  export type ScopeHistoryWhereInput = {
    AND?: ScopeHistoryWhereInput | ScopeHistoryWhereInput[]
    OR?: ScopeHistoryWhereInput[]
    NOT?: ScopeHistoryWhereInput | ScopeHistoryWhereInput[]
    id?: IntFilter<"ScopeHistory"> | number
    projectId?: IntFilter<"ScopeHistory"> | number
    scopeText?: StringFilter<"ScopeHistory"> | string
    changeReason?: StringNullableFilter<"ScopeHistory"> | string | null
    changedById?: IntFilter<"ScopeHistory"> | number
    createdAt?: DateTimeFilter<"ScopeHistory"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ScopeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    scopeText?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ScopeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScopeHistoryWhereInput | ScopeHistoryWhereInput[]
    OR?: ScopeHistoryWhereInput[]
    NOT?: ScopeHistoryWhereInput | ScopeHistoryWhereInput[]
    projectId?: IntFilter<"ScopeHistory"> | number
    scopeText?: StringFilter<"ScopeHistory"> | string
    changeReason?: StringNullableFilter<"ScopeHistory"> | string | null
    changedById?: IntFilter<"ScopeHistory"> | number
    createdAt?: DateTimeFilter<"ScopeHistory"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ScopeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    scopeText?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
    _count?: ScopeHistoryCountOrderByAggregateInput
    _avg?: ScopeHistoryAvgOrderByAggregateInput
    _max?: ScopeHistoryMaxOrderByAggregateInput
    _min?: ScopeHistoryMinOrderByAggregateInput
    _sum?: ScopeHistorySumOrderByAggregateInput
  }

  export type ScopeHistoryScalarWhereWithAggregatesInput = {
    AND?: ScopeHistoryScalarWhereWithAggregatesInput | ScopeHistoryScalarWhereWithAggregatesInput[]
    OR?: ScopeHistoryScalarWhereWithAggregatesInput[]
    NOT?: ScopeHistoryScalarWhereWithAggregatesInput | ScopeHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScopeHistory"> | number
    projectId?: IntWithAggregatesFilter<"ScopeHistory"> | number
    scopeText?: StringWithAggregatesFilter<"ScopeHistory"> | string
    changeReason?: StringNullableWithAggregatesFilter<"ScopeHistory"> | string | null
    changedById?: IntWithAggregatesFilter<"ScopeHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ScopeHistory"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: IntFilter<"Attachment"> | number
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: IntNullableFilter<"Attachment"> | number | null
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
    taskId?: IntNullableFilter<"Attachment"> | number | null
    uploadedById?: IntFilter<"Attachment"> | number
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    taskId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    uploader?: UserOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: IntNullableFilter<"Attachment"> | number | null
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
    taskId?: IntNullableFilter<"Attachment"> | number | null
    uploadedById?: IntFilter<"Attachment"> | number
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<TaskNullableRelationFilter, TaskWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    taskId?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attachment"> | number
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    fileUrl?: StringWithAggregatesFilter<"Attachment"> | string
    fileType?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    taskId?: IntNullableWithAggregatesFilter<"Attachment"> | number | null
    uploadedById?: IntWithAggregatesFilter<"Attachment"> | number
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: IntFilter<"SystemSetting"> | number
    changeLogs?: SettingsChangeLogListRelationFilter
    updater?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    changeLogs?: SettingsChangeLogOrderByRelationAggregateInput
    updater?: UserOrderByWithRelationInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: IntFilter<"SystemSetting"> | number
    changeLogs?: SettingsChangeLogListRelationFilter
    updater?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _avg?: SystemSettingAvgOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
    _sum?: SystemSettingSumOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSetting"> | number
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    category?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"SystemSetting"> | number
  }

  export type SettingsChangeLogWhereInput = {
    AND?: SettingsChangeLogWhereInput | SettingsChangeLogWhereInput[]
    OR?: SettingsChangeLogWhereInput[]
    NOT?: SettingsChangeLogWhereInput | SettingsChangeLogWhereInput[]
    id?: IntFilter<"SettingsChangeLog"> | number
    settingKey?: StringFilter<"SettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"SettingsChangeLog"> | string | null
    newValue?: StringFilter<"SettingsChangeLog"> | string
    reason?: StringNullableFilter<"SettingsChangeLog"> | string | null
    userId?: IntFilter<"SettingsChangeLog"> | number
    settingId?: IntFilter<"SettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"SettingsChangeLog"> | Date | string
    setting?: XOR<SystemSettingRelationFilter, SystemSettingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SettingsChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    setting?: SystemSettingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SettingsChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettingsChangeLogWhereInput | SettingsChangeLogWhereInput[]
    OR?: SettingsChangeLogWhereInput[]
    NOT?: SettingsChangeLogWhereInput | SettingsChangeLogWhereInput[]
    settingKey?: StringFilter<"SettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"SettingsChangeLog"> | string | null
    newValue?: StringFilter<"SettingsChangeLog"> | string
    reason?: StringNullableFilter<"SettingsChangeLog"> | string | null
    userId?: IntFilter<"SettingsChangeLog"> | number
    settingId?: IntFilter<"SettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"SettingsChangeLog"> | Date | string
    setting?: XOR<SystemSettingRelationFilter, SystemSettingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SettingsChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    settingKey?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    _count?: SettingsChangeLogCountOrderByAggregateInput
    _avg?: SettingsChangeLogAvgOrderByAggregateInput
    _max?: SettingsChangeLogMaxOrderByAggregateInput
    _min?: SettingsChangeLogMinOrderByAggregateInput
    _sum?: SettingsChangeLogSumOrderByAggregateInput
  }

  export type SettingsChangeLogScalarWhereWithAggregatesInput = {
    AND?: SettingsChangeLogScalarWhereWithAggregatesInput | SettingsChangeLogScalarWhereWithAggregatesInput[]
    OR?: SettingsChangeLogScalarWhereWithAggregatesInput[]
    NOT?: SettingsChangeLogScalarWhereWithAggregatesInput | SettingsChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SettingsChangeLog"> | number
    settingKey?: StringWithAggregatesFilter<"SettingsChangeLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"SettingsChangeLog"> | string | null
    newValue?: StringWithAggregatesFilter<"SettingsChangeLog"> | string
    reason?: StringNullableWithAggregatesFilter<"SettingsChangeLog"> | string | null
    userId?: IntWithAggregatesFilter<"SettingsChangeLog"> | number
    settingId?: IntWithAggregatesFilter<"SettingsChangeLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SettingsChangeLog"> | Date | string
  }

  export type ProjectSettingWhereInput = {
    AND?: ProjectSettingWhereInput | ProjectSettingWhereInput[]
    OR?: ProjectSettingWhereInput[]
    NOT?: ProjectSettingWhereInput | ProjectSettingWhereInput[]
    id?: IntFilter<"ProjectSetting"> | number
    projectId?: IntFilter<"ProjectSetting"> | number
    key?: StringFilter<"ProjectSetting"> | string
    value?: StringFilter<"ProjectSetting"> | string
    category?: StringFilter<"ProjectSetting"> | string
    enabled?: BoolFilter<"ProjectSetting"> | boolean
    updatedAt?: DateTimeFilter<"ProjectSetting"> | Date | string
    updatedBy?: IntFilter<"ProjectSetting"> | number
    updater?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    changeLogs?: ProjectSettingsChangeLogListRelationFilter
  }

  export type ProjectSettingOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    updater?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    changeLogs?: ProjectSettingsChangeLogOrderByRelationAggregateInput
  }

  export type ProjectSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_key?: ProjectSettingProjectIdKeyCompoundUniqueInput
    AND?: ProjectSettingWhereInput | ProjectSettingWhereInput[]
    OR?: ProjectSettingWhereInput[]
    NOT?: ProjectSettingWhereInput | ProjectSettingWhereInput[]
    projectId?: IntFilter<"ProjectSetting"> | number
    key?: StringFilter<"ProjectSetting"> | string
    value?: StringFilter<"ProjectSetting"> | string
    category?: StringFilter<"ProjectSetting"> | string
    enabled?: BoolFilter<"ProjectSetting"> | boolean
    updatedAt?: DateTimeFilter<"ProjectSetting"> | Date | string
    updatedBy?: IntFilter<"ProjectSetting"> | number
    updater?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    changeLogs?: ProjectSettingsChangeLogListRelationFilter
  }, "id" | "projectId_key">

  export type ProjectSettingOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: ProjectSettingCountOrderByAggregateInput
    _avg?: ProjectSettingAvgOrderByAggregateInput
    _max?: ProjectSettingMaxOrderByAggregateInput
    _min?: ProjectSettingMinOrderByAggregateInput
    _sum?: ProjectSettingSumOrderByAggregateInput
  }

  export type ProjectSettingScalarWhereWithAggregatesInput = {
    AND?: ProjectSettingScalarWhereWithAggregatesInput | ProjectSettingScalarWhereWithAggregatesInput[]
    OR?: ProjectSettingScalarWhereWithAggregatesInput[]
    NOT?: ProjectSettingScalarWhereWithAggregatesInput | ProjectSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectSetting"> | number
    projectId?: IntWithAggregatesFilter<"ProjectSetting"> | number
    key?: StringWithAggregatesFilter<"ProjectSetting"> | string
    value?: StringWithAggregatesFilter<"ProjectSetting"> | string
    category?: StringWithAggregatesFilter<"ProjectSetting"> | string
    enabled?: BoolWithAggregatesFilter<"ProjectSetting"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectSetting"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"ProjectSetting"> | number
  }

  export type ProjectSettingsChangeLogWhereInput = {
    AND?: ProjectSettingsChangeLogWhereInput | ProjectSettingsChangeLogWhereInput[]
    OR?: ProjectSettingsChangeLogWhereInput[]
    NOT?: ProjectSettingsChangeLogWhereInput | ProjectSettingsChangeLogWhereInput[]
    id?: IntFilter<"ProjectSettingsChangeLog"> | number
    projectId?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingKey?: StringFilter<"ProjectSettingsChangeLog"> | string
    category?: StringFilter<"ProjectSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    newValue?: StringFilter<"ProjectSettingsChangeLog"> | string
    reason?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingId?: IntFilter<"ProjectSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"ProjectSettingsChangeLog"> | Date | string
    setting?: XOR<ProjectSettingRelationFilter, ProjectSettingWhereInput>
    changer?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectSettingsChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    setting?: ProjectSettingOrderByWithRelationInput
    changer?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectSettingsChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectSettingsChangeLogWhereInput | ProjectSettingsChangeLogWhereInput[]
    OR?: ProjectSettingsChangeLogWhereInput[]
    NOT?: ProjectSettingsChangeLogWhereInput | ProjectSettingsChangeLogWhereInput[]
    projectId?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingKey?: StringFilter<"ProjectSettingsChangeLog"> | string
    category?: StringFilter<"ProjectSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    newValue?: StringFilter<"ProjectSettingsChangeLog"> | string
    reason?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingId?: IntFilter<"ProjectSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"ProjectSettingsChangeLog"> | Date | string
    setting?: XOR<ProjectSettingRelationFilter, ProjectSettingWhereInput>
    changer?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectSettingsChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    _count?: ProjectSettingsChangeLogCountOrderByAggregateInput
    _avg?: ProjectSettingsChangeLogAvgOrderByAggregateInput
    _max?: ProjectSettingsChangeLogMaxOrderByAggregateInput
    _min?: ProjectSettingsChangeLogMinOrderByAggregateInput
    _sum?: ProjectSettingsChangeLogSumOrderByAggregateInput
  }

  export type ProjectSettingsChangeLogScalarWhereWithAggregatesInput = {
    AND?: ProjectSettingsChangeLogScalarWhereWithAggregatesInput | ProjectSettingsChangeLogScalarWhereWithAggregatesInput[]
    OR?: ProjectSettingsChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ProjectSettingsChangeLogScalarWhereWithAggregatesInput | ProjectSettingsChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectSettingsChangeLog"> | number
    projectId?: IntWithAggregatesFilter<"ProjectSettingsChangeLog"> | number
    settingKey?: StringWithAggregatesFilter<"ProjectSettingsChangeLog"> | string
    category?: StringWithAggregatesFilter<"ProjectSettingsChangeLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"ProjectSettingsChangeLog"> | string | null
    newValue?: StringWithAggregatesFilter<"ProjectSettingsChangeLog"> | string
    reason?: StringNullableWithAggregatesFilter<"ProjectSettingsChangeLog"> | string | null
    changedBy?: IntWithAggregatesFilter<"ProjectSettingsChangeLog"> | number
    settingId?: IntWithAggregatesFilter<"ProjectSettingsChangeLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectSettingsChangeLog"> | Date | string
  }

  export type UserSettingWhereInput = {
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    id?: IntFilter<"UserSetting"> | number
    userId?: IntFilter<"UserSetting"> | number
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
    category?: StringFilter<"UserSetting"> | string
    updatedAt?: DateTimeFilter<"UserSetting"> | Date | string
    updatedBy?: IntFilter<"UserSetting"> | number
    updater?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    changeLogs?: UserSettingsChangeLogListRelationFilter
  }

  export type UserSettingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    updater?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    changeLogs?: UserSettingsChangeLogOrderByRelationAggregateInput
  }

  export type UserSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_key?: UserSettingUserIdKeyCompoundUniqueInput
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    userId?: IntFilter<"UserSetting"> | number
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
    category?: StringFilter<"UserSetting"> | string
    updatedAt?: DateTimeFilter<"UserSetting"> | Date | string
    updatedBy?: IntFilter<"UserSetting"> | number
    updater?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    changeLogs?: UserSettingsChangeLogListRelationFilter
  }, "id" | "userId_key">

  export type UserSettingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    _count?: UserSettingCountOrderByAggregateInput
    _avg?: UserSettingAvgOrderByAggregateInput
    _max?: UserSettingMaxOrderByAggregateInput
    _min?: UserSettingMinOrderByAggregateInput
    _sum?: UserSettingSumOrderByAggregateInput
  }

  export type UserSettingScalarWhereWithAggregatesInput = {
    AND?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    OR?: UserSettingScalarWhereWithAggregatesInput[]
    NOT?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSetting"> | number
    userId?: IntWithAggregatesFilter<"UserSetting"> | number
    key?: StringWithAggregatesFilter<"UserSetting"> | string
    value?: StringWithAggregatesFilter<"UserSetting"> | string
    category?: StringWithAggregatesFilter<"UserSetting"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSetting"> | Date | string
    updatedBy?: IntWithAggregatesFilter<"UserSetting"> | number
  }

  export type UserSettingsChangeLogWhereInput = {
    AND?: UserSettingsChangeLogWhereInput | UserSettingsChangeLogWhereInput[]
    OR?: UserSettingsChangeLogWhereInput[]
    NOT?: UserSettingsChangeLogWhereInput | UserSettingsChangeLogWhereInput[]
    id?: IntFilter<"UserSettingsChangeLog"> | number
    userId?: IntFilter<"UserSettingsChangeLog"> | number
    settingKey?: StringFilter<"UserSettingsChangeLog"> | string
    category?: StringFilter<"UserSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    newValue?: StringFilter<"UserSettingsChangeLog"> | string
    reason?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"UserSettingsChangeLog"> | number
    settingId?: IntFilter<"UserSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"UserSettingsChangeLog"> | Date | string
    setting?: XOR<UserSettingRelationFilter, UserSettingWhereInput>
    changer?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSettingsChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    setting?: UserSettingOrderByWithRelationInput
    changer?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserSettingsChangeLogWhereInput | UserSettingsChangeLogWhereInput[]
    OR?: UserSettingsChangeLogWhereInput[]
    NOT?: UserSettingsChangeLogWhereInput | UserSettingsChangeLogWhereInput[]
    userId?: IntFilter<"UserSettingsChangeLog"> | number
    settingKey?: StringFilter<"UserSettingsChangeLog"> | string
    category?: StringFilter<"UserSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    newValue?: StringFilter<"UserSettingsChangeLog"> | string
    reason?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"UserSettingsChangeLog"> | number
    settingId?: IntFilter<"UserSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"UserSettingsChangeLog"> | Date | string
    setting?: XOR<UserSettingRelationFilter, UserSettingWhereInput>
    changer?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserSettingsChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrder
    reason?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
    _count?: UserSettingsChangeLogCountOrderByAggregateInput
    _avg?: UserSettingsChangeLogAvgOrderByAggregateInput
    _max?: UserSettingsChangeLogMaxOrderByAggregateInput
    _min?: UserSettingsChangeLogMinOrderByAggregateInput
    _sum?: UserSettingsChangeLogSumOrderByAggregateInput
  }

  export type UserSettingsChangeLogScalarWhereWithAggregatesInput = {
    AND?: UserSettingsChangeLogScalarWhereWithAggregatesInput | UserSettingsChangeLogScalarWhereWithAggregatesInput[]
    OR?: UserSettingsChangeLogScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsChangeLogScalarWhereWithAggregatesInput | UserSettingsChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserSettingsChangeLog"> | number
    userId?: IntWithAggregatesFilter<"UserSettingsChangeLog"> | number
    settingKey?: StringWithAggregatesFilter<"UserSettingsChangeLog"> | string
    category?: StringWithAggregatesFilter<"UserSettingsChangeLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"UserSettingsChangeLog"> | string | null
    newValue?: StringWithAggregatesFilter<"UserSettingsChangeLog"> | string
    reason?: StringNullableWithAggregatesFilter<"UserSettingsChangeLog"> | string | null
    changedBy?: IntWithAggregatesFilter<"UserSettingsChangeLog"> | number
    settingId?: IntWithAggregatesFilter<"UserSettingsChangeLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserSettingsChangeLog"> | Date | string
  }

  export type ProjectNotificationWhereInput = {
    AND?: ProjectNotificationWhereInput | ProjectNotificationWhereInput[]
    OR?: ProjectNotificationWhereInput[]
    NOT?: ProjectNotificationWhereInput | ProjectNotificationWhereInput[]
    id?: IntFilter<"ProjectNotification"> | number
    projectId?: IntFilter<"ProjectNotification"> | number
    userId?: IntFilter<"ProjectNotification"> | number
    type?: StringFilter<"ProjectNotification"> | string
    entityType?: StringFilter<"ProjectNotification"> | string
    entityId?: IntNullableFilter<"ProjectNotification"> | number | null
    title?: StringFilter<"ProjectNotification"> | string
    message?: StringFilter<"ProjectNotification"> | string
    isRead?: BoolFilter<"ProjectNotification"> | boolean
    soundRequired?: BoolFilter<"ProjectNotification"> | boolean
    isUrgent?: BoolFilter<"ProjectNotification"> | boolean
    requiresAcknowledgment?: BoolFilter<"ProjectNotification"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"ProjectNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectNotificationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    soundRequired?: SortOrder
    isUrgent?: SortOrder
    requiresAcknowledgment?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectNotificationWhereInput | ProjectNotificationWhereInput[]
    OR?: ProjectNotificationWhereInput[]
    NOT?: ProjectNotificationWhereInput | ProjectNotificationWhereInput[]
    projectId?: IntFilter<"ProjectNotification"> | number
    userId?: IntFilter<"ProjectNotification"> | number
    type?: StringFilter<"ProjectNotification"> | string
    entityType?: StringFilter<"ProjectNotification"> | string
    entityId?: IntNullableFilter<"ProjectNotification"> | number | null
    title?: StringFilter<"ProjectNotification"> | string
    message?: StringFilter<"ProjectNotification"> | string
    isRead?: BoolFilter<"ProjectNotification"> | boolean
    soundRequired?: BoolFilter<"ProjectNotification"> | boolean
    isUrgent?: BoolFilter<"ProjectNotification"> | boolean
    requiresAcknowledgment?: BoolFilter<"ProjectNotification"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"ProjectNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectNotification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type ProjectNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    soundRequired?: SortOrder
    isUrgent?: SortOrder
    requiresAcknowledgment?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProjectNotificationCountOrderByAggregateInput
    _avg?: ProjectNotificationAvgOrderByAggregateInput
    _max?: ProjectNotificationMaxOrderByAggregateInput
    _min?: ProjectNotificationMinOrderByAggregateInput
    _sum?: ProjectNotificationSumOrderByAggregateInput
  }

  export type ProjectNotificationScalarWhereWithAggregatesInput = {
    AND?: ProjectNotificationScalarWhereWithAggregatesInput | ProjectNotificationScalarWhereWithAggregatesInput[]
    OR?: ProjectNotificationScalarWhereWithAggregatesInput[]
    NOT?: ProjectNotificationScalarWhereWithAggregatesInput | ProjectNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectNotification"> | number
    projectId?: IntWithAggregatesFilter<"ProjectNotification"> | number
    userId?: IntWithAggregatesFilter<"ProjectNotification"> | number
    type?: StringWithAggregatesFilter<"ProjectNotification"> | string
    entityType?: StringWithAggregatesFilter<"ProjectNotification"> | string
    entityId?: IntNullableWithAggregatesFilter<"ProjectNotification"> | number | null
    title?: StringWithAggregatesFilter<"ProjectNotification"> | string
    message?: StringWithAggregatesFilter<"ProjectNotification"> | string
    isRead?: BoolWithAggregatesFilter<"ProjectNotification"> | boolean
    soundRequired?: BoolWithAggregatesFilter<"ProjectNotification"> | boolean
    isUrgent?: BoolWithAggregatesFilter<"ProjectNotification"> | boolean
    requiresAcknowledgment?: BoolWithAggregatesFilter<"ProjectNotification"> | boolean
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"ProjectNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectNotification"> | Date | string
  }

  export type UrgentProjectAcknowledgementWhereInput = {
    AND?: UrgentProjectAcknowledgementWhereInput | UrgentProjectAcknowledgementWhereInput[]
    OR?: UrgentProjectAcknowledgementWhereInput[]
    NOT?: UrgentProjectAcknowledgementWhereInput | UrgentProjectAcknowledgementWhereInput[]
    id?: IntFilter<"UrgentProjectAcknowledgement"> | number
    projectId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    userId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    acknowledgedAt?: DateTimeFilter<"UrgentProjectAcknowledgement"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UrgentProjectAcknowledgementOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    acknowledgedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UrgentProjectAcknowledgementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId?: UrgentProjectAcknowledgementProjectIdUserIdCompoundUniqueInput
    AND?: UrgentProjectAcknowledgementWhereInput | UrgentProjectAcknowledgementWhereInput[]
    OR?: UrgentProjectAcknowledgementWhereInput[]
    NOT?: UrgentProjectAcknowledgementWhereInput | UrgentProjectAcknowledgementWhereInput[]
    projectId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    userId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    acknowledgedAt?: DateTimeFilter<"UrgentProjectAcknowledgement"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type UrgentProjectAcknowledgementOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    acknowledgedAt?: SortOrder
    _count?: UrgentProjectAcknowledgementCountOrderByAggregateInput
    _avg?: UrgentProjectAcknowledgementAvgOrderByAggregateInput
    _max?: UrgentProjectAcknowledgementMaxOrderByAggregateInput
    _min?: UrgentProjectAcknowledgementMinOrderByAggregateInput
    _sum?: UrgentProjectAcknowledgementSumOrderByAggregateInput
  }

  export type UrgentProjectAcknowledgementScalarWhereWithAggregatesInput = {
    AND?: UrgentProjectAcknowledgementScalarWhereWithAggregatesInput | UrgentProjectAcknowledgementScalarWhereWithAggregatesInput[]
    OR?: UrgentProjectAcknowledgementScalarWhereWithAggregatesInput[]
    NOT?: UrgentProjectAcknowledgementScalarWhereWithAggregatesInput | UrgentProjectAcknowledgementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UrgentProjectAcknowledgement"> | number
    projectId?: IntWithAggregatesFilter<"UrgentProjectAcknowledgement"> | number
    userId?: IntWithAggregatesFilter<"UrgentProjectAcknowledgement"> | number
    acknowledgedAt?: DateTimeWithAggregatesFilter<"UrgentProjectAcknowledgement"> | Date | string
  }

  export type ProjectNotificationPreferenceWhereInput = {
    AND?: ProjectNotificationPreferenceWhereInput | ProjectNotificationPreferenceWhereInput[]
    OR?: ProjectNotificationPreferenceWhereInput[]
    NOT?: ProjectNotificationPreferenceWhereInput | ProjectNotificationPreferenceWhereInput[]
    id?: IntFilter<"ProjectNotificationPreference"> | number
    projectId?: IntFilter<"ProjectNotificationPreference"> | number
    userId?: IntFilter<"ProjectNotificationPreference"> | number
    soundEnabled?: BoolFilter<"ProjectNotificationPreference"> | boolean
    taskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    dependencyNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    todayTaskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    projectAdminNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    updatedAt?: DateTimeFilter<"ProjectNotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type ProjectNotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    soundEnabled?: SortOrder
    taskNotifications?: SortOrder
    dependencyNotifications?: SortOrder
    todayTaskNotifications?: SortOrder
    projectAdminNotifications?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectNotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_userId?: ProjectNotificationPreferenceProjectIdUserIdCompoundUniqueInput
    AND?: ProjectNotificationPreferenceWhereInput | ProjectNotificationPreferenceWhereInput[]
    OR?: ProjectNotificationPreferenceWhereInput[]
    NOT?: ProjectNotificationPreferenceWhereInput | ProjectNotificationPreferenceWhereInput[]
    projectId?: IntFilter<"ProjectNotificationPreference"> | number
    userId?: IntFilter<"ProjectNotificationPreference"> | number
    soundEnabled?: BoolFilter<"ProjectNotificationPreference"> | boolean
    taskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    dependencyNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    todayTaskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    projectAdminNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    updatedAt?: DateTimeFilter<"ProjectNotificationPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectNotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    soundEnabled?: SortOrder
    taskNotifications?: SortOrder
    dependencyNotifications?: SortOrder
    todayTaskNotifications?: SortOrder
    projectAdminNotifications?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectNotificationPreferenceCountOrderByAggregateInput
    _avg?: ProjectNotificationPreferenceAvgOrderByAggregateInput
    _max?: ProjectNotificationPreferenceMaxOrderByAggregateInput
    _min?: ProjectNotificationPreferenceMinOrderByAggregateInput
    _sum?: ProjectNotificationPreferenceSumOrderByAggregateInput
  }

  export type ProjectNotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: ProjectNotificationPreferenceScalarWhereWithAggregatesInput | ProjectNotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: ProjectNotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: ProjectNotificationPreferenceScalarWhereWithAggregatesInput | ProjectNotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectNotificationPreference"> | number
    projectId?: IntWithAggregatesFilter<"ProjectNotificationPreference"> | number
    userId?: IntWithAggregatesFilter<"ProjectNotificationPreference"> | number
    soundEnabled?: BoolWithAggregatesFilter<"ProjectNotificationPreference"> | boolean
    taskNotifications?: BoolWithAggregatesFilter<"ProjectNotificationPreference"> | boolean
    dependencyNotifications?: BoolWithAggregatesFilter<"ProjectNotificationPreference"> | boolean
    todayTaskNotifications?: BoolWithAggregatesFilter<"ProjectNotificationPreference"> | boolean
    projectAdminNotifications?: BoolWithAggregatesFilter<"ProjectNotificationPreference"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectNotificationPreference"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamMember"> | number
    teamId?: IntWithAggregatesFilter<"TeamMember"> | number
    userId?: IntWithAggregatesFilter<"TeamMember"> | number
    role?: StringWithAggregatesFilter<"TeamMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type ProjectTeamWhereInput = {
    AND?: ProjectTeamWhereInput | ProjectTeamWhereInput[]
    OR?: ProjectTeamWhereInput[]
    NOT?: ProjectTeamWhereInput | ProjectTeamWhereInput[]
    id?: IntFilter<"ProjectTeam"> | number
    projectId?: IntFilter<"ProjectTeam"> | number
    teamId?: IntFilter<"ProjectTeam"> | number
    assignedAt?: DateTimeFilter<"ProjectTeam"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }

  export type ProjectTeamOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    assignedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type ProjectTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_teamId?: ProjectTeamProjectIdTeamIdCompoundUniqueInput
    AND?: ProjectTeamWhereInput | ProjectTeamWhereInput[]
    OR?: ProjectTeamWhereInput[]
    NOT?: ProjectTeamWhereInput | ProjectTeamWhereInput[]
    projectId?: IntFilter<"ProjectTeam"> | number
    teamId?: IntFilter<"ProjectTeam"> | number
    assignedAt?: DateTimeFilter<"ProjectTeam"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
  }, "id" | "projectId_teamId">

  export type ProjectTeamOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    assignedAt?: SortOrder
    _count?: ProjectTeamCountOrderByAggregateInput
    _avg?: ProjectTeamAvgOrderByAggregateInput
    _max?: ProjectTeamMaxOrderByAggregateInput
    _min?: ProjectTeamMinOrderByAggregateInput
    _sum?: ProjectTeamSumOrderByAggregateInput
  }

  export type ProjectTeamScalarWhereWithAggregatesInput = {
    AND?: ProjectTeamScalarWhereWithAggregatesInput | ProjectTeamScalarWhereWithAggregatesInput[]
    OR?: ProjectTeamScalarWhereWithAggregatesInput[]
    NOT?: ProjectTeamScalarWhereWithAggregatesInput | ProjectTeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectTeam"> | number
    projectId?: IntWithAggregatesFilter<"ProjectTeam"> | number
    teamId?: IntWithAggregatesFilter<"ProjectTeam"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"ProjectTeam"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystemRole?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: RolePermissionOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystemRole?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystemRole?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    key?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    category?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    category?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "key">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    key?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    module?: StringWithAggregatesFilter<"Permission"> | string
    category?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    scopeType?: StringNullableFilter<"UserRole"> | string | null
    scopeId?: IntNullableFilter<"UserRole"> | number | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: IntNullableFilter<"UserRole"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    assigner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeType?: SortOrderInput | SortOrder
    scopeId?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    assigner?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_roleId_scopeType_scopeId?: UserRoleUserIdRoleIdScopeTypeScopeIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    scopeType?: StringNullableFilter<"UserRole"> | string | null
    scopeId?: IntNullableFilter<"UserRole"> | number | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: IntNullableFilter<"UserRole"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    assigner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId_roleId_scopeType_scopeId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeType?: SortOrderInput | SortOrder
    scopeId?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRole"> | number
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    scopeType?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    scopeId?: IntNullableWithAggregatesFilter<"UserRole"> | number | null
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedBy?: IntNullableWithAggregatesFilter<"UserRole"> | number | null
  }

  export type ProjectTypeWhereInput = {
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    id?: IntFilter<"ProjectType"> | number
    name?: StringFilter<"ProjectType"> | string
    description?: StringNullableFilter<"ProjectType"> | string | null
    isActive?: BoolFilter<"ProjectType"> | boolean
    displayOrder?: IntFilter<"ProjectType"> | number
    color?: StringNullableFilter<"ProjectType"> | string | null
    icon?: StringNullableFilter<"ProjectType"> | string | null
    createdAt?: DateTimeFilter<"ProjectType"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectType"> | Date | string
    projects?: ProjectListRelationFilter
  }

  export type ProjectTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ProjectTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    OR?: ProjectTypeWhereInput[]
    NOT?: ProjectTypeWhereInput | ProjectTypeWhereInput[]
    name?: StringFilter<"ProjectType"> | string
    description?: StringNullableFilter<"ProjectType"> | string | null
    isActive?: BoolFilter<"ProjectType"> | boolean
    displayOrder?: IntFilter<"ProjectType"> | number
    color?: StringNullableFilter<"ProjectType"> | string | null
    icon?: StringNullableFilter<"ProjectType"> | string | null
    createdAt?: DateTimeFilter<"ProjectType"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectType"> | Date | string
    projects?: ProjectListRelationFilter
  }, "id">

  export type ProjectTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectTypeCountOrderByAggregateInput
    _avg?: ProjectTypeAvgOrderByAggregateInput
    _max?: ProjectTypeMaxOrderByAggregateInput
    _min?: ProjectTypeMinOrderByAggregateInput
    _sum?: ProjectTypeSumOrderByAggregateInput
  }

  export type ProjectTypeScalarWhereWithAggregatesInput = {
    AND?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    OR?: ProjectTypeScalarWhereWithAggregatesInput[]
    NOT?: ProjectTypeScalarWhereWithAggregatesInput | ProjectTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectType"> | number
    name?: StringWithAggregatesFilter<"ProjectType"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProjectType"> | boolean
    displayOrder?: IntWithAggregatesFilter<"ProjectType"> | number
    color?: StringNullableWithAggregatesFilter<"ProjectType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ProjectType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectType"> | Date | string
  }

  export type ProjectStatusWhereInput = {
    AND?: ProjectStatusWhereInput | ProjectStatusWhereInput[]
    OR?: ProjectStatusWhereInput[]
    NOT?: ProjectStatusWhereInput | ProjectStatusWhereInput[]
    id?: IntFilter<"ProjectStatus"> | number
    name?: StringFilter<"ProjectStatus"> | string
    color?: StringFilter<"ProjectStatus"> | string
    isDefault?: BoolFilter<"ProjectStatus"> | boolean
    isFinal?: BoolFilter<"ProjectStatus"> | boolean
    isUrgent?: BoolFilter<"ProjectStatus"> | boolean
    orderIndex?: IntFilter<"ProjectStatus"> | number
    isActive?: BoolFilter<"ProjectStatus"> | boolean
    createdAt?: DateTimeFilter<"ProjectStatus"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStatus"> | Date | string
    projects?: ProjectListRelationFilter
  }

  export type ProjectStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isUrgent?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type ProjectStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ProjectStatusWhereInput | ProjectStatusWhereInput[]
    OR?: ProjectStatusWhereInput[]
    NOT?: ProjectStatusWhereInput | ProjectStatusWhereInput[]
    color?: StringFilter<"ProjectStatus"> | string
    isDefault?: BoolFilter<"ProjectStatus"> | boolean
    isFinal?: BoolFilter<"ProjectStatus"> | boolean
    isUrgent?: BoolFilter<"ProjectStatus"> | boolean
    orderIndex?: IntFilter<"ProjectStatus"> | number
    isActive?: BoolFilter<"ProjectStatus"> | boolean
    createdAt?: DateTimeFilter<"ProjectStatus"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectStatus"> | Date | string
    projects?: ProjectListRelationFilter
  }, "id" | "name">

  export type ProjectStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isUrgent?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectStatusCountOrderByAggregateInput
    _avg?: ProjectStatusAvgOrderByAggregateInput
    _max?: ProjectStatusMaxOrderByAggregateInput
    _min?: ProjectStatusMinOrderByAggregateInput
    _sum?: ProjectStatusSumOrderByAggregateInput
  }

  export type ProjectStatusScalarWhereWithAggregatesInput = {
    AND?: ProjectStatusScalarWhereWithAggregatesInput | ProjectStatusScalarWhereWithAggregatesInput[]
    OR?: ProjectStatusScalarWhereWithAggregatesInput[]
    NOT?: ProjectStatusScalarWhereWithAggregatesInput | ProjectStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectStatus"> | number
    name?: StringWithAggregatesFilter<"ProjectStatus"> | string
    color?: StringWithAggregatesFilter<"ProjectStatus"> | string
    isDefault?: BoolWithAggregatesFilter<"ProjectStatus"> | boolean
    isFinal?: BoolWithAggregatesFilter<"ProjectStatus"> | boolean
    isUrgent?: BoolWithAggregatesFilter<"ProjectStatus"> | boolean
    orderIndex?: IntWithAggregatesFilter<"ProjectStatus"> | number
    isActive?: BoolWithAggregatesFilter<"ProjectStatus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectStatus"> | Date | string
  }

  export type TaskStatusWhereInput = {
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    id?: IntFilter<"TaskStatus"> | number
    name?: StringFilter<"TaskStatus"> | string
    color?: StringFilter<"TaskStatus"> | string
    isDefault?: BoolFilter<"TaskStatus"> | boolean
    isFinal?: BoolFilter<"TaskStatus"> | boolean
    isBlocking?: BoolFilter<"TaskStatus"> | boolean
    orderIndex?: IntFilter<"TaskStatus"> | number
    isActive?: BoolFilter<"TaskStatus"> | boolean
    createdAt?: DateTimeFilter<"TaskStatus"> | Date | string
    updatedAt?: DateTimeFilter<"TaskStatus"> | Date | string
    tasks?: TaskListRelationFilter
  }

  export type TaskStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isBlocking?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type TaskStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TaskStatusWhereInput | TaskStatusWhereInput[]
    OR?: TaskStatusWhereInput[]
    NOT?: TaskStatusWhereInput | TaskStatusWhereInput[]
    color?: StringFilter<"TaskStatus"> | string
    isDefault?: BoolFilter<"TaskStatus"> | boolean
    isFinal?: BoolFilter<"TaskStatus"> | boolean
    isBlocking?: BoolFilter<"TaskStatus"> | boolean
    orderIndex?: IntFilter<"TaskStatus"> | number
    isActive?: BoolFilter<"TaskStatus"> | boolean
    createdAt?: DateTimeFilter<"TaskStatus"> | Date | string
    updatedAt?: DateTimeFilter<"TaskStatus"> | Date | string
    tasks?: TaskListRelationFilter
  }, "id" | "name">

  export type TaskStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isBlocking?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskStatusCountOrderByAggregateInput
    _avg?: TaskStatusAvgOrderByAggregateInput
    _max?: TaskStatusMaxOrderByAggregateInput
    _min?: TaskStatusMinOrderByAggregateInput
    _sum?: TaskStatusSumOrderByAggregateInput
  }

  export type TaskStatusScalarWhereWithAggregatesInput = {
    AND?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    OR?: TaskStatusScalarWhereWithAggregatesInput[]
    NOT?: TaskStatusScalarWhereWithAggregatesInput | TaskStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskStatus"> | number
    name?: StringWithAggregatesFilter<"TaskStatus"> | string
    color?: StringWithAggregatesFilter<"TaskStatus"> | string
    isDefault?: BoolWithAggregatesFilter<"TaskStatus"> | boolean
    isFinal?: BoolWithAggregatesFilter<"TaskStatus"> | boolean
    isBlocking?: BoolWithAggregatesFilter<"TaskStatus"> | boolean
    orderIndex?: IntWithAggregatesFilter<"TaskStatus"> | number
    isActive?: BoolWithAggregatesFilter<"TaskStatus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaskStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaskStatus"> | Date | string
  }

  export type StatSnapshotWhereInput = {
    AND?: StatSnapshotWhereInput | StatSnapshotWhereInput[]
    OR?: StatSnapshotWhereInput[]
    NOT?: StatSnapshotWhereInput | StatSnapshotWhereInput[]
    id?: IntFilter<"StatSnapshot"> | number
    entityType?: StringFilter<"StatSnapshot"> | string
    entityId?: IntNullableFilter<"StatSnapshot"> | number | null
    metricKey?: StringFilter<"StatSnapshot"> | string
    value?: FloatFilter<"StatSnapshot"> | number
    date?: DateTimeFilter<"StatSnapshot"> | Date | string
    createdAt?: DateTimeFilter<"StatSnapshot"> | Date | string
  }

  export type StatSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metricKey?: SortOrder
    value?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type StatSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StatSnapshotWhereInput | StatSnapshotWhereInput[]
    OR?: StatSnapshotWhereInput[]
    NOT?: StatSnapshotWhereInput | StatSnapshotWhereInput[]
    entityType?: StringFilter<"StatSnapshot"> | string
    entityId?: IntNullableFilter<"StatSnapshot"> | number | null
    metricKey?: StringFilter<"StatSnapshot"> | string
    value?: FloatFilter<"StatSnapshot"> | number
    date?: DateTimeFilter<"StatSnapshot"> | Date | string
    createdAt?: DateTimeFilter<"StatSnapshot"> | Date | string
  }, "id">

  export type StatSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    metricKey?: SortOrder
    value?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    _count?: StatSnapshotCountOrderByAggregateInput
    _avg?: StatSnapshotAvgOrderByAggregateInput
    _max?: StatSnapshotMaxOrderByAggregateInput
    _min?: StatSnapshotMinOrderByAggregateInput
    _sum?: StatSnapshotSumOrderByAggregateInput
  }

  export type StatSnapshotScalarWhereWithAggregatesInput = {
    AND?: StatSnapshotScalarWhereWithAggregatesInput | StatSnapshotScalarWhereWithAggregatesInput[]
    OR?: StatSnapshotScalarWhereWithAggregatesInput[]
    NOT?: StatSnapshotScalarWhereWithAggregatesInput | StatSnapshotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StatSnapshot"> | number
    entityType?: StringWithAggregatesFilter<"StatSnapshot"> | string
    entityId?: IntNullableWithAggregatesFilter<"StatSnapshot"> | number | null
    metricKey?: StringWithAggregatesFilter<"StatSnapshot"> | string
    value?: FloatWithAggregatesFilter<"StatSnapshot"> | number
    date?: DateTimeWithAggregatesFilter<"StatSnapshot"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"StatSnapshot"> | Date | string
  }

  export type ProductivitySnapshotWhereInput = {
    AND?: ProductivitySnapshotWhereInput | ProductivitySnapshotWhereInput[]
    OR?: ProductivitySnapshotWhereInput[]
    NOT?: ProductivitySnapshotWhereInput | ProductivitySnapshotWhereInput[]
    id?: IntFilter<"ProductivitySnapshot"> | number
    entityType?: StringFilter<"ProductivitySnapshot"> | string
    entityId?: IntFilter<"ProductivitySnapshot"> | number
    period?: StringFilter<"ProductivitySnapshot"> | string
    startDate?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
    endDate?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
    score?: FloatFilter<"ProductivitySnapshot"> | number
    breakdown?: StringFilter<"ProductivitySnapshot"> | string
    createdAt?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
  }

  export type ProductivitySnapshotOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductivitySnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductivitySnapshotWhereInput | ProductivitySnapshotWhereInput[]
    OR?: ProductivitySnapshotWhereInput[]
    NOT?: ProductivitySnapshotWhereInput | ProductivitySnapshotWhereInput[]
    entityType?: StringFilter<"ProductivitySnapshot"> | string
    entityId?: IntFilter<"ProductivitySnapshot"> | number
    period?: StringFilter<"ProductivitySnapshot"> | string
    startDate?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
    endDate?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
    score?: FloatFilter<"ProductivitySnapshot"> | number
    breakdown?: StringFilter<"ProductivitySnapshot"> | string
    createdAt?: DateTimeFilter<"ProductivitySnapshot"> | Date | string
  }, "id">

  export type ProductivitySnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
    _count?: ProductivitySnapshotCountOrderByAggregateInput
    _avg?: ProductivitySnapshotAvgOrderByAggregateInput
    _max?: ProductivitySnapshotMaxOrderByAggregateInput
    _min?: ProductivitySnapshotMinOrderByAggregateInput
    _sum?: ProductivitySnapshotSumOrderByAggregateInput
  }

  export type ProductivitySnapshotScalarWhereWithAggregatesInput = {
    AND?: ProductivitySnapshotScalarWhereWithAggregatesInput | ProductivitySnapshotScalarWhereWithAggregatesInput[]
    OR?: ProductivitySnapshotScalarWhereWithAggregatesInput[]
    NOT?: ProductivitySnapshotScalarWhereWithAggregatesInput | ProductivitySnapshotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductivitySnapshot"> | number
    entityType?: StringWithAggregatesFilter<"ProductivitySnapshot"> | string
    entityId?: IntWithAggregatesFilter<"ProductivitySnapshot"> | number
    period?: StringWithAggregatesFilter<"ProductivitySnapshot"> | string
    startDate?: DateTimeWithAggregatesFilter<"ProductivitySnapshot"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ProductivitySnapshot"> | Date | string
    score?: FloatWithAggregatesFilter<"ProductivitySnapshot"> | number
    breakdown?: StringWithAggregatesFilter<"ProductivitySnapshot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductivitySnapshot"> | Date | string
  }

  export type ForecastSnapshotWhereInput = {
    AND?: ForecastSnapshotWhereInput | ForecastSnapshotWhereInput[]
    OR?: ForecastSnapshotWhereInput[]
    NOT?: ForecastSnapshotWhereInput | ForecastSnapshotWhereInput[]
    id?: IntFilter<"ForecastSnapshot"> | number
    entityType?: StringFilter<"ForecastSnapshot"> | string
    entityId?: IntFilter<"ForecastSnapshot"> | number
    predictedDate?: DateTimeFilter<"ForecastSnapshot"> | Date | string
    riskLevel?: StringFilter<"ForecastSnapshot"> | string
    confidence?: FloatFilter<"ForecastSnapshot"> | number
    explanation?: StringFilter<"ForecastSnapshot"> | string
    createdAt?: DateTimeFilter<"ForecastSnapshot"> | Date | string
  }

  export type ForecastSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    predictedDate?: SortOrder
    riskLevel?: SortOrder
    confidence?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type ForecastSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ForecastSnapshotWhereInput | ForecastSnapshotWhereInput[]
    OR?: ForecastSnapshotWhereInput[]
    NOT?: ForecastSnapshotWhereInput | ForecastSnapshotWhereInput[]
    entityType?: StringFilter<"ForecastSnapshot"> | string
    entityId?: IntFilter<"ForecastSnapshot"> | number
    predictedDate?: DateTimeFilter<"ForecastSnapshot"> | Date | string
    riskLevel?: StringFilter<"ForecastSnapshot"> | string
    confidence?: FloatFilter<"ForecastSnapshot"> | number
    explanation?: StringFilter<"ForecastSnapshot"> | string
    createdAt?: DateTimeFilter<"ForecastSnapshot"> | Date | string
  }, "id">

  export type ForecastSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    predictedDate?: SortOrder
    riskLevel?: SortOrder
    confidence?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    _count?: ForecastSnapshotCountOrderByAggregateInput
    _avg?: ForecastSnapshotAvgOrderByAggregateInput
    _max?: ForecastSnapshotMaxOrderByAggregateInput
    _min?: ForecastSnapshotMinOrderByAggregateInput
    _sum?: ForecastSnapshotSumOrderByAggregateInput
  }

  export type ForecastSnapshotScalarWhereWithAggregatesInput = {
    AND?: ForecastSnapshotScalarWhereWithAggregatesInput | ForecastSnapshotScalarWhereWithAggregatesInput[]
    OR?: ForecastSnapshotScalarWhereWithAggregatesInput[]
    NOT?: ForecastSnapshotScalarWhereWithAggregatesInput | ForecastSnapshotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ForecastSnapshot"> | number
    entityType?: StringWithAggregatesFilter<"ForecastSnapshot"> | string
    entityId?: IntWithAggregatesFilter<"ForecastSnapshot"> | number
    predictedDate?: DateTimeWithAggregatesFilter<"ForecastSnapshot"> | Date | string
    riskLevel?: StringWithAggregatesFilter<"ForecastSnapshot"> | string
    confidence?: FloatWithAggregatesFilter<"ForecastSnapshot"> | number
    explanation?: StringWithAggregatesFilter<"ForecastSnapshot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForecastSnapshot"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamCreateInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubtaskCreateInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyCreateInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    dependsOnSubtask: SubtaskCreateNestedOneWithoutDependenciesInput
    subtask: SubtaskCreateNestedOneWithoutDependentsInput
  }

  export type SubtaskDependencyUncheckedCreateInput = {
    subtaskId: number
    dependsOnSubtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type SubtaskDependencyUpdateInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOnSubtask?: SubtaskUpdateOneRequiredWithoutDependenciesNestedInput
    subtask?: SubtaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type SubtaskDependencyUncheckedUpdateInput = {
    subtaskId?: IntFieldUpdateOperationsInput | number
    dependsOnSubtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyCreateManyInput = {
    subtaskId: number
    dependsOnSubtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type SubtaskDependencyUpdateManyMutationInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyUncheckedUpdateManyInput = {
    subtaskId?: IntFieldUpdateOperationsInput | number
    dependsOnSubtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    subtask?: SubtaskCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
    mentions?: CommentMentionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
    userId: number
    mentions?: CommentMentionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    subtask?: SubtaskUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
    mentions?: CommentMentionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    mentions?: CommentMentionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
    userId: number
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CommentMentionCreateInput = {
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutMentionsInput
    user: UserCreateNestedOneWithoutCommentMentionsInput
  }

  export type CommentMentionUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    createdAt?: Date | string
  }

  export type CommentMentionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutMentionsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentMentionsNestedInput
  }

  export type CommentMentionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentMentionCreateManyInput = {
    id?: number
    commentId: number
    userId: number
    createdAt?: Date | string
  }

  export type CommentMentionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentMentionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelCreateInput = {
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    tasks?: TaskLabelCreateNestedManyWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
    tasks?: TaskLabelUncheckedCreateNestedManyWithoutLabelInput
  }

  export type LabelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskLabelUpdateManyWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskLabelUncheckedUpdateManyWithoutLabelNestedInput
  }

  export type LabelCreateManyInput = {
    id?: number
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LabelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateInput = {
    createdAt?: Date | string
    label: LabelCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutLabelsInput
  }

  export type TaskLabelUncheckedCreateInput = {
    taskId: number
    labelId: number
    createdAt?: Date | string
  }

  export type TaskLabelUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: LabelUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    labelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateManyInput = {
    taskId: number
    labelId: number
    createdAt?: Date | string
  }

  export type TaskLabelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    labelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyCreateInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    dependsOnTask: TaskCreateNestedOneWithoutDependentsInput
    task: TaskCreateNestedOneWithoutDependenciesInput
  }

  export type TaskDependencyUncheckedCreateInput = {
    taskId: number
    dependsOnTaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskDependencyUpdateInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOnTask?: TaskUpdateOneRequiredWithoutDependentsNestedInput
    task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type TaskDependencyUncheckedUpdateInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    dependsOnTaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyCreateManyInput = {
    taskId: number
    dependsOnTaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskDependencyUpdateManyMutationInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    dependsOnTaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogCreateInput = {
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    subtask?: SubtaskCreateNestedOneWithoutTimeLogsInput
    task?: TaskCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    taskId?: number | null
    subtaskId?: number | null
  }

  export type TimeLogUpdateInput = {
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtask?: SubtaskUpdateOneWithoutTimeLogsNestedInput
    task?: TaskUpdateOneWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TimeLogCreateManyInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    taskId?: number | null
    subtaskId?: number | null
  }

  export type TimeLogUpdateManyMutationInput = {
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationRuleCreateInput = {
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    team?: TeamCreateNestedOneWithoutRulesInput
    creator: UserCreateNestedOneWithoutCreatedRulesInput
  }

  export type AutomationRuleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdById: number
    teamId?: number | null
  }

  export type AutomationRuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutRulesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedRulesNestedInput
  }

  export type AutomationRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationRuleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdById: number
    teamId?: number | null
  }

  export type AutomationRuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateManyInput = {
    id?: number
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
    userId: number
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityLogCreateInput = {
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    performedBy?: UserCreateNestedOneWithoutActivityLogsPerformedInput
    affectedUser?: UserCreateNestedOneWithoutActivityLogsAffectedInput
    project?: ProjectCreateNestedOneWithoutActivityLogsInput
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogUpdateInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: UserUpdateOneWithoutActivityLogsPerformedNestedInput
    affectedUser?: UserUpdateOneWithoutActivityLogsAffectedNestedInput
    project?: ProjectUpdateOneWithoutActivityLogsNestedInput
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogUpdateManyMutationInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectUserCreateInput = {
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectUsersInput
  }

  export type ProjectUserUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectUserUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectUsersNestedInput
  }

  export type ProjectUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectUserUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseCreateInput = {
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutPhasesInput
  }

  export type ProjectPhaseUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectPhaseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type ProjectPhaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectPhaseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverableCreateInput = {
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeliverablesInput
    tasks?: TaskCreateNestedManyWithoutDeliverableInput
  }

  export type DeliverableUncheckedCreateInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutDeliverableInput
  }

  export type DeliverableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeliverablesNestedInput
    tasks?: TaskUpdateManyWithoutDeliverableNestedInput
  }

  export type DeliverableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutDeliverableNestedInput
  }

  export type DeliverableCreateManyInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliverableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryCreateInput = {
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutScopeHistoryInput
  }

  export type ScopeHistoryUncheckedCreateInput = {
    id?: number
    projectId: number
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
  }

  export type ScopeHistoryUpdateInput = {
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutScopeHistoryNestedInput
  }

  export type ScopeHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryCreateManyInput = {
    id?: number
    projectId: number
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
  }

  export type ScopeHistoryUpdateManyMutationInput = {
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    uploader: UserCreateNestedOneWithoutUploadedFilesInput
    task?: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    taskId?: number | null
    uploadedById: number
  }

  export type AttachmentUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
    task?: TaskUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentCreateManyInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    taskId?: number | null
    uploadedById: number
  }

  export type AttachmentUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    changeLogs?: SettingsChangeLogCreateNestedManyWithoutSettingInput
    updater: UserCreateNestedOneWithoutUpdatedSettingsInput
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    updatedBy: number
    changeLogs?: SettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeLogs?: SettingsChangeLogUpdateManyWithoutSettingNestedInput
    updater?: UserUpdateOneRequiredWithoutUpdatedSettingsNestedInput
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    changeLogs?: SettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type SystemSettingCreateManyInput = {
    id?: number
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type SettingsChangeLogCreateInput = {
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: SystemSettingCreateNestedOneWithoutChangeLogsInput
    user: UserCreateNestedOneWithoutSettingsChangedInput
  }

  export type SettingsChangeLogUncheckedCreateInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    userId: number
    settingId: number
    createdAt?: Date | string
  }

  export type SettingsChangeLogUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: SystemSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutSettingsChangedNestedInput
  }

  export type SettingsChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsChangeLogCreateManyInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    userId: number
    settingId: number
    createdAt?: Date | string
  }

  export type SettingsChangeLogUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingCreateInput = {
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutProjectSettingsUpdatedInput
    project: ProjectCreateNestedOneWithoutSettingsInput
    changeLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingUncheckedCreateInput = {
    id?: number
    projectId: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updatedBy: number
    changeLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutProjectSettingsUpdatedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSettingsNestedInput
    changeLogs?: ProjectSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    changeLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingCreateManyInput = {
    id?: number
    projectId: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ProjectSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSettingsChangeLogCreateInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: ProjectSettingCreateNestedOneWithoutChangeLogsInput
    changer: UserCreateNestedOneWithoutProjectSettingsChangedInput
    project: ProjectCreateNestedOneWithoutSettingsLogsInput
  }

  export type ProjectSettingsChangeLogUncheckedCreateInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: ProjectSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    changer?: UserUpdateOneRequiredWithoutProjectSettingsChangedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSettingsLogsNestedInput
  }

  export type ProjectSettingsChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogCreateManyInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingCreateInput = {
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutUserSettingsUpdatedInput
    user: UserCreateNestedOneWithoutUserSettingsInput
    changeLogs?: UserSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type UserSettingUncheckedCreateInput = {
    id?: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updatedBy: number
    changeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type UserSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutUserSettingsUpdatedNestedInput
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
    changeLogs?: UserSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    changeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingCreateManyInput = {
    id?: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingsChangeLogCreateInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: UserSettingCreateNestedOneWithoutChangeLogsInput
    changer: UserCreateNestedOneWithoutUserSettingsChangedInput
    user: UserCreateNestedOneWithoutUserSettingsChangeLogsInput
  }

  export type UserSettingsChangeLogUncheckedCreateInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: UserSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    changer?: UserUpdateOneRequiredWithoutUserSettingsChangedNestedInput
    user?: UserUpdateOneRequiredWithoutUserSettingsChangeLogsNestedInput
  }

  export type UserSettingsChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogCreateManyInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationCreateInput = {
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectNotificationsInput
    project: ProjectCreateNestedOneWithoutNotificationsInput
  }

  export type ProjectNotificationUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectNotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectNotificationsNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type ProjectNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectNotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementCreateInput = {
    acknowledgedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUrgentAcknowledgmentsInput
    user: UserCreateNestedOneWithoutUrgentAcknowledgementsInput
  }

  export type UrgentProjectAcknowledgementUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    acknowledgedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementUpdateInput = {
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUrgentAcknowledgmentsNestedInput
    user?: UserUpdateOneRequiredWithoutUrgentAcknowledgementsNestedInput
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    acknowledgedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementUpdateManyMutationInput = {
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceCreateInput = {
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectNotificationPreferencesInput
    project: ProjectCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type ProjectNotificationPreferenceUncheckedCreateInput = {
    id?: number
    projectId: number
    userId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationPreferenceUpdateInput = {
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectNotificationPreferencesNestedInput
    project?: ProjectUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type ProjectNotificationPreferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceCreateManyInput = {
    id?: number
    projectId: number
    userId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationPreferenceUpdateManyMutationInput = {
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    role?: string
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: number
    teamId: number
    userId: number
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: number
    teamId: number
    userId: number
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamCreateInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectTeamsInput
    team: TeamCreateNestedOneWithoutProjectTeamsInput
  }

  export type ProjectTeamUncheckedCreateInput = {
    id?: number
    projectId: number
    teamId: number
    assignedAt?: Date | string
  }

  export type ProjectTeamUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectTeamsNestedInput
    team?: TeamUpdateOneRequiredWithoutProjectTeamsNestedInput
  }

  export type ProjectTeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamCreateManyInput = {
    id?: number
    projectId: number
    teamId: number
    assignedAt?: Date | string
  }

  export type ProjectTeamUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    key: string
    name: string
    description?: string | null
    module: string
    category?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    key: string
    name: string
    description?: string | null
    module: string
    category?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    key: string
    name: string
    description?: string | null
    module: string
    category?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleId: number
    permissionId: number
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
    assigner?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleUpdateInput = {
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
    assigner?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleUpdateManyMutationInput = {
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTypeCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    displayOrder?: number
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutProjectTypeInput
  }

  export type ProjectTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    displayOrder?: number
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutProjectTypeInput
  }

  export type ProjectTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutProjectTypeNestedInput
  }

  export type ProjectTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutProjectTypeNestedInput
  }

  export type ProjectTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    displayOrder?: number
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusCreateInput = {
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutProjectStatusInput
  }

  export type ProjectStatusUncheckedCreateInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutProjectStatusInput
  }

  export type ProjectStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutProjectStatusNestedInput
  }

  export type ProjectStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutProjectStatusNestedInput
  }

  export type ProjectStatusCreateManyInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskStatusCreateInput = {
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutTaskStatusInput
  }

  export type TaskStatusUncheckedCreateInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutTaskStatusInput
  }

  export type TaskStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutTaskStatusNestedInput
  }

  export type TaskStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutTaskStatusNestedInput
  }

  export type TaskStatusCreateManyInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatSnapshotCreateInput = {
    entityType: string
    entityId?: number | null
    metricKey: string
    value: number
    date: Date | string
    createdAt?: Date | string
  }

  export type StatSnapshotUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId?: number | null
    metricKey: string
    value: number
    date: Date | string
    createdAt?: Date | string
  }

  export type StatSnapshotUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    metricKey?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatSnapshotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    metricKey?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatSnapshotCreateManyInput = {
    id?: number
    entityType: string
    entityId?: number | null
    metricKey: string
    value: number
    date: Date | string
    createdAt?: Date | string
  }

  export type StatSnapshotUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    metricKey?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatSnapshotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    metricKey?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductivitySnapshotCreateInput = {
    entityType: string
    entityId: number
    period: string
    startDate: Date | string
    endDate: Date | string
    score: number
    breakdown: string
    createdAt?: Date | string
  }

  export type ProductivitySnapshotUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    period: string
    startDate: Date | string
    endDate: Date | string
    score: number
    breakdown: string
    createdAt?: Date | string
  }

  export type ProductivitySnapshotUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: FloatFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductivitySnapshotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: FloatFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductivitySnapshotCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    period: string
    startDate: Date | string
    endDate: Date | string
    score: number
    breakdown: string
    createdAt?: Date | string
  }

  export type ProductivitySnapshotUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: FloatFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductivitySnapshotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    period?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: FloatFieldUpdateOperationsInput | number
    breakdown?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastSnapshotCreateInput = {
    entityType: string
    entityId: number
    predictedDate: Date | string
    riskLevel: string
    confidence: number
    explanation: string
    createdAt?: Date | string
  }

  export type ForecastSnapshotUncheckedCreateInput = {
    id?: number
    entityType: string
    entityId: number
    predictedDate: Date | string
    riskLevel: string
    confidence: number
    explanation: string
    createdAt?: Date | string
  }

  export type ForecastSnapshotUpdateInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastSnapshotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastSnapshotCreateManyInput = {
    id?: number
    entityType: string
    entityId: number
    predictedDate: Date | string
    riskLevel: string
    confidence: number
    explanation: string
    createdAt?: Date | string
  }

  export type ForecastSnapshotUpdateManyMutationInput = {
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForecastSnapshotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: IntFieldUpdateOperationsInput | number
    predictedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    explanation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AutomationRuleListRelationFilter = {
    every?: AutomationRuleWhereInput
    some?: AutomationRuleWhereInput
    none?: AutomationRuleWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentMentionListRelationFilter = {
    every?: CommentMentionWhereInput
    some?: CommentMentionWhereInput
    none?: CommentMentionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ProjectNotificationPreferenceListRelationFilter = {
    every?: ProjectNotificationPreferenceWhereInput
    some?: ProjectNotificationPreferenceWhereInput
    none?: ProjectNotificationPreferenceWhereInput
  }

  export type ProjectNotificationListRelationFilter = {
    every?: ProjectNotificationWhereInput
    some?: ProjectNotificationWhereInput
    none?: ProjectNotificationWhereInput
  }

  export type ProjectSettingListRelationFilter = {
    every?: ProjectSettingWhereInput
    some?: ProjectSettingWhereInput
    none?: ProjectSettingWhereInput
  }

  export type ProjectSettingsChangeLogListRelationFilter = {
    every?: ProjectSettingsChangeLogWhereInput
    some?: ProjectSettingsChangeLogWhereInput
    none?: ProjectSettingsChangeLogWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SettingsChangeLogListRelationFilter = {
    every?: SettingsChangeLogWhereInput
    some?: SettingsChangeLogWhereInput
    none?: SettingsChangeLogWhereInput
  }

  export type SubtaskListRelationFilter = {
    every?: SubtaskWhereInput
    some?: SubtaskWhereInput
    none?: SubtaskWhereInput
  }

  export type SystemSettingListRelationFilter = {
    every?: SystemSettingWhereInput
    some?: SystemSettingWhereInput
    none?: SystemSettingWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TimeLogListRelationFilter = {
    every?: TimeLogWhereInput
    some?: TimeLogWhereInput
    none?: TimeLogWhereInput
  }

  export type UserSettingListRelationFilter = {
    every?: UserSettingWhereInput
    some?: UserSettingWhereInput
    none?: UserSettingWhereInput
  }

  export type UserSettingsChangeLogListRelationFilter = {
    every?: UserSettingsChangeLogWhereInput
    some?: UserSettingsChangeLogWhereInput
    none?: UserSettingsChangeLogWhereInput
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UrgentProjectAcknowledgementListRelationFilter = {
    every?: UrgentProjectAcknowledgementWhereInput
    some?: UrgentProjectAcknowledgementWhereInput
    none?: UrgentProjectAcknowledgementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentMentionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectNotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSettingsChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingsChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSettingsChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UrgentProjectAcknowledgementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    teamId?: SortOrder
    avatarUrl?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ProjectTeamListRelationFilter = {
    every?: ProjectTeamWhereInput
    some?: ProjectTeamWhereInput
    none?: ProjectTeamWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamLeadId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    teamLeadId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamLeadId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    teamLeadId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    teamLeadId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DeliverableListRelationFilter = {
    every?: DeliverableWhereInput
    some?: DeliverableWhereInput
    none?: DeliverableWhereInput
  }

  export type ProjectPhaseListRelationFilter = {
    every?: ProjectPhaseWhereInput
    some?: ProjectPhaseWhereInput
    none?: ProjectPhaseWhereInput
  }

  export type ProjectUserListRelationFilter = {
    every?: ProjectUserWhereInput
    some?: ProjectUserWhereInput
    none?: ProjectUserWhereInput
  }

  export type ProjectTypeNullableRelationFilter = {
    is?: ProjectTypeWhereInput | null
    isNot?: ProjectTypeWhereInput | null
  }

  export type ProjectStatusNullableRelationFilter = {
    is?: ProjectStatusWhereInput | null
    isNot?: ProjectStatusWhereInput | null
  }

  export type ScopeHistoryListRelationFilter = {
    every?: ScopeHistoryWhereInput
    some?: ScopeHistoryWhereInput
    none?: ScopeHistoryWhereInput
  }

  export type DeliverableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScopeHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    projectTypeId?: SortOrder
    projectStatusId?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    urgentReason?: SortOrder
    urgentMarkedAt?: SortOrder
    urgentMarkedById?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    projectManagerId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    projectTypeId?: SortOrder
    projectStatusId?: SortOrder
    urgentMarkedById?: SortOrder
    projectManagerId?: SortOrder
    createdById?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    projectTypeId?: SortOrder
    projectStatusId?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    urgentReason?: SortOrder
    urgentMarkedAt?: SortOrder
    urgentMarkedById?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    projectManagerId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    projectTypeId?: SortOrder
    projectStatusId?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    urgentReason?: SortOrder
    urgentMarkedAt?: SortOrder
    urgentMarkedById?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    projectManagerId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    projectTypeId?: SortOrder
    projectStatusId?: SortOrder
    urgentMarkedById?: SortOrder
    projectManagerId?: SortOrder
    createdById?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TaskDependencyListRelationFilter = {
    every?: TaskDependencyWhereInput
    some?: TaskDependencyWhereInput
    none?: TaskDependencyWhereInput
  }

  export type TaskLabelListRelationFilter = {
    every?: TaskLabelWhereInput
    some?: TaskLabelWhereInput
    none?: TaskLabelWhereInput
  }

  export type DeliverableNullableRelationFilter = {
    is?: DeliverableWhereInput | null
    isNot?: DeliverableWhereInput | null
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type TaskStatusNullableRelationFilter = {
    is?: TaskStatusWhereInput | null
    isNot?: TaskStatusWhereInput | null
  }

  export type TaskDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskLabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    taskStatusId?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    plannedDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    deliverableId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    taskStatusId?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    deliverableId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    taskStatusId?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    plannedDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    deliverableId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    taskStatusId?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    plannedDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    deliverableId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    taskStatusId?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    deliverableId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SubtaskDependencyListRelationFilter = {
    every?: SubtaskDependencyWhereInput
    some?: SubtaskDependencyWhereInput
    none?: SubtaskDependencyWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type SubtaskDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskAvgOrderByAggregateInput = {
    id?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
  }

  export type SubtaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    startDate?: SortOrder
    dueDate?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtaskSumOrderByAggregateInput = {
    id?: SortOrder
    estimatedHours?: SortOrder
    actualHours?: SortOrder
    parentTaskId?: SortOrder
    assignedToId?: SortOrder
    teamId?: SortOrder
    createdById?: SortOrder
  }

  export type SubtaskRelationFilter = {
    is?: SubtaskWhereInput
    isNot?: SubtaskWhereInput
  }

  export type SubtaskDependencySubtaskIdDependsOnSubtaskIdCompoundUniqueInput = {
    subtaskId: number
    dependsOnSubtaskId: number
  }

  export type SubtaskDependencyCountOrderByAggregateInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtaskDependencyAvgOrderByAggregateInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    createdById?: SortOrder
  }

  export type SubtaskDependencyMaxOrderByAggregateInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtaskDependencyMinOrderByAggregateInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtaskDependencySumOrderByAggregateInput = {
    subtaskId?: SortOrder
    dependsOnSubtaskId?: SortOrder
    createdById?: SortOrder
  }

  export type SubtaskNullableRelationFilter = {
    is?: SubtaskWhereInput | null
    isNot?: SubtaskWhereInput | null
  }

  export type TaskNullableRelationFilter = {
    is?: TaskWhereInput | null
    isNot?: TaskWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
    userId?: SortOrder
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentMentionCommentIdUserIdCompoundUniqueInput = {
    commentId: number
    userId: number
  }

  export type CommentMentionCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMentionAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMentionMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMentionMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMentionSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LabelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type LabelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LabelRelationFilter = {
    is?: LabelWhereInput
    isNot?: LabelWhereInput
  }

  export type TaskLabelTaskIdLabelIdCompoundUniqueInput = {
    taskId: number
    labelId: number
  }

  export type TaskLabelCountOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLabelAvgOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
  }

  export type TaskLabelMaxOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLabelMinOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLabelSumOrderByAggregateInput = {
    taskId?: SortOrder
    labelId?: SortOrder
  }

  export type TaskDependencyTaskIdDependsOnTaskIdCompoundUniqueInput = {
    taskId: number
    dependsOnTaskId: number
  }

  export type TaskDependencyCountOrderByAggregateInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskDependencyAvgOrderByAggregateInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    createdById?: SortOrder
  }

  export type TaskDependencyMaxOrderByAggregateInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskDependencyMinOrderByAggregateInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    dependencyType?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskDependencySumOrderByAggregateInput = {
    taskId?: SortOrder
    dependsOnTaskId?: SortOrder
    createdById?: SortOrder
  }

  export type TimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    description?: SortOrder
    logDate?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
  }

  export type TimeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
  }

  export type TimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    description?: SortOrder
    logDate?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
  }

  export type TimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    description?: SortOrder
    logDate?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
  }

  export type TimeLogSumOrderByAggregateInput = {
    id?: SortOrder
    hoursLogged?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    subtaskId?: SortOrder
  }

  export type AutomationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerCondition?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerCondition?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerCondition?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrder
  }

  export type AutomationRuleSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    teamId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    actionCategory?: SortOrder
    actionSummary?: SortOrder
    actionDetails?: SortOrder
    performedById?: SortOrder
    affectedUserId?: SortOrder
    projectId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    performedById?: SortOrder
    affectedUserId?: SortOrder
    projectId?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    actionCategory?: SortOrder
    actionSummary?: SortOrder
    actionDetails?: SortOrder
    performedById?: SortOrder
    affectedUserId?: SortOrder
    projectId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    actionCategory?: SortOrder
    actionSummary?: SortOrder
    actionDetails?: SortOrder
    performedById?: SortOrder
    affectedUserId?: SortOrder
    projectId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    action?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    performedById?: SortOrder
    affectedUserId?: SortOrder
    projectId?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectUserProjectIdUserIdJoinedAtCompoundUniqueInput = {
    projectId: number
    userId: number
    joinedAt: Date | string
  }

  export type ProjectUserCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    allocationPercentage?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectUserAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    allocationPercentage?: SortOrder
  }

  export type ProjectUserMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    allocationPercentage?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectUserMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    allocationPercentage?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectUserSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    allocationPercentage?: SortOrder
  }

  export type ProjectPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sequenceOrder?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectPhaseAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sequenceOrder?: SortOrder
  }

  export type ProjectPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sequenceOrder?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    sequenceOrder?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectPhaseSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sequenceOrder?: SortOrder
  }

  export type DeliverableCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverableAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type DeliverableMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverableMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    acceptanceCriteria?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliverableSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ScopeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    scopeText?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ScopeHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    changedById?: SortOrder
  }

  export type ScopeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    scopeText?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ScopeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    scopeText?: SortOrder
    changeReason?: SortOrder
    changedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ScopeHistorySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    changedById?: SortOrder
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedAt?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    taskId?: SortOrder
    uploadedById?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingSumOrderByAggregateInput = {
    id?: SortOrder
    updatedBy?: SortOrder
  }

  export type SystemSettingRelationFilter = {
    is?: SystemSettingWhereInput
    isNot?: SystemSettingWhereInput
  }

  export type SettingsChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
  }

  export type SettingsChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    settingKey?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingId?: SortOrder
  }

  export type ProjectSettingProjectIdKeyCompoundUniqueInput = {
    projectId: number
    key: string
  }

  export type ProjectSettingCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectSettingMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    enabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectSettingSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProjectSettingRelationFilter = {
    is?: ProjectSettingWhereInput
    isNot?: ProjectSettingWhereInput
  }

  export type ProjectSettingsChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectSettingsChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
  }

  export type ProjectSettingsChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectSettingsChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectSettingsChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
  }

  export type UserSettingUserIdKeyCompoundUniqueInput = {
    userId: number
    key: string
  }

  export type UserSettingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSettingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSettingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSettingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    updatedBy?: SortOrder
  }

  export type UserSettingRelationFilter = {
    is?: UserSettingWhereInput
    isNot?: UserSettingWhereInput
  }

  export type UserSettingsChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSettingsChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
  }

  export type UserSettingsChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSettingsChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    settingKey?: SortOrder
    category?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSettingsChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changedBy?: SortOrder
    settingId?: SortOrder
  }

  export type ProjectNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    soundRequired?: SortOrder
    isUrgent?: SortOrder
    requiresAcknowledgment?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type ProjectNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    soundRequired?: SortOrder
    isUrgent?: SortOrder
    requiresAcknowledgment?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    soundRequired?: SortOrder
    isUrgent?: SortOrder
    requiresAcknowledgment?: SortOrder
    acknowledgedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectNotificationSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    entityId?: SortOrder
  }

  export type UrgentProjectAcknowledgementProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: number
  }

  export type UrgentProjectAcknowledgementCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type UrgentProjectAcknowledgementAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type UrgentProjectAcknowledgementMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type UrgentProjectAcknowledgementMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    acknowledgedAt?: SortOrder
  }

  export type UrgentProjectAcknowledgementSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotificationPreferenceProjectIdUserIdCompoundUniqueInput = {
    projectId: number
    userId: number
  }

  export type ProjectNotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    soundEnabled?: SortOrder
    taskNotifications?: SortOrder
    dependencyNotifications?: SortOrder
    todayTaskNotifications?: SortOrder
    projectAdminNotifications?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectNotificationPreferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectNotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    soundEnabled?: SortOrder
    taskNotifications?: SortOrder
    dependencyNotifications?: SortOrder
    todayTaskNotifications?: SortOrder
    projectAdminNotifications?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectNotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    soundEnabled?: SortOrder
    taskNotifications?: SortOrder
    dependencyNotifications?: SortOrder
    todayTaskNotifications?: SortOrder
    projectAdminNotifications?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectNotificationPreferenceSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type ProjectTeamProjectIdTeamIdCompoundUniqueInput = {
    projectId: number
    teamId: number
  }

  export type ProjectTeamCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectTeamAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
  }

  export type ProjectTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectTeamMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ProjectTeamSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystemRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type UserRoleUserIdRoleIdScopeTypeScopeIdCompoundUniqueInput = {
    userId: number
    roleId: number
    scopeType: string
    scopeId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeType?: SortOrder
    scopeId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeId?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeType?: SortOrder
    scopeId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeType?: SortOrder
    scopeId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    scopeId?: SortOrder
    assignedBy?: SortOrder
  }

  export type ProjectTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProjectTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTypeSumOrderByAggregateInput = {
    id?: SortOrder
    displayOrder?: SortOrder
  }

  export type ProjectStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isUrgent?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    orderIndex?: SortOrder
  }

  export type ProjectStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isUrgent?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isUrgent?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatusSumOrderByAggregateInput = {
    id?: SortOrder
    orderIndex?: SortOrder
  }

  export type TaskStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isBlocking?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    orderIndex?: SortOrder
  }

  export type TaskStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isBlocking?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    isDefault?: SortOrder
    isFinal?: SortOrder
    isBlocking?: SortOrder
    orderIndex?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskStatusSumOrderByAggregateInput = {
    id?: SortOrder
    orderIndex?: SortOrder
  }

  export type StatSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricKey?: SortOrder
    value?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type StatSnapshotAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
  }

  export type StatSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricKey?: SortOrder
    value?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type StatSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metricKey?: SortOrder
    value?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type StatSnapshotSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    value?: SortOrder
  }

  export type ProductivitySnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductivitySnapshotAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    score?: SortOrder
  }

  export type ProductivitySnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductivitySnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    score?: SortOrder
    breakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductivitySnapshotSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    score?: SortOrder
  }

  export type ForecastSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    predictedDate?: SortOrder
    riskLevel?: SortOrder
    confidence?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type ForecastSnapshotAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    confidence?: SortOrder
  }

  export type ForecastSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    predictedDate?: SortOrder
    riskLevel?: SortOrder
    confidence?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type ForecastSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    predictedDate?: SortOrder
    riskLevel?: SortOrder
    confidence?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type ForecastSnapshotSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    confidence?: SortOrder
  }

  export type ActivityLogCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput> | ActivityLogCreateWithoutPerformedByInput[] | ActivityLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPerformedByInput | ActivityLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: ActivityLogCreateManyPerformedByInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutAffectedUserInput = {
    create?: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput> | ActivityLogCreateWithoutAffectedUserInput[] | ActivityLogUncheckedCreateWithoutAffectedUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffectedUserInput | ActivityLogCreateOrConnectWithoutAffectedUserInput[]
    createMany?: ActivityLogCreateManyAffectedUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput> | AttachmentCreateWithoutUploaderInput[] | AttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUploaderInput | AttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: AttachmentCreateManyUploaderInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AutomationRuleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput> | AutomationRuleCreateWithoutCreatorInput[] | AutomationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatorInput | AutomationRuleCreateOrConnectWithoutCreatorInput[]
    createMany?: AutomationRuleCreateManyCreatorInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentMentionCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput> | CommentMentionCreateWithoutUserInput[] | CommentMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutUserInput | CommentMentionCreateOrConnectWithoutUserInput[]
    createMany?: CommentMentionCreateManyUserInputEnvelope
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProjectNotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput> | ProjectNotificationPreferenceCreateWithoutUserInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutUserInput | ProjectNotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: ProjectNotificationPreferenceCreateManyUserInputEnvelope
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
  }

  export type ProjectNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput> | ProjectNotificationCreateWithoutUserInput[] | ProjectNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutUserInput | ProjectNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectNotificationCreateManyUserInputEnvelope
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
  }

  export type ProjectSettingCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput> | ProjectSettingCreateWithoutUpdaterInput[] | ProjectSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutUpdaterInput | ProjectSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: ProjectSettingCreateManyUpdaterInputEnvelope
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
  }

  export type ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput> | ProjectSettingsChangeLogCreateWithoutChangerInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput | ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    createMany?: ProjectSettingsChangeLogCreateManyChangerInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutUrgentMarkedByInput = {
    create?: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput> | ProjectCreateWithoutUrgentMarkedByInput[] | ProjectUncheckedCreateWithoutUrgentMarkedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentMarkedByInput | ProjectCreateOrConnectWithoutUrgentMarkedByInput[]
    createMany?: ProjectCreateManyUrgentMarkedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SettingsChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput> | SettingsChangeLogCreateWithoutUserInput[] | SettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutUserInput | SettingsChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: SettingsChangeLogCreateManyUserInputEnvelope
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput> | SubtaskCreateWithoutCreatorInput[] | SubtaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutCreatorInput | SubtaskCreateOrConnectWithoutCreatorInput[]
    createMany?: SubtaskCreateManyCreatorInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput> | SubtaskCreateWithoutAssignedToInput[] | SubtaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssignedToInput | SubtaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: SubtaskCreateManyAssignedToInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type SystemSettingCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput> | SystemSettingCreateWithoutUpdaterInput[] | SystemSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdaterInput | SystemSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: SystemSettingCreateManyUpdaterInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserSettingCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput> | UserSettingCreateWithoutUpdaterInput[] | UserSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUpdaterInput | UserSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: UserSettingCreateManyUpdaterInputEnvelope
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserSettingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput> | UserSettingCreateWithoutUserInput[] | UserSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput | UserSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserSettingCreateManyUserInputEnvelope
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserSettingsChangeLogCreateNestedManyWithoutChangerInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput> | UserSettingsChangeLogCreateWithoutChangerInput[] | UserSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutChangerInput | UserSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    createMany?: UserSettingsChangeLogCreateManyChangerInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type UserSettingsChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput> | UserSettingsChangeLogCreateWithoutUserInput[] | UserSettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutUserInput | UserSettingsChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: UserSettingsChangeLogCreateManyUserInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type TeamCreateNestedOneWithoutUsersInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    connect?: TeamWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput> | TaskCreateWithoutAssigneesInput[] | TaskUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput | TaskCreateOrConnectWithoutAssigneesInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutTeamLeadInput = {
    create?: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput> | TeamCreateWithoutTeamLeadInput[] | TeamUncheckedCreateWithoutTeamLeadInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeamLeadInput | TeamCreateOrConnectWithoutTeamLeadInput[]
    createMany?: TeamCreateManyTeamLeadInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutAssignerInput = {
    create?: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput> | UserRoleCreateWithoutAssignerInput[] | UserRoleUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignerInput | UserRoleCreateOrConnectWithoutAssignerInput[]
    createMany?: UserRoleCreateManyAssignerInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput> | UrgentProjectAcknowledgementCreateWithoutUserInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput | UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyUserInputEnvelope
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput> | ActivityLogCreateWithoutPerformedByInput[] | ActivityLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPerformedByInput | ActivityLogCreateOrConnectWithoutPerformedByInput[]
    createMany?: ActivityLogCreateManyPerformedByInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput = {
    create?: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput> | ActivityLogCreateWithoutAffectedUserInput[] | ActivityLogUncheckedCreateWithoutAffectedUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffectedUserInput | ActivityLogCreateOrConnectWithoutAffectedUserInput[]
    createMany?: ActivityLogCreateManyAffectedUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput> | AttachmentCreateWithoutUploaderInput[] | AttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUploaderInput | AttachmentCreateOrConnectWithoutUploaderInput[]
    createMany?: AttachmentCreateManyUploaderInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput> | AutomationRuleCreateWithoutCreatorInput[] | AutomationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatorInput | AutomationRuleCreateOrConnectWithoutCreatorInput[]
    createMany?: AutomationRuleCreateManyCreatorInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentMentionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput> | CommentMentionCreateWithoutUserInput[] | CommentMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutUserInput | CommentMentionCreateOrConnectWithoutUserInput[]
    createMany?: CommentMentionCreateManyUserInputEnvelope
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput> | ProjectNotificationPreferenceCreateWithoutUserInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutUserInput | ProjectNotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: ProjectNotificationPreferenceCreateManyUserInputEnvelope
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
  }

  export type ProjectNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput> | ProjectNotificationCreateWithoutUserInput[] | ProjectNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutUserInput | ProjectNotificationCreateOrConnectWithoutUserInput[]
    createMany?: ProjectNotificationCreateManyUserInputEnvelope
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
  }

  export type ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput> | ProjectSettingCreateWithoutUpdaterInput[] | ProjectSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutUpdaterInput | ProjectSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: ProjectSettingCreateManyUpdaterInputEnvelope
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
  }

  export type ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput> | ProjectSettingsChangeLogCreateWithoutChangerInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput | ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    createMany?: ProjectSettingsChangeLogCreateManyChangerInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput = {
    create?: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput> | ProjectCreateWithoutUrgentMarkedByInput[] | ProjectUncheckedCreateWithoutUrgentMarkedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentMarkedByInput | ProjectCreateOrConnectWithoutUrgentMarkedByInput[]
    createMany?: ProjectCreateManyUrgentMarkedByInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput> | SettingsChangeLogCreateWithoutUserInput[] | SettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutUserInput | SettingsChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: SettingsChangeLogCreateManyUserInputEnvelope
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput> | SubtaskCreateWithoutCreatorInput[] | SubtaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutCreatorInput | SubtaskCreateOrConnectWithoutCreatorInput[]
    createMany?: SubtaskCreateManyCreatorInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput> | SubtaskCreateWithoutAssignedToInput[] | SubtaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssignedToInput | SubtaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: SubtaskCreateManyAssignedToInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput> | SystemSettingCreateWithoutUpdaterInput[] | SystemSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdaterInput | SystemSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: SystemSettingCreateManyUpdaterInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserSettingUncheckedCreateNestedManyWithoutUpdaterInput = {
    create?: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput> | UserSettingCreateWithoutUpdaterInput[] | UserSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUpdaterInput | UserSettingCreateOrConnectWithoutUpdaterInput[]
    createMany?: UserSettingCreateManyUpdaterInputEnvelope
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserSettingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput> | UserSettingCreateWithoutUserInput[] | UserSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput | UserSettingCreateOrConnectWithoutUserInput[]
    createMany?: UserSettingCreateManyUserInputEnvelope
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
  }

  export type UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput> | UserSettingsChangeLogCreateWithoutChangerInput[] | UserSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutChangerInput | UserSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    createMany?: UserSettingsChangeLogCreateManyChangerInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput> | UserSettingsChangeLogCreateWithoutUserInput[] | UserSettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutUserInput | UserSettingsChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: UserSettingsChangeLogCreateManyUserInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneesInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput> | TaskCreateWithoutAssigneesInput[] | TaskUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput | TaskCreateOrConnectWithoutAssigneesInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutTeamLeadInput = {
    create?: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput> | TeamCreateWithoutTeamLeadInput[] | TeamUncheckedCreateWithoutTeamLeadInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeamLeadInput | TeamCreateOrConnectWithoutTeamLeadInput[]
    createMany?: TeamCreateManyTeamLeadInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutAssignerInput = {
    create?: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput> | UserRoleCreateWithoutAssignerInput[] | UserRoleUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignerInput | UserRoleCreateOrConnectWithoutAssignerInput[]
    createMany?: UserRoleCreateManyAssignerInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput> | UrgentProjectAcknowledgementCreateWithoutUserInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput | UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyUserInputEnvelope
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ActivityLogUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput> | ActivityLogCreateWithoutPerformedByInput[] | ActivityLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPerformedByInput | ActivityLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutPerformedByInput | ActivityLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: ActivityLogCreateManyPerformedByInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutPerformedByInput | ActivityLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutPerformedByInput | ActivityLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutAffectedUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput> | ActivityLogCreateWithoutAffectedUserInput[] | ActivityLogUncheckedCreateWithoutAffectedUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffectedUserInput | ActivityLogCreateOrConnectWithoutAffectedUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAffectedUserInput | ActivityLogUpsertWithWhereUniqueWithoutAffectedUserInput[]
    createMany?: ActivityLogCreateManyAffectedUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAffectedUserInput | ActivityLogUpdateWithWhereUniqueWithoutAffectedUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAffectedUserInput | ActivityLogUpdateManyWithWhereWithoutAffectedUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput> | AttachmentCreateWithoutUploaderInput[] | AttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUploaderInput | AttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUploaderInput | AttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: AttachmentCreateManyUploaderInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUploaderInput | AttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUploaderInput | AttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AutomationRuleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput> | AutomationRuleCreateWithoutCreatorInput[] | AutomationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatorInput | AutomationRuleCreateOrConnectWithoutCreatorInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutCreatorInput | AutomationRuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AutomationRuleCreateManyCreatorInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutCreatorInput | AutomationRuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutCreatorInput | AutomationRuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentMentionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput> | CommentMentionCreateWithoutUserInput[] | CommentMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutUserInput | CommentMentionCreateOrConnectWithoutUserInput[]
    upsert?: CommentMentionUpsertWithWhereUniqueWithoutUserInput | CommentMentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentMentionCreateManyUserInputEnvelope
    set?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    disconnect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    delete?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    update?: CommentMentionUpdateWithWhereUniqueWithoutUserInput | CommentMentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentMentionUpdateManyWithWhereWithoutUserInput | CommentMentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput> | ProjectNotificationPreferenceCreateWithoutUserInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutUserInput | ProjectNotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectNotificationPreferenceCreateManyUserInputEnvelope
    set?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    disconnect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    delete?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    update?: ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectNotificationPreferenceUpdateManyWithWhereWithoutUserInput | ProjectNotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
  }

  export type ProjectNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput> | ProjectNotificationCreateWithoutUserInput[] | ProjectNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutUserInput | ProjectNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectNotificationUpsertWithWhereUniqueWithoutUserInput | ProjectNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectNotificationCreateManyUserInputEnvelope
    set?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    disconnect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    delete?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    update?: ProjectNotificationUpdateWithWhereUniqueWithoutUserInput | ProjectNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectNotificationUpdateManyWithWhereWithoutUserInput | ProjectNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
  }

  export type ProjectSettingUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput> | ProjectSettingCreateWithoutUpdaterInput[] | ProjectSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutUpdaterInput | ProjectSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: ProjectSettingUpsertWithWhereUniqueWithoutUpdaterInput | ProjectSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: ProjectSettingCreateManyUpdaterInputEnvelope
    set?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    disconnect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    delete?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    update?: ProjectSettingUpdateWithWhereUniqueWithoutUpdaterInput | ProjectSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: ProjectSettingUpdateManyWithWhereWithoutUpdaterInput | ProjectSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
  }

  export type ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput> | ProjectSettingsChangeLogCreateWithoutChangerInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput | ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: ProjectSettingsChangeLogCreateManyChangerInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutChangerInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutUrgentMarkedByNestedInput = {
    create?: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput> | ProjectCreateWithoutUrgentMarkedByInput[] | ProjectUncheckedCreateWithoutUrgentMarkedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentMarkedByInput | ProjectCreateOrConnectWithoutUrgentMarkedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUrgentMarkedByInput | ProjectUpsertWithWhereUniqueWithoutUrgentMarkedByInput[]
    createMany?: ProjectCreateManyUrgentMarkedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUrgentMarkedByInput | ProjectUpdateWithWhereUniqueWithoutUrgentMarkedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUrgentMarkedByInput | ProjectUpdateManyWithWhereWithoutUrgentMarkedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SettingsChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput> | SettingsChangeLogCreateWithoutUserInput[] | SettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutUserInput | SettingsChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: SettingsChangeLogUpsertWithWhereUniqueWithoutUserInput | SettingsChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettingsChangeLogCreateManyUserInputEnvelope
    set?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    disconnect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    delete?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    update?: SettingsChangeLogUpdateWithWhereUniqueWithoutUserInput | SettingsChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettingsChangeLogUpdateManyWithWhereWithoutUserInput | SettingsChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput> | SubtaskCreateWithoutCreatorInput[] | SubtaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutCreatorInput | SubtaskCreateOrConnectWithoutCreatorInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutCreatorInput | SubtaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubtaskCreateManyCreatorInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutCreatorInput | SubtaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutCreatorInput | SubtaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput> | SubtaskCreateWithoutAssignedToInput[] | SubtaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssignedToInput | SubtaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssignedToInput | SubtaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SubtaskCreateManyAssignedToInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssignedToInput | SubtaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssignedToInput | SubtaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type SystemSettingUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput> | SystemSettingCreateWithoutUpdaterInput[] | SystemSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdaterInput | SystemSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdaterInput | SystemSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: SystemSettingCreateManyUpdaterInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdaterInput | SystemSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdaterInput | SystemSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserSettingUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput> | UserSettingCreateWithoutUpdaterInput[] | UserSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUpdaterInput | UserSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUpdaterInput | UserSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: UserSettingCreateManyUpdaterInputEnvelope
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUpdaterInput | UserSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUpdaterInput | UserSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserSettingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput> | UserSettingCreateWithoutUserInput[] | UserSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput | UserSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUserInput | UserSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSettingCreateManyUserInputEnvelope
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUserInput | UserSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUserInput | UserSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserSettingsChangeLogUpdateManyWithoutChangerNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput> | UserSettingsChangeLogCreateWithoutChangerInput[] | UserSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutChangerInput | UserSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: UserSettingsChangeLogCreateManyChangerInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutChangerInput | UserSettingsChangeLogUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type UserSettingsChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput> | UserSettingsChangeLogCreateWithoutUserInput[] | UserSettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutUserInput | UserSettingsChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutUserInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSettingsChangeLogCreateManyUserInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutUserInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutUserInput | UserSettingsChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type TeamUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput
    upsert?: TeamUpsertWithoutUsersInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutUsersInput, TeamUpdateWithoutUsersInput>, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TaskUpdateManyWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput> | TaskCreateWithoutAssigneesInput[] | TaskUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput | TaskCreateOrConnectWithoutAssigneesInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneesInput | TaskUpsertWithWhereUniqueWithoutAssigneesInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneesInput | TaskUpdateWithWhereUniqueWithoutAssigneesInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneesInput | TaskUpdateManyWithWhereWithoutAssigneesInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutTeamLeadNestedInput = {
    create?: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput> | TeamCreateWithoutTeamLeadInput[] | TeamUncheckedCreateWithoutTeamLeadInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeamLeadInput | TeamCreateOrConnectWithoutTeamLeadInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTeamLeadInput | TeamUpsertWithWhereUniqueWithoutTeamLeadInput[]
    createMany?: TeamCreateManyTeamLeadInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTeamLeadInput | TeamUpdateWithWhereUniqueWithoutTeamLeadInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTeamLeadInput | TeamUpdateManyWithWhereWithoutTeamLeadInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput> | UserRoleCreateWithoutAssignerInput[] | UserRoleUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignerInput | UserRoleCreateOrConnectWithoutAssignerInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignerInput | UserRoleUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: UserRoleCreateManyAssignerInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignerInput | UserRoleUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignerInput | UserRoleUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput> | UrgentProjectAcknowledgementCreateWithoutUserInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput | UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput[]
    upsert?: UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutUserInput | UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyUserInputEnvelope
    set?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    disconnect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    delete?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    update?: UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutUserInput | UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UrgentProjectAcknowledgementUpdateManyWithWhereWithoutUserInput | UrgentProjectAcknowledgementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput> | ActivityLogCreateWithoutPerformedByInput[] | ActivityLogUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPerformedByInput | ActivityLogCreateOrConnectWithoutPerformedByInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutPerformedByInput | ActivityLogUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: ActivityLogCreateManyPerformedByInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutPerformedByInput | ActivityLogUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutPerformedByInput | ActivityLogUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput> | ActivityLogCreateWithoutAffectedUserInput[] | ActivityLogUncheckedCreateWithoutAffectedUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffectedUserInput | ActivityLogCreateOrConnectWithoutAffectedUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAffectedUserInput | ActivityLogUpsertWithWhereUniqueWithoutAffectedUserInput[]
    createMany?: ActivityLogCreateManyAffectedUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAffectedUserInput | ActivityLogUpdateWithWhereUniqueWithoutAffectedUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAffectedUserInput | ActivityLogUpdateManyWithWhereWithoutAffectedUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput> | AttachmentCreateWithoutUploaderInput[] | AttachmentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutUploaderInput | AttachmentCreateOrConnectWithoutUploaderInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutUploaderInput | AttachmentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: AttachmentCreateManyUploaderInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutUploaderInput | AttachmentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutUploaderInput | AttachmentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput> | AutomationRuleCreateWithoutCreatorInput[] | AutomationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutCreatorInput | AutomationRuleCreateOrConnectWithoutCreatorInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutCreatorInput | AutomationRuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AutomationRuleCreateManyCreatorInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutCreatorInput | AutomationRuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutCreatorInput | AutomationRuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentMentionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput> | CommentMentionCreateWithoutUserInput[] | CommentMentionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutUserInput | CommentMentionCreateOrConnectWithoutUserInput[]
    upsert?: CommentMentionUpsertWithWhereUniqueWithoutUserInput | CommentMentionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentMentionCreateManyUserInputEnvelope
    set?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    disconnect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    delete?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    update?: CommentMentionUpdateWithWhereUniqueWithoutUserInput | CommentMentionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentMentionUpdateManyWithWhereWithoutUserInput | CommentMentionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput> | ProjectNotificationPreferenceCreateWithoutUserInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutUserInput | ProjectNotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectNotificationPreferenceCreateManyUserInputEnvelope
    set?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    disconnect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    delete?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    update?: ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectNotificationPreferenceUpdateManyWithWhereWithoutUserInput | ProjectNotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
  }

  export type ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput> | ProjectNotificationCreateWithoutUserInput[] | ProjectNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutUserInput | ProjectNotificationCreateOrConnectWithoutUserInput[]
    upsert?: ProjectNotificationUpsertWithWhereUniqueWithoutUserInput | ProjectNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectNotificationCreateManyUserInputEnvelope
    set?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    disconnect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    delete?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    update?: ProjectNotificationUpdateWithWhereUniqueWithoutUserInput | ProjectNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectNotificationUpdateManyWithWhereWithoutUserInput | ProjectNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
  }

  export type ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput> | ProjectSettingCreateWithoutUpdaterInput[] | ProjectSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutUpdaterInput | ProjectSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: ProjectSettingUpsertWithWhereUniqueWithoutUpdaterInput | ProjectSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: ProjectSettingCreateManyUpdaterInputEnvelope
    set?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    disconnect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    delete?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    update?: ProjectSettingUpdateWithWhereUniqueWithoutUpdaterInput | ProjectSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: ProjectSettingUpdateManyWithWhereWithoutUpdaterInput | ProjectSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput> | ProjectSettingsChangeLogCreateWithoutChangerInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput | ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: ProjectSettingsChangeLogCreateManyChangerInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutChangerInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput = {
    create?: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput> | ProjectCreateWithoutUrgentMarkedByInput[] | ProjectUncheckedCreateWithoutUrgentMarkedByInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentMarkedByInput | ProjectCreateOrConnectWithoutUrgentMarkedByInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUrgentMarkedByInput | ProjectUpsertWithWhereUniqueWithoutUrgentMarkedByInput[]
    createMany?: ProjectCreateManyUrgentMarkedByInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUrgentMarkedByInput | ProjectUpdateWithWhereUniqueWithoutUrgentMarkedByInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUrgentMarkedByInput | ProjectUpdateManyWithWhereWithoutUrgentMarkedByInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput> | SettingsChangeLogCreateWithoutUserInput[] | SettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutUserInput | SettingsChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: SettingsChangeLogUpsertWithWhereUniqueWithoutUserInput | SettingsChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettingsChangeLogCreateManyUserInputEnvelope
    set?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    disconnect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    delete?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    update?: SettingsChangeLogUpdateWithWhereUniqueWithoutUserInput | SettingsChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettingsChangeLogUpdateManyWithWhereWithoutUserInput | SettingsChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput> | SubtaskCreateWithoutCreatorInput[] | SubtaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutCreatorInput | SubtaskCreateOrConnectWithoutCreatorInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutCreatorInput | SubtaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SubtaskCreateManyCreatorInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutCreatorInput | SubtaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutCreatorInput | SubtaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput> | SubtaskCreateWithoutAssignedToInput[] | SubtaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutAssignedToInput | SubtaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutAssignedToInput | SubtaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SubtaskCreateManyAssignedToInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutAssignedToInput | SubtaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutAssignedToInput | SubtaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput> | SystemSettingCreateWithoutUpdaterInput[] | SystemSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdaterInput | SystemSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdaterInput | SystemSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: SystemSettingCreateManyUpdaterInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdaterInput | SystemSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdaterInput | SystemSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput = {
    create?: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput> | UserSettingCreateWithoutUpdaterInput[] | UserSettingUncheckedCreateWithoutUpdaterInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUpdaterInput | UserSettingCreateOrConnectWithoutUpdaterInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUpdaterInput | UserSettingUpsertWithWhereUniqueWithoutUpdaterInput[]
    createMany?: UserSettingCreateManyUpdaterInputEnvelope
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUpdaterInput | UserSettingUpdateWithWhereUniqueWithoutUpdaterInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUpdaterInput | UserSettingUpdateManyWithWhereWithoutUpdaterInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserSettingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput> | UserSettingCreateWithoutUserInput[] | UserSettingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingCreateOrConnectWithoutUserInput | UserSettingCreateOrConnectWithoutUserInput[]
    upsert?: UserSettingUpsertWithWhereUniqueWithoutUserInput | UserSettingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSettingCreateManyUserInputEnvelope
    set?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    disconnect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    delete?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    connect?: UserSettingWhereUniqueInput | UserSettingWhereUniqueInput[]
    update?: UserSettingUpdateWithWhereUniqueWithoutUserInput | UserSettingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSettingUpdateManyWithWhereWithoutUserInput | UserSettingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput> | UserSettingsChangeLogCreateWithoutChangerInput[] | UserSettingsChangeLogUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutChangerInput | UserSettingsChangeLogCreateOrConnectWithoutChangerInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: UserSettingsChangeLogCreateManyChangerInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutChangerInput | UserSettingsChangeLogUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput> | UserSettingsChangeLogCreateWithoutUserInput[] | UserSettingsChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutUserInput | UserSettingsChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutUserInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSettingsChangeLogCreateManyUserInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutUserInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutUserInput | UserSettingsChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneesNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput> | TaskCreateWithoutAssigneesInput[] | TaskUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneesInput | TaskCreateOrConnectWithoutAssigneesInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneesInput | TaskUpsertWithWhereUniqueWithoutAssigneesInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneesInput | TaskUpdateWithWhereUniqueWithoutAssigneesInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneesInput | TaskUpdateManyWithWhereWithoutAssigneesInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutTeamLeadNestedInput = {
    create?: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput> | TeamCreateWithoutTeamLeadInput[] | TeamUncheckedCreateWithoutTeamLeadInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutTeamLeadInput | TeamCreateOrConnectWithoutTeamLeadInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutTeamLeadInput | TeamUpsertWithWhereUniqueWithoutTeamLeadInput[]
    createMany?: TeamCreateManyTeamLeadInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutTeamLeadInput | TeamUpdateWithWhereUniqueWithoutTeamLeadInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutTeamLeadInput | TeamUpdateManyWithWhereWithoutTeamLeadInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignerNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput> | UserRoleCreateWithoutAssignerInput[] | UserRoleUncheckedCreateWithoutAssignerInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignerInput | UserRoleCreateOrConnectWithoutAssignerInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignerInput | UserRoleUpsertWithWhereUniqueWithoutAssignerInput[]
    createMany?: UserRoleCreateManyAssignerInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignerInput | UserRoleUpdateWithWhereUniqueWithoutAssignerInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignerInput | UserRoleUpdateManyWithWhereWithoutAssignerInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput> | UrgentProjectAcknowledgementCreateWithoutUserInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput | UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput[]
    upsert?: UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutUserInput | UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyUserInputEnvelope
    set?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    disconnect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    delete?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    update?: UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutUserInput | UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UrgentProjectAcknowledgementUpdateManyWithWhereWithoutUserInput | UrgentProjectAcknowledgementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
  }

  export type AutomationRuleCreateNestedManyWithoutTeamInput = {
    create?: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput> | AutomationRuleCreateWithoutTeamInput[] | AutomationRuleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTeamInput | AutomationRuleCreateOrConnectWithoutTeamInput[]
    createMany?: AutomationRuleCreateManyTeamInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutTeamInput = {
    create?: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput> | SubtaskCreateWithoutTeamInput[] | SubtaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTeamInput | SubtaskCreateOrConnectWithoutTeamInput[]
    createMany?: SubtaskCreateManyTeamInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTeamsLedInput = {
    create?: XOR<UserCreateWithoutTeamsLedInput, UserUncheckedCreateWithoutTeamsLedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsLedInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ProjectTeamCreateNestedManyWithoutTeamInput = {
    create?: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput> | ProjectTeamCreateWithoutTeamInput[] | ProjectTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutTeamInput | ProjectTeamCreateOrConnectWithoutTeamInput[]
    createMany?: ProjectTeamCreateManyTeamInputEnvelope
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
  }

  export type AutomationRuleUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput> | AutomationRuleCreateWithoutTeamInput[] | AutomationRuleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTeamInput | AutomationRuleCreateOrConnectWithoutTeamInput[]
    createMany?: AutomationRuleCreateManyTeamInputEnvelope
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput> | SubtaskCreateWithoutTeamInput[] | SubtaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTeamInput | SubtaskCreateOrConnectWithoutTeamInput[]
    createMany?: SubtaskCreateManyTeamInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type ProjectTeamUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput> | ProjectTeamCreateWithoutTeamInput[] | ProjectTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutTeamInput | ProjectTeamCreateOrConnectWithoutTeamInput[]
    createMany?: ProjectTeamCreateManyTeamInputEnvelope
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
  }

  export type AutomationRuleUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput> | AutomationRuleCreateWithoutTeamInput[] | AutomationRuleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTeamInput | AutomationRuleCreateOrConnectWithoutTeamInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutTeamInput | AutomationRuleUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AutomationRuleCreateManyTeamInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutTeamInput | AutomationRuleUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutTeamInput | AutomationRuleUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput> | SubtaskCreateWithoutTeamInput[] | SubtaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTeamInput | SubtaskCreateOrConnectWithoutTeamInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTeamInput | SubtaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SubtaskCreateManyTeamInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTeamInput | SubtaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTeamInput | SubtaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutTeamsLedNestedInput = {
    create?: XOR<UserCreateWithoutTeamsLedInput, UserUncheckedCreateWithoutTeamsLedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsLedInput
    upsert?: UserUpsertWithoutTeamsLedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsLedInput, UserUpdateWithoutTeamsLedInput>, UserUncheckedUpdateWithoutTeamsLedInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ProjectTeamUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput> | ProjectTeamCreateWithoutTeamInput[] | ProjectTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutTeamInput | ProjectTeamCreateOrConnectWithoutTeamInput[]
    upsert?: ProjectTeamUpsertWithWhereUniqueWithoutTeamInput | ProjectTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ProjectTeamCreateManyTeamInputEnvelope
    set?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    disconnect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    delete?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    update?: ProjectTeamUpdateWithWhereUniqueWithoutTeamInput | ProjectTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ProjectTeamUpdateManyWithWhereWithoutTeamInput | ProjectTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
  }

  export type AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput> | AutomationRuleCreateWithoutTeamInput[] | AutomationRuleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AutomationRuleCreateOrConnectWithoutTeamInput | AutomationRuleCreateOrConnectWithoutTeamInput[]
    upsert?: AutomationRuleUpsertWithWhereUniqueWithoutTeamInput | AutomationRuleUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AutomationRuleCreateManyTeamInputEnvelope
    set?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    disconnect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    delete?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    connect?: AutomationRuleWhereUniqueInput | AutomationRuleWhereUniqueInput[]
    update?: AutomationRuleUpdateWithWhereUniqueWithoutTeamInput | AutomationRuleUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AutomationRuleUpdateManyWithWhereWithoutTeamInput | AutomationRuleUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput> | SubtaskCreateWithoutTeamInput[] | SubtaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutTeamInput | SubtaskCreateOrConnectWithoutTeamInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutTeamInput | SubtaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: SubtaskCreateManyTeamInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutTeamInput | SubtaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutTeamInput | SubtaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput> | UserCreateWithoutTeamInput[] | UserUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamInput | UserCreateOrConnectWithoutTeamInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamInput | UserUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserCreateManyTeamInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamInput | UserUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamInput | UserUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput> | ProjectTeamCreateWithoutTeamInput[] | ProjectTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutTeamInput | ProjectTeamCreateOrConnectWithoutTeamInput[]
    upsert?: ProjectTeamUpsertWithWhereUniqueWithoutTeamInput | ProjectTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ProjectTeamCreateManyTeamInputEnvelope
    set?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    disconnect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    delete?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    update?: ProjectTeamUpdateWithWhereUniqueWithoutTeamInput | ProjectTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ProjectTeamUpdateManyWithWhereWithoutTeamInput | ProjectTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
  }

  export type DeliverableCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput> | DeliverableCreateWithoutProjectInput[] | DeliverableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeliverableCreateOrConnectWithoutProjectInput | DeliverableCreateOrConnectWithoutProjectInput[]
    createMany?: DeliverableCreateManyProjectInputEnvelope
    connect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
  }

  export type ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput> | ProjectNotificationPreferenceCreateWithoutProjectInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput | ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotificationPreferenceCreateManyProjectInputEnvelope
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
  }

  export type ProjectNotificationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput> | ProjectNotificationCreateWithoutProjectInput[] | ProjectNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutProjectInput | ProjectNotificationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotificationCreateManyProjectInputEnvelope
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
  }

  export type ProjectPhaseCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type ProjectSettingCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput> | ProjectSettingCreateWithoutProjectInput[] | ProjectSettingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutProjectInput | ProjectSettingCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingCreateManyProjectInputEnvelope
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
  }

  export type ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput> | ProjectSettingsChangeLogCreateWithoutProjectInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput | ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingsChangeLogCreateManyProjectInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type ProjectUserCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProjectsManagedInput = {
    create?: XOR<UserCreateWithoutProjectsManagedInput, UserUncheckedCreateWithoutProjectsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsManagedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectsMarkedUrgentInput = {
    create?: XOR<UserCreateWithoutProjectsMarkedUrgentInput, UserUncheckedCreateWithoutProjectsMarkedUrgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsMarkedUrgentInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectTypeCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectTypeCreateOrConnectWithoutProjectsInput
    connect?: ProjectTypeWhereUniqueInput
  }

  export type ProjectStatusCreateNestedOneWithoutProjectsInput = {
    create?: XOR<ProjectStatusCreateWithoutProjectsInput, ProjectStatusUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusCreateOrConnectWithoutProjectsInput
    connect?: ProjectStatusWhereUniqueInput
  }

  export type ScopeHistoryCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput> | ScopeHistoryCreateWithoutProjectInput[] | ScopeHistoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScopeHistoryCreateOrConnectWithoutProjectInput | ScopeHistoryCreateOrConnectWithoutProjectInput[]
    createMany?: ScopeHistoryCreateManyProjectInputEnvelope
    connect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput> | ActivityLogCreateWithoutProjectInput[] | ActivityLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProjectInput | ActivityLogCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityLogCreateManyProjectInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ProjectTeamCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput> | ProjectTeamCreateWithoutProjectInput[] | ProjectTeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutProjectInput | ProjectTeamCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTeamCreateManyProjectInputEnvelope
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
  }

  export type UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput> | UrgentProjectAcknowledgementCreateWithoutProjectInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput | UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyProjectInputEnvelope
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
  }

  export type DeliverableUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput> | DeliverableCreateWithoutProjectInput[] | DeliverableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeliverableCreateOrConnectWithoutProjectInput | DeliverableCreateOrConnectWithoutProjectInput[]
    createMany?: DeliverableCreateManyProjectInputEnvelope
    connect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
  }

  export type ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput> | ProjectNotificationPreferenceCreateWithoutProjectInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput | ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotificationPreferenceCreateManyProjectInputEnvelope
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
  }

  export type ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput> | ProjectNotificationCreateWithoutProjectInput[] | ProjectNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutProjectInput | ProjectNotificationCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectNotificationCreateManyProjectInputEnvelope
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
  }

  export type ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
  }

  export type ProjectSettingUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput> | ProjectSettingCreateWithoutProjectInput[] | ProjectSettingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutProjectInput | ProjectSettingCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingCreateManyProjectInputEnvelope
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
  }

  export type ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput> | ProjectSettingsChangeLogCreateWithoutProjectInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput | ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSettingsChangeLogCreateManyProjectInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type ProjectUserUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
  }

  export type ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput> | ScopeHistoryCreateWithoutProjectInput[] | ScopeHistoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScopeHistoryCreateOrConnectWithoutProjectInput | ScopeHistoryCreateOrConnectWithoutProjectInput[]
    createMany?: ScopeHistoryCreateManyProjectInputEnvelope
    connect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput> | ActivityLogCreateWithoutProjectInput[] | ActivityLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProjectInput | ActivityLogCreateOrConnectWithoutProjectInput[]
    createMany?: ActivityLogCreateManyProjectInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ProjectTeamUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput> | ProjectTeamCreateWithoutProjectInput[] | ProjectTeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutProjectInput | ProjectTeamCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTeamCreateManyProjectInputEnvelope
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
  }

  export type UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput> | UrgentProjectAcknowledgementCreateWithoutProjectInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput | UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyProjectInputEnvelope
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DeliverableUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput> | DeliverableCreateWithoutProjectInput[] | DeliverableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeliverableCreateOrConnectWithoutProjectInput | DeliverableCreateOrConnectWithoutProjectInput[]
    upsert?: DeliverableUpsertWithWhereUniqueWithoutProjectInput | DeliverableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeliverableCreateManyProjectInputEnvelope
    set?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    disconnect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    delete?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    connect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    update?: DeliverableUpdateWithWhereUniqueWithoutProjectInput | DeliverableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeliverableUpdateManyWithWhereWithoutProjectInput | DeliverableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeliverableScalarWhereInput | DeliverableScalarWhereInput[]
  }

  export type ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput> | ProjectNotificationPreferenceCreateWithoutProjectInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput | ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutProjectInput | ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotificationPreferenceCreateManyProjectInputEnvelope
    set?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    disconnect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    delete?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    update?: ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutProjectInput | ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotificationPreferenceUpdateManyWithWhereWithoutProjectInput | ProjectNotificationPreferenceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
  }

  export type ProjectNotificationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput> | ProjectNotificationCreateWithoutProjectInput[] | ProjectNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutProjectInput | ProjectNotificationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotificationUpsertWithWhereUniqueWithoutProjectInput | ProjectNotificationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotificationCreateManyProjectInputEnvelope
    set?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    disconnect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    delete?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    update?: ProjectNotificationUpdateWithWhereUniqueWithoutProjectInput | ProjectNotificationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotificationUpdateManyWithWhereWithoutProjectInput | ProjectNotificationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
  }

  export type ProjectPhaseUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput | ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput | ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutProjectInput | ProjectPhaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type ProjectSettingUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput> | ProjectSettingCreateWithoutProjectInput[] | ProjectSettingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutProjectInput | ProjectSettingCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingCreateManyProjectInputEnvelope
    set?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    disconnect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    delete?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    update?: ProjectSettingUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingUpdateManyWithWhereWithoutProjectInput | ProjectSettingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
  }

  export type ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput> | ProjectSettingsChangeLogCreateWithoutProjectInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput | ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingsChangeLogCreateManyProjectInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutProjectInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectUserUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutProjectInput | ProjectUserUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutProjectInput | ProjectUserUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutProjectInput | ProjectUserUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type UserUpdateOneWithoutProjectsManagedNestedInput = {
    create?: XOR<UserCreateWithoutProjectsManagedInput, UserUncheckedCreateWithoutProjectsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsManagedInput
    upsert?: UserUpsertWithoutProjectsManagedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsManagedInput, UserUpdateWithoutProjectsManagedInput>, UserUncheckedUpdateWithoutProjectsManagedInput>
  }

  export type UserUpdateOneWithoutProjectsMarkedUrgentNestedInput = {
    create?: XOR<UserCreateWithoutProjectsMarkedUrgentInput, UserUncheckedCreateWithoutProjectsMarkedUrgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsMarkedUrgentInput
    upsert?: UserUpsertWithoutProjectsMarkedUrgentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsMarkedUrgentInput, UserUpdateWithoutProjectsMarkedUrgentInput>, UserUncheckedUpdateWithoutProjectsMarkedUrgentInput>
  }

  export type ProjectTypeUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectTypeCreateOrConnectWithoutProjectsInput
    upsert?: ProjectTypeUpsertWithoutProjectsInput
    disconnect?: ProjectTypeWhereInput | boolean
    delete?: ProjectTypeWhereInput | boolean
    connect?: ProjectTypeWhereUniqueInput
    update?: XOR<XOR<ProjectTypeUpdateToOneWithWhereWithoutProjectsInput, ProjectTypeUpdateWithoutProjectsInput>, ProjectTypeUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectStatusUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<ProjectStatusCreateWithoutProjectsInput, ProjectStatusUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: ProjectStatusCreateOrConnectWithoutProjectsInput
    upsert?: ProjectStatusUpsertWithoutProjectsInput
    disconnect?: ProjectStatusWhereInput | boolean
    delete?: ProjectStatusWhereInput | boolean
    connect?: ProjectStatusWhereUniqueInput
    update?: XOR<XOR<ProjectStatusUpdateToOneWithWhereWithoutProjectsInput, ProjectStatusUpdateWithoutProjectsInput>, ProjectStatusUncheckedUpdateWithoutProjectsInput>
  }

  export type ScopeHistoryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput> | ScopeHistoryCreateWithoutProjectInput[] | ScopeHistoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScopeHistoryCreateOrConnectWithoutProjectInput | ScopeHistoryCreateOrConnectWithoutProjectInput[]
    upsert?: ScopeHistoryUpsertWithWhereUniqueWithoutProjectInput | ScopeHistoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScopeHistoryCreateManyProjectInputEnvelope
    set?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    disconnect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    delete?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    connect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    update?: ScopeHistoryUpdateWithWhereUniqueWithoutProjectInput | ScopeHistoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScopeHistoryUpdateManyWithWhereWithoutProjectInput | ScopeHistoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScopeHistoryScalarWhereInput | ScopeHistoryScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput> | ActivityLogCreateWithoutProjectInput[] | ActivityLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProjectInput | ActivityLogCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutProjectInput | ActivityLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityLogCreateManyProjectInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutProjectInput | ActivityLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutProjectInput | ActivityLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ProjectTeamUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput> | ProjectTeamCreateWithoutProjectInput[] | ProjectTeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutProjectInput | ProjectTeamCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTeamUpsertWithWhereUniqueWithoutProjectInput | ProjectTeamUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTeamCreateManyProjectInputEnvelope
    set?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    disconnect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    delete?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    update?: ProjectTeamUpdateWithWhereUniqueWithoutProjectInput | ProjectTeamUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTeamUpdateManyWithWhereWithoutProjectInput | ProjectTeamUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
  }

  export type UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput> | UrgentProjectAcknowledgementCreateWithoutProjectInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput | UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput[]
    upsert?: UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutProjectInput | UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyProjectInputEnvelope
    set?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    disconnect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    delete?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    update?: UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutProjectInput | UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UrgentProjectAcknowledgementUpdateManyWithWhereWithoutProjectInput | UrgentProjectAcknowledgementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
  }

  export type DeliverableUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput> | DeliverableCreateWithoutProjectInput[] | DeliverableUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DeliverableCreateOrConnectWithoutProjectInput | DeliverableCreateOrConnectWithoutProjectInput[]
    upsert?: DeliverableUpsertWithWhereUniqueWithoutProjectInput | DeliverableUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DeliverableCreateManyProjectInputEnvelope
    set?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    disconnect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    delete?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    connect?: DeliverableWhereUniqueInput | DeliverableWhereUniqueInput[]
    update?: DeliverableUpdateWithWhereUniqueWithoutProjectInput | DeliverableUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DeliverableUpdateManyWithWhereWithoutProjectInput | DeliverableUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DeliverableScalarWhereInput | DeliverableScalarWhereInput[]
  }

  export type ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput> | ProjectNotificationPreferenceCreateWithoutProjectInput[] | ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput | ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutProjectInput | ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotificationPreferenceCreateManyProjectInputEnvelope
    set?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    disconnect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    delete?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    connect?: ProjectNotificationPreferenceWhereUniqueInput | ProjectNotificationPreferenceWhereUniqueInput[]
    update?: ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutProjectInput | ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotificationPreferenceUpdateManyWithWhereWithoutProjectInput | ProjectNotificationPreferenceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
  }

  export type ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput> | ProjectNotificationCreateWithoutProjectInput[] | ProjectNotificationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectNotificationCreateOrConnectWithoutProjectInput | ProjectNotificationCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectNotificationUpsertWithWhereUniqueWithoutProjectInput | ProjectNotificationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectNotificationCreateManyProjectInputEnvelope
    set?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    disconnect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    delete?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    connect?: ProjectNotificationWhereUniqueInput | ProjectNotificationWhereUniqueInput[]
    update?: ProjectNotificationUpdateWithWhereUniqueWithoutProjectInput | ProjectNotificationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectNotificationUpdateManyWithWhereWithoutProjectInput | ProjectNotificationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput> | ProjectPhaseCreateWithoutProjectInput[] | ProjectPhaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectPhaseCreateOrConnectWithoutProjectInput | ProjectPhaseCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput | ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectPhaseCreateManyProjectInputEnvelope
    set?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    disconnect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    delete?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    connect?: ProjectPhaseWhereUniqueInput | ProjectPhaseWhereUniqueInput[]
    update?: ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput | ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectPhaseUpdateManyWithWhereWithoutProjectInput | ProjectPhaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
  }

  export type ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput> | ProjectSettingCreateWithoutProjectInput[] | ProjectSettingUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutProjectInput | ProjectSettingCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingCreateManyProjectInputEnvelope
    set?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    disconnect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    delete?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    connect?: ProjectSettingWhereUniqueInput | ProjectSettingWhereUniqueInput[]
    update?: ProjectSettingUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingUpdateManyWithWhereWithoutProjectInput | ProjectSettingUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput> | ProjectSettingsChangeLogCreateWithoutProjectInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput | ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutProjectInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSettingsChangeLogCreateManyProjectInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutProjectInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutProjectInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectUserUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput> | ProjectUserCreateWithoutProjectInput[] | ProjectUserUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUserCreateOrConnectWithoutProjectInput | ProjectUserCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUserUpsertWithWhereUniqueWithoutProjectInput | ProjectUserUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUserCreateManyProjectInputEnvelope
    set?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    disconnect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    delete?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    connect?: ProjectUserWhereUniqueInput | ProjectUserWhereUniqueInput[]
    update?: ProjectUserUpdateWithWhereUniqueWithoutProjectInput | ProjectUserUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUserUpdateManyWithWhereWithoutProjectInput | ProjectUserUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
  }

  export type ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput> | ScopeHistoryCreateWithoutProjectInput[] | ScopeHistoryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScopeHistoryCreateOrConnectWithoutProjectInput | ScopeHistoryCreateOrConnectWithoutProjectInput[]
    upsert?: ScopeHistoryUpsertWithWhereUniqueWithoutProjectInput | ScopeHistoryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScopeHistoryCreateManyProjectInputEnvelope
    set?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    disconnect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    delete?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    connect?: ScopeHistoryWhereUniqueInput | ScopeHistoryWhereUniqueInput[]
    update?: ScopeHistoryUpdateWithWhereUniqueWithoutProjectInput | ScopeHistoryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScopeHistoryUpdateManyWithWhereWithoutProjectInput | ScopeHistoryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScopeHistoryScalarWhereInput | ScopeHistoryScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput> | ActivityLogCreateWithoutProjectInput[] | ActivityLogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProjectInput | ActivityLogCreateOrConnectWithoutProjectInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutProjectInput | ActivityLogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActivityLogCreateManyProjectInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutProjectInput | ActivityLogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutProjectInput | ActivityLogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput> | ProjectTeamCreateWithoutProjectInput[] | ProjectTeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTeamCreateOrConnectWithoutProjectInput | ProjectTeamCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTeamUpsertWithWhereUniqueWithoutProjectInput | ProjectTeamUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTeamCreateManyProjectInputEnvelope
    set?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    disconnect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    delete?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    connect?: ProjectTeamWhereUniqueInput | ProjectTeamWhereUniqueInput[]
    update?: ProjectTeamUpdateWithWhereUniqueWithoutProjectInput | ProjectTeamUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTeamUpdateManyWithWhereWithoutProjectInput | ProjectTeamUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput> | UrgentProjectAcknowledgementCreateWithoutProjectInput[] | UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput | UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput[]
    upsert?: UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutProjectInput | UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: UrgentProjectAcknowledgementCreateManyProjectInputEnvelope
    set?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    disconnect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    delete?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    connect?: UrgentProjectAcknowledgementWhereUniqueInput | UrgentProjectAcknowledgementWhereUniqueInput[]
    update?: UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutProjectInput | UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: UrgentProjectAcknowledgementUpdateManyWithWhereWithoutProjectInput | UrgentProjectAcknowledgementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
  }

  export type AttachmentCreateNestedManyWithoutTaskInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SubtaskCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput> | SubtaskCreateWithoutParentTaskInput[] | SubtaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutParentTaskInput | SubtaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: SubtaskCreateManyParentTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskDependencyCreateNestedManyWithoutDependsOnTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput> | TaskDependencyCreateWithoutDependsOnTaskInput[] | TaskDependencyUncheckedCreateWithoutDependsOnTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDependsOnTaskInput | TaskDependencyCreateOrConnectWithoutDependsOnTaskInput[]
    createMany?: TaskDependencyCreateManyDependsOnTaskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    createMany?: TaskDependencyCreateManyTaskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskLabelCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type DeliverableCreateNestedOneWithoutTasksInput = {
    create?: XOR<DeliverableCreateWithoutTasksInput, DeliverableUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DeliverableCreateOrConnectWithoutTasksInput
    connect?: DeliverableWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksCreatedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTasksInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    connect?: TeamWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskStatusCreateNestedOneWithoutTasksInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    connect?: TaskStatusWhereUniqueInput
  }

  export type TimeLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SubtaskUncheckedCreateNestedManyWithoutParentTaskInput = {
    create?: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput> | SubtaskCreateWithoutParentTaskInput[] | SubtaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutParentTaskInput | SubtaskCreateOrConnectWithoutParentTaskInput[]
    createMany?: SubtaskCreateManyParentTaskInputEnvelope
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput> | TaskDependencyCreateWithoutDependsOnTaskInput[] | TaskDependencyUncheckedCreateWithoutDependsOnTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDependsOnTaskInput | TaskDependencyCreateOrConnectWithoutDependsOnTaskInput[]
    createMany?: TaskDependencyCreateManyDependsOnTaskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskDependencyUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    createMany?: TaskDependencyCreateManyTaskInputEnvelope
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AttachmentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTaskInput | AttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTaskInput | AttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTaskInput | AttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SubtaskUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput> | SubtaskCreateWithoutParentTaskInput[] | SubtaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutParentTaskInput | SubtaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutParentTaskInput | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: SubtaskCreateManyParentTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutParentTaskInput | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutParentTaskInput | SubtaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput> | TaskDependencyCreateWithoutDependsOnTaskInput[] | TaskDependencyUncheckedCreateWithoutDependsOnTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDependsOnTaskInput | TaskDependencyCreateOrConnectWithoutDependsOnTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutDependsOnTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnTaskInput[]
    createMany?: TaskDependencyCreateManyDependsOnTaskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutDependsOnTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutDependsOnTaskInput | TaskDependencyUpdateManyWithWhereWithoutDependsOnTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskDependencyCreateManyTaskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutTaskInput | TaskDependencyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskLabelUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type DeliverableUpdateOneWithoutTasksNestedInput = {
    create?: XOR<DeliverableCreateWithoutTasksInput, DeliverableUncheckedCreateWithoutTasksInput>
    connectOrCreate?: DeliverableCreateOrConnectWithoutTasksInput
    upsert?: DeliverableUpsertWithoutTasksInput
    disconnect?: DeliverableWhereInput | boolean
    delete?: DeliverableWhereInput | boolean
    connect?: DeliverableWhereUniqueInput
    update?: XOR<XOR<DeliverableUpdateToOneWithWhereWithoutTasksInput, DeliverableUpdateWithoutTasksInput>, DeliverableUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutTasksCreatedNestedInput = {
    create?: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksCreatedInput
    upsert?: UserUpsertWithoutTasksCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksCreatedInput, UserUpdateWithoutTasksCreatedInput>, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type TeamUpdateOneWithoutTasksNestedInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    upsert?: TeamUpsertWithoutTasksInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTasksInput, TeamUpdateWithoutTasksInput>, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateOneWithoutTasksNestedInput = {
    create?: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TaskStatusCreateOrConnectWithoutTasksInput
    upsert?: TaskStatusUpsertWithoutTasksInput
    disconnect?: TaskStatusWhereInput | boolean
    delete?: TaskStatusWhereInput | boolean
    connect?: TaskStatusWhereUniqueInput
    update?: XOR<XOR<TaskStatusUpdateToOneWithWhereWithoutTasksInput, TaskStatusUpdateWithoutTasksInput>, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type TimeLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserUpdateManyWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedTasksInput | UserUpsertWithWhereUniqueWithoutAssignedTasksInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedTasksInput | UserUpdateWithWhereUniqueWithoutAssignedTasksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedTasksInput | UserUpdateManyWithWhereWithoutAssignedTasksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput> | AttachmentCreateWithoutTaskInput[] | AttachmentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTaskInput | AttachmentCreateOrConnectWithoutTaskInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTaskInput | AttachmentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AttachmentCreateManyTaskInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTaskInput | AttachmentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTaskInput | AttachmentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput> | CommentCreateWithoutTaskInput[] | CommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTaskInput | CommentCreateOrConnectWithoutTaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTaskInput | CommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CommentCreateManyTaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTaskInput | CommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTaskInput | CommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput = {
    create?: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput> | SubtaskCreateWithoutParentTaskInput[] | SubtaskUncheckedCreateWithoutParentTaskInput[]
    connectOrCreate?: SubtaskCreateOrConnectWithoutParentTaskInput | SubtaskCreateOrConnectWithoutParentTaskInput[]
    upsert?: SubtaskUpsertWithWhereUniqueWithoutParentTaskInput | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput[]
    createMany?: SubtaskCreateManyParentTaskInputEnvelope
    set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[]
    update?: SubtaskUpdateWithWhereUniqueWithoutParentTaskInput | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput[]
    updateMany?: SubtaskUpdateManyWithWhereWithoutParentTaskInput | SubtaskUpdateManyWithWhereWithoutParentTaskInput[]
    deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput> | TaskDependencyCreateWithoutDependsOnTaskInput[] | TaskDependencyUncheckedCreateWithoutDependsOnTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutDependsOnTaskInput | TaskDependencyCreateOrConnectWithoutDependsOnTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutDependsOnTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnTaskInput[]
    createMany?: TaskDependencyCreateManyDependsOnTaskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutDependsOnTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutDependsOnTaskInput | TaskDependencyUpdateManyWithWhereWithoutDependsOnTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput> | TaskDependencyCreateWithoutTaskInput[] | TaskDependencyUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskDependencyCreateOrConnectWithoutTaskInput | TaskDependencyCreateOrConnectWithoutTaskInput[]
    upsert?: TaskDependencyUpsertWithWhereUniqueWithoutTaskInput | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskDependencyCreateManyTaskInputEnvelope
    set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[]
    update?: TaskDependencyUpdateWithWhereUniqueWithoutTaskInput | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskDependencyUpdateManyWithWhereWithoutTaskInput | TaskDependencyUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput> | TaskLabelCreateWithoutTaskInput[] | TaskLabelUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutTaskInput | TaskLabelCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutTaskInput | TaskLabelUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLabelCreateManyTaskInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutTaskInput | TaskLabelUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutTaskInput | TaskLabelUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput> | TimeLogCreateWithoutTaskInput[] | TimeLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutTaskInput | TimeLogCreateOrConnectWithoutTaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutTaskInput | TimeLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TimeLogCreateManyTaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutTaskInput | TimeLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutTaskInput | TimeLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput> | UserCreateWithoutAssignedTasksInput[] | UserUncheckedCreateWithoutAssignedTasksInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput | UserCreateOrConnectWithoutAssignedTasksInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedTasksInput | UserUpsertWithWhereUniqueWithoutAssignedTasksInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedTasksInput | UserUpdateWithWhereUniqueWithoutAssignedTasksInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedTasksInput | UserUpdateManyWithWhereWithoutAssignedTasksInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CommentCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput> | CommentCreateWithoutSubtaskInput[] | CommentUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSubtaskInput | CommentCreateOrConnectWithoutSubtaskInput[]
    createMany?: CommentCreateManySubtaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput = {
    create?: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput> | SubtaskDependencyCreateWithoutDependsOnSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput | SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput[]
    createMany?: SubtaskDependencyCreateManyDependsOnSubtaskInputEnvelope
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
  }

  export type SubtaskDependencyCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput> | SubtaskDependencyCreateWithoutSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutSubtaskInput | SubtaskDependencyCreateOrConnectWithoutSubtaskInput[]
    createMany?: SubtaskDependencyCreateManySubtaskInputEnvelope
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedSubtasksInput = {
    create?: XOR<UserCreateWithoutCreatedSubtasksInput, UserUncheckedCreateWithoutCreatedSubtasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubtasksInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TeamCreateWithoutSubtasksInput, TeamUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubtasksInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedSubtasksInput = {
    create?: XOR<UserCreateWithoutAssignedSubtasksInput, UserUncheckedCreateWithoutAssignedSubtasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedSubtasksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutSubtasksInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
  }

  export type TimeLogCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput> | TimeLogCreateWithoutSubtaskInput[] | TimeLogUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSubtaskInput | TimeLogCreateOrConnectWithoutSubtaskInput[]
    createMany?: TimeLogCreateManySubtaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput> | CommentCreateWithoutSubtaskInput[] | CommentUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSubtaskInput | CommentCreateOrConnectWithoutSubtaskInput[]
    createMany?: CommentCreateManySubtaskInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput = {
    create?: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput> | SubtaskDependencyCreateWithoutDependsOnSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput | SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput[]
    createMany?: SubtaskDependencyCreateManyDependsOnSubtaskInputEnvelope
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
  }

  export type SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput> | SubtaskDependencyCreateWithoutSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutSubtaskInput | SubtaskDependencyCreateOrConnectWithoutSubtaskInput[]
    createMany?: SubtaskDependencyCreateManySubtaskInputEnvelope
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutSubtaskInput = {
    create?: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput> | TimeLogCreateWithoutSubtaskInput[] | TimeLogUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSubtaskInput | TimeLogCreateOrConnectWithoutSubtaskInput[]
    createMany?: TimeLogCreateManySubtaskInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput> | CommentCreateWithoutSubtaskInput[] | CommentUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSubtaskInput | CommentCreateOrConnectWithoutSubtaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutSubtaskInput | CommentUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: CommentCreateManySubtaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutSubtaskInput | CommentUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutSubtaskInput | CommentUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput = {
    create?: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput> | SubtaskDependencyCreateWithoutDependsOnSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput | SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput[]
    upsert?: SubtaskDependencyUpsertWithWhereUniqueWithoutDependsOnSubtaskInput | SubtaskDependencyUpsertWithWhereUniqueWithoutDependsOnSubtaskInput[]
    createMany?: SubtaskDependencyCreateManyDependsOnSubtaskInputEnvelope
    set?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    disconnect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    delete?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    update?: SubtaskDependencyUpdateWithWhereUniqueWithoutDependsOnSubtaskInput | SubtaskDependencyUpdateWithWhereUniqueWithoutDependsOnSubtaskInput[]
    updateMany?: SubtaskDependencyUpdateManyWithWhereWithoutDependsOnSubtaskInput | SubtaskDependencyUpdateManyWithWhereWithoutDependsOnSubtaskInput[]
    deleteMany?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
  }

  export type SubtaskDependencyUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput> | SubtaskDependencyCreateWithoutSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutSubtaskInput | SubtaskDependencyCreateOrConnectWithoutSubtaskInput[]
    upsert?: SubtaskDependencyUpsertWithWhereUniqueWithoutSubtaskInput | SubtaskDependencyUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: SubtaskDependencyCreateManySubtaskInputEnvelope
    set?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    disconnect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    delete?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    update?: SubtaskDependencyUpdateWithWhereUniqueWithoutSubtaskInput | SubtaskDependencyUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: SubtaskDependencyUpdateManyWithWhereWithoutSubtaskInput | SubtaskDependencyUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSubtasksInput, UserUncheckedCreateWithoutCreatedSubtasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubtasksInput
    upsert?: UserUpsertWithoutCreatedSubtasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSubtasksInput, UserUpdateWithoutCreatedSubtasksInput>, UserUncheckedUpdateWithoutCreatedSubtasksInput>
  }

  export type TeamUpdateOneWithoutSubtasksNestedInput = {
    create?: XOR<TeamCreateWithoutSubtasksInput, TeamUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubtasksInput
    upsert?: TeamUpsertWithoutSubtasksInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSubtasksInput, TeamUpdateWithoutSubtasksInput>, TeamUncheckedUpdateWithoutSubtasksInput>
  }

  export type UserUpdateOneWithoutAssignedSubtasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedSubtasksInput, UserUncheckedCreateWithoutAssignedSubtasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedSubtasksInput
    upsert?: UserUpsertWithoutAssignedSubtasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedSubtasksInput, UserUpdateWithoutAssignedSubtasksInput>, UserUncheckedUpdateWithoutAssignedSubtasksInput>
  }

  export type TaskUpdateOneRequiredWithoutSubtasksNestedInput = {
    create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput
    upsert?: TaskUpsertWithoutSubtasksInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TimeLogUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput> | TimeLogCreateWithoutSubtaskInput[] | TimeLogUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSubtaskInput | TimeLogCreateOrConnectWithoutSubtaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutSubtaskInput | TimeLogUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: TimeLogCreateManySubtaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutSubtaskInput | TimeLogUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutSubtaskInput | TimeLogUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput> | CommentCreateWithoutSubtaskInput[] | CommentUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSubtaskInput | CommentCreateOrConnectWithoutSubtaskInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutSubtaskInput | CommentUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: CommentCreateManySubtaskInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutSubtaskInput | CommentUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutSubtaskInput | CommentUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput = {
    create?: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput> | SubtaskDependencyCreateWithoutDependsOnSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput | SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput[]
    upsert?: SubtaskDependencyUpsertWithWhereUniqueWithoutDependsOnSubtaskInput | SubtaskDependencyUpsertWithWhereUniqueWithoutDependsOnSubtaskInput[]
    createMany?: SubtaskDependencyCreateManyDependsOnSubtaskInputEnvelope
    set?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    disconnect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    delete?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    update?: SubtaskDependencyUpdateWithWhereUniqueWithoutDependsOnSubtaskInput | SubtaskDependencyUpdateWithWhereUniqueWithoutDependsOnSubtaskInput[]
    updateMany?: SubtaskDependencyUpdateManyWithWhereWithoutDependsOnSubtaskInput | SubtaskDependencyUpdateManyWithWhereWithoutDependsOnSubtaskInput[]
    deleteMany?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
  }

  export type SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput> | SubtaskDependencyCreateWithoutSubtaskInput[] | SubtaskDependencyUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: SubtaskDependencyCreateOrConnectWithoutSubtaskInput | SubtaskDependencyCreateOrConnectWithoutSubtaskInput[]
    upsert?: SubtaskDependencyUpsertWithWhereUniqueWithoutSubtaskInput | SubtaskDependencyUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: SubtaskDependencyCreateManySubtaskInputEnvelope
    set?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    disconnect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    delete?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    connect?: SubtaskDependencyWhereUniqueInput | SubtaskDependencyWhereUniqueInput[]
    update?: SubtaskDependencyUpdateWithWhereUniqueWithoutSubtaskInput | SubtaskDependencyUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: SubtaskDependencyUpdateManyWithWhereWithoutSubtaskInput | SubtaskDependencyUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput = {
    create?: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput> | TimeLogCreateWithoutSubtaskInput[] | TimeLogUncheckedCreateWithoutSubtaskInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSubtaskInput | TimeLogCreateOrConnectWithoutSubtaskInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutSubtaskInput | TimeLogUpsertWithWhereUniqueWithoutSubtaskInput[]
    createMany?: TimeLogCreateManySubtaskInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutSubtaskInput | TimeLogUpdateWithWhereUniqueWithoutSubtaskInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutSubtaskInput | TimeLogUpdateManyWithWhereWithoutSubtaskInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type SubtaskCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<SubtaskCreateWithoutDependenciesInput, SubtaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutDependenciesInput
    connect?: SubtaskWhereUniqueInput
  }

  export type SubtaskCreateNestedOneWithoutDependentsInput = {
    create?: XOR<SubtaskCreateWithoutDependentsInput, SubtaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutDependentsInput
    connect?: SubtaskWhereUniqueInput
  }

  export type SubtaskUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<SubtaskCreateWithoutDependenciesInput, SubtaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutDependenciesInput
    upsert?: SubtaskUpsertWithoutDependenciesInput
    connect?: SubtaskWhereUniqueInput
    update?: XOR<XOR<SubtaskUpdateToOneWithWhereWithoutDependenciesInput, SubtaskUpdateWithoutDependenciesInput>, SubtaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type SubtaskUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<SubtaskCreateWithoutDependentsInput, SubtaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutDependentsInput
    upsert?: SubtaskUpsertWithoutDependentsInput
    connect?: SubtaskWhereUniqueInput
    update?: XOR<XOR<SubtaskUpdateToOneWithWhereWithoutDependentsInput, SubtaskUpdateWithoutDependentsInput>, SubtaskUncheckedUpdateWithoutDependentsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type SubtaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SubtaskCreateWithoutCommentsInput, SubtaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutCommentsInput
    connect?: SubtaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type CommentMentionCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput> | CommentMentionCreateWithoutCommentInput[] | CommentMentionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutCommentInput | CommentMentionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentMentionCreateManyCommentInputEnvelope
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
  }

  export type CommentMentionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput> | CommentMentionCreateWithoutCommentInput[] | CommentMentionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutCommentInput | CommentMentionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentMentionCreateManyCommentInputEnvelope
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type SubtaskUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<SubtaskCreateWithoutCommentsInput, SubtaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutCommentsInput
    upsert?: SubtaskUpsertWithoutCommentsInput
    disconnect?: SubtaskWhereInput | boolean
    delete?: SubtaskWhereInput | boolean
    connect?: SubtaskWhereUniqueInput
    update?: XOR<XOR<SubtaskUpdateToOneWithWhereWithoutCommentsInput, SubtaskUpdateWithoutCommentsInput>, SubtaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentMentionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput> | CommentMentionCreateWithoutCommentInput[] | CommentMentionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutCommentInput | CommentMentionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentMentionUpsertWithWhereUniqueWithoutCommentInput | CommentMentionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentMentionCreateManyCommentInputEnvelope
    set?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    disconnect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    delete?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    update?: CommentMentionUpdateWithWhereUniqueWithoutCommentInput | CommentMentionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentMentionUpdateManyWithWhereWithoutCommentInput | CommentMentionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
  }

  export type CommentMentionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput> | CommentMentionCreateWithoutCommentInput[] | CommentMentionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentMentionCreateOrConnectWithoutCommentInput | CommentMentionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentMentionUpsertWithWhereUniqueWithoutCommentInput | CommentMentionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentMentionCreateManyCommentInputEnvelope
    set?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    disconnect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    delete?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    connect?: CommentMentionWhereUniqueInput | CommentMentionWhereUniqueInput[]
    update?: CommentMentionUpdateWithWhereUniqueWithoutCommentInput | CommentMentionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentMentionUpdateManyWithWhereWithoutCommentInput | CommentMentionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutMentionsInput = {
    create?: XOR<CommentCreateWithoutMentionsInput, CommentUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutMentionsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentMentionsInput = {
    create?: XOR<UserCreateWithoutCommentMentionsInput, UserUncheckedCreateWithoutCommentMentionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentMentionsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutMentionsNestedInput = {
    create?: XOR<CommentCreateWithoutMentionsInput, CommentUncheckedCreateWithoutMentionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutMentionsInput
    upsert?: CommentUpsertWithoutMentionsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutMentionsInput, CommentUpdateWithoutMentionsInput>, CommentUncheckedUpdateWithoutMentionsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentMentionsNestedInput = {
    create?: XOR<UserCreateWithoutCommentMentionsInput, UserUncheckedCreateWithoutCommentMentionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentMentionsInput
    upsert?: UserUpsertWithoutCommentMentionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentMentionsInput, UserUpdateWithoutCommentMentionsInput>, UserUncheckedUpdateWithoutCommentMentionsInput>
  }

  export type TaskLabelCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TaskLabelUncheckedCreateNestedManyWithoutLabelInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
  }

  export type TaskLabelUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelNestedInput = {
    create?: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput> | TaskLabelCreateWithoutLabelInput[] | TaskLabelUncheckedCreateWithoutLabelInput[]
    connectOrCreate?: TaskLabelCreateOrConnectWithoutLabelInput | TaskLabelCreateOrConnectWithoutLabelInput[]
    upsert?: TaskLabelUpsertWithWhereUniqueWithoutLabelInput | TaskLabelUpsertWithWhereUniqueWithoutLabelInput[]
    createMany?: TaskLabelCreateManyLabelInputEnvelope
    set?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    disconnect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    delete?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    connect?: TaskLabelWhereUniqueInput | TaskLabelWhereUniqueInput[]
    update?: TaskLabelUpdateWithWhereUniqueWithoutLabelInput | TaskLabelUpdateWithWhereUniqueWithoutLabelInput[]
    updateMany?: TaskLabelUpdateManyWithWhereWithoutLabelInput | TaskLabelUpdateManyWithWhereWithoutLabelInput[]
    deleteMany?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
  }

  export type LabelCreateNestedOneWithoutTasksInput = {
    create?: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTasksInput
    connect?: LabelWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutLabelsInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    connect?: TaskWhereUniqueInput
  }

  export type LabelUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LabelCreateOrConnectWithoutTasksInput
    upsert?: LabelUpsertWithoutTasksInput
    connect?: LabelWhereUniqueInput
    update?: XOR<XOR<LabelUpdateToOneWithWhereWithoutTasksInput, LabelUpdateWithoutTasksInput>, LabelUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneRequiredWithoutLabelsNestedInput = {
    create?: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutLabelsInput
    upsert?: TaskUpsertWithoutLabelsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutLabelsInput, TaskUpdateWithoutLabelsInput>, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type TaskCreateNestedOneWithoutDependentsInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutDependenciesInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput
    upsert?: TaskUpsertWithoutDependentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependentsInput, TaskUpdateWithoutDependentsInput>, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskUpdateOneRequiredWithoutDependenciesNestedInput = {
    create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput
    upsert?: TaskUpsertWithoutDependenciesInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutDependenciesInput, TaskUpdateWithoutDependenciesInput>, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type SubtaskCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<SubtaskCreateWithoutTimeLogsInput, SubtaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutTimeLogsInput
    connect?: SubtaskWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type SubtaskUpdateOneWithoutTimeLogsNestedInput = {
    create?: XOR<SubtaskCreateWithoutTimeLogsInput, SubtaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: SubtaskCreateOrConnectWithoutTimeLogsInput
    upsert?: SubtaskUpsertWithoutTimeLogsInput
    disconnect?: SubtaskWhereInput | boolean
    delete?: SubtaskWhereInput | boolean
    connect?: SubtaskWhereUniqueInput
    update?: XOR<XOR<SubtaskUpdateToOneWithWhereWithoutTimeLogsInput, SubtaskUpdateWithoutTimeLogsInput>, SubtaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TaskUpdateOneWithoutTimeLogsNestedInput = {
    create?: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTimeLogsInput
    upsert?: TaskUpsertWithoutTimeLogsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTimeLogsInput, TaskUpdateWithoutTimeLogsInput>, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    upsert?: UserUpsertWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeLogsInput, UserUpdateWithoutTimeLogsInput>, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TeamCreateNestedOneWithoutRulesInput = {
    create?: XOR<TeamCreateWithoutRulesInput, TeamUncheckedCreateWithoutRulesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRulesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRulesInput = {
    create?: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRulesInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneWithoutRulesNestedInput = {
    create?: XOR<TeamCreateWithoutRulesInput, TeamUncheckedCreateWithoutRulesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRulesInput
    upsert?: TeamUpsertWithoutRulesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRulesInput, TeamUpdateWithoutRulesInput>, TeamUncheckedUpdateWithoutRulesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedRulesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRulesInput
    upsert?: UserUpsertWithoutCreatedRulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRulesInput, UserUpdateWithoutCreatedRulesInput>, UserUncheckedUpdateWithoutCreatedRulesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsPerformedInput = {
    create?: XOR<UserCreateWithoutActivityLogsPerformedInput, UserUncheckedCreateWithoutActivityLogsPerformedInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsPerformedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityLogsAffectedInput = {
    create?: XOR<UserCreateWithoutActivityLogsAffectedInput, UserUncheckedCreateWithoutActivityLogsAffectedInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsAffectedInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<ProjectCreateWithoutActivityLogsInput, ProjectUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivityLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutActivityLogsPerformedNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsPerformedInput, UserUncheckedCreateWithoutActivityLogsPerformedInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsPerformedInput
    upsert?: UserUpsertWithoutActivityLogsPerformedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsPerformedInput, UserUpdateWithoutActivityLogsPerformedInput>, UserUncheckedUpdateWithoutActivityLogsPerformedInput>
  }

  export type UserUpdateOneWithoutActivityLogsAffectedNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsAffectedInput, UserUncheckedCreateWithoutActivityLogsAffectedInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsAffectedInput
    upsert?: UserUpsertWithoutActivityLogsAffectedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsAffectedInput, UserUpdateWithoutActivityLogsAffectedInput>, UserUncheckedUpdateWithoutActivityLogsAffectedInput>
  }

  export type ProjectUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutActivityLogsInput, ProjectUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActivityLogsInput
    upsert?: ProjectUpsertWithoutActivityLogsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutActivityLogsInput, ProjectUpdateWithoutActivityLogsInput>, ProjectUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type ProjectCreateNestedOneWithoutProjectUsersInput = {
    create?: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectUsersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectUsersNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectUsersInput
    upsert?: ProjectUpsertWithoutProjectUsersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectUsersInput, ProjectUpdateWithoutProjectUsersInput>, ProjectUncheckedUpdateWithoutProjectUsersInput>
  }

  export type ProjectCreateNestedOneWithoutPhasesInput = {
    create?: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhasesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPhasesInput
    upsert?: ProjectUpsertWithoutPhasesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPhasesInput, ProjectUpdateWithoutPhasesInput>, ProjectUncheckedUpdateWithoutPhasesInput>
  }

  export type ProjectCreateNestedOneWithoutDeliverablesInput = {
    create?: XOR<ProjectCreateWithoutDeliverablesInput, ProjectUncheckedCreateWithoutDeliverablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDeliverablesInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutDeliverableInput = {
    create?: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput> | TaskCreateWithoutDeliverableInput[] | TaskUncheckedCreateWithoutDeliverableInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDeliverableInput | TaskCreateOrConnectWithoutDeliverableInput[]
    createMany?: TaskCreateManyDeliverableInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutDeliverableInput = {
    create?: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput> | TaskCreateWithoutDeliverableInput[] | TaskUncheckedCreateWithoutDeliverableInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDeliverableInput | TaskCreateOrConnectWithoutDeliverableInput[]
    createMany?: TaskCreateManyDeliverableInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutDeliverablesNestedInput = {
    create?: XOR<ProjectCreateWithoutDeliverablesInput, ProjectUncheckedCreateWithoutDeliverablesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDeliverablesInput
    upsert?: ProjectUpsertWithoutDeliverablesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDeliverablesInput, ProjectUpdateWithoutDeliverablesInput>, ProjectUncheckedUpdateWithoutDeliverablesInput>
  }

  export type TaskUpdateManyWithoutDeliverableNestedInput = {
    create?: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput> | TaskCreateWithoutDeliverableInput[] | TaskUncheckedCreateWithoutDeliverableInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDeliverableInput | TaskCreateOrConnectWithoutDeliverableInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDeliverableInput | TaskUpsertWithWhereUniqueWithoutDeliverableInput[]
    createMany?: TaskCreateManyDeliverableInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDeliverableInput | TaskUpdateWithWhereUniqueWithoutDeliverableInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDeliverableInput | TaskUpdateManyWithWhereWithoutDeliverableInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutDeliverableNestedInput = {
    create?: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput> | TaskCreateWithoutDeliverableInput[] | TaskUncheckedCreateWithoutDeliverableInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutDeliverableInput | TaskCreateOrConnectWithoutDeliverableInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutDeliverableInput | TaskUpsertWithWhereUniqueWithoutDeliverableInput[]
    createMany?: TaskCreateManyDeliverableInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutDeliverableInput | TaskUpdateWithWhereUniqueWithoutDeliverableInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutDeliverableInput | TaskUpdateManyWithWhereWithoutDeliverableInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutScopeHistoryInput = {
    create?: XOR<ProjectCreateWithoutScopeHistoryInput, ProjectUncheckedCreateWithoutScopeHistoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScopeHistoryInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutScopeHistoryNestedInput = {
    create?: XOR<ProjectCreateWithoutScopeHistoryInput, ProjectUncheckedCreateWithoutScopeHistoryInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScopeHistoryInput
    upsert?: ProjectUpsertWithoutScopeHistoryInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutScopeHistoryInput, ProjectUpdateWithoutScopeHistoryInput>, ProjectUncheckedUpdateWithoutScopeHistoryInput>
  }

  export type UserCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUploadedFilesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput
    upsert?: UserUpsertWithoutUploadedFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedFilesInput, UserUpdateWithoutUploadedFilesInput>, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type TaskUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAttachmentsInput
    upsert?: TaskUpsertWithoutAttachmentsInput
    disconnect?: TaskWhereInput | boolean
    delete?: TaskWhereInput | boolean
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAttachmentsInput, TaskUpdateWithoutAttachmentsInput>, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type SettingsChangeLogCreateNestedManyWithoutSettingInput = {
    create?: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput> | SettingsChangeLogCreateWithoutSettingInput[] | SettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutSettingInput | SettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: SettingsChangeLogCreateManySettingInputEnvelope
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutUpdatedSettingsInput = {
    create?: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type SettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput = {
    create?: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput> | SettingsChangeLogCreateWithoutSettingInput[] | SettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutSettingInput | SettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: SettingsChangeLogCreateManySettingInputEnvelope
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
  }

  export type SettingsChangeLogUpdateManyWithoutSettingNestedInput = {
    create?: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput> | SettingsChangeLogCreateWithoutSettingInput[] | SettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutSettingInput | SettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: SettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | SettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: SettingsChangeLogCreateManySettingInputEnvelope
    set?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    disconnect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    delete?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    update?: SettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | SettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: SettingsChangeLogUpdateManyWithWhereWithoutSettingInput | SettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutUpdatedSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSettingsInput
    upsert?: UserUpsertWithoutUpdatedSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedSettingsInput, UserUpdateWithoutUpdatedSettingsInput>, UserUncheckedUpdateWithoutUpdatedSettingsInput>
  }

  export type SettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput = {
    create?: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput> | SettingsChangeLogCreateWithoutSettingInput[] | SettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: SettingsChangeLogCreateOrConnectWithoutSettingInput | SettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: SettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | SettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: SettingsChangeLogCreateManySettingInputEnvelope
    set?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    disconnect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    delete?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    connect?: SettingsChangeLogWhereUniqueInput | SettingsChangeLogWhereUniqueInput[]
    update?: SettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | SettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: SettingsChangeLogUpdateManyWithWhereWithoutSettingInput | SettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
  }

  export type SystemSettingCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<SystemSettingCreateWithoutChangeLogsInput, SystemSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: SystemSettingCreateOrConnectWithoutChangeLogsInput
    connect?: SystemSettingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSettingsChangedInput = {
    create?: XOR<UserCreateWithoutSettingsChangedInput, UserUncheckedCreateWithoutSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsChangedInput
    connect?: UserWhereUniqueInput
  }

  export type SystemSettingUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<SystemSettingCreateWithoutChangeLogsInput, SystemSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: SystemSettingCreateOrConnectWithoutChangeLogsInput
    upsert?: SystemSettingUpsertWithoutChangeLogsInput
    connect?: SystemSettingWhereUniqueInput
    update?: XOR<XOR<SystemSettingUpdateToOneWithWhereWithoutChangeLogsInput, SystemSettingUpdateWithoutChangeLogsInput>, SystemSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutSettingsChangedNestedInput = {
    create?: XOR<UserCreateWithoutSettingsChangedInput, UserUncheckedCreateWithoutSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsChangedInput
    upsert?: UserUpsertWithoutSettingsChangedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsChangedInput, UserUpdateWithoutSettingsChangedInput>, UserUncheckedUpdateWithoutSettingsChangedInput>
  }

  export type UserCreateNestedOneWithoutProjectSettingsUpdatedInput = {
    create?: XOR<UserCreateWithoutProjectSettingsUpdatedInput, UserUncheckedCreateWithoutProjectSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingsUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSettingsInput = {
    create?: XOR<ProjectCreateWithoutSettingsInput, ProjectUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSettingsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectSettingsChangeLogCreateNestedManyWithoutSettingInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput> | ProjectSettingsChangeLogCreateWithoutSettingInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput | ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: ProjectSettingsChangeLogCreateManySettingInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput> | ProjectSettingsChangeLogCreateWithoutSettingInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput | ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: ProjectSettingsChangeLogCreateManySettingInputEnvelope
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProjectSettingsUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutProjectSettingsUpdatedInput, UserUncheckedCreateWithoutProjectSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingsUpdatedInput
    upsert?: UserUpsertWithoutProjectSettingsUpdatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectSettingsUpdatedInput, UserUpdateWithoutProjectSettingsUpdatedInput>, UserUncheckedUpdateWithoutProjectSettingsUpdatedInput>
  }

  export type ProjectUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<ProjectCreateWithoutSettingsInput, ProjectUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSettingsInput
    upsert?: ProjectUpsertWithoutSettingsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSettingsInput, ProjectUpdateWithoutSettingsInput>, ProjectUncheckedUpdateWithoutSettingsInput>
  }

  export type ProjectSettingsChangeLogUpdateManyWithoutSettingNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput> | ProjectSettingsChangeLogCreateWithoutSettingInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput | ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: ProjectSettingsChangeLogCreateManySettingInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutSettingInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput = {
    create?: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput> | ProjectSettingsChangeLogCreateWithoutSettingInput[] | ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput | ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: ProjectSettingsChangeLogCreateManySettingInputEnvelope
    set?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    disconnect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    delete?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    connect?: ProjectSettingsChangeLogWhereUniqueInput | ProjectSettingsChangeLogWhereUniqueInput[]
    update?: ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: ProjectSettingsChangeLogUpdateManyWithWhereWithoutSettingInput | ProjectSettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
  }

  export type ProjectSettingCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<ProjectSettingCreateWithoutChangeLogsInput, ProjectSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutChangeLogsInput
    connect?: ProjectSettingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectSettingsChangedInput = {
    create?: XOR<UserCreateWithoutProjectSettingsChangedInput, UserUncheckedCreateWithoutProjectSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingsChangedInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSettingsLogsInput = {
    create?: XOR<ProjectCreateWithoutSettingsLogsInput, ProjectUncheckedCreateWithoutSettingsLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSettingsLogsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectSettingUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<ProjectSettingCreateWithoutChangeLogsInput, ProjectSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ProjectSettingCreateOrConnectWithoutChangeLogsInput
    upsert?: ProjectSettingUpsertWithoutChangeLogsInput
    connect?: ProjectSettingWhereUniqueInput
    update?: XOR<XOR<ProjectSettingUpdateToOneWithWhereWithoutChangeLogsInput, ProjectSettingUpdateWithoutChangeLogsInput>, ProjectSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutProjectSettingsChangedNestedInput = {
    create?: XOR<UserCreateWithoutProjectSettingsChangedInput, UserUncheckedCreateWithoutProjectSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectSettingsChangedInput
    upsert?: UserUpsertWithoutProjectSettingsChangedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectSettingsChangedInput, UserUpdateWithoutProjectSettingsChangedInput>, UserUncheckedUpdateWithoutProjectSettingsChangedInput>
  }

  export type ProjectUpdateOneRequiredWithoutSettingsLogsNestedInput = {
    create?: XOR<ProjectCreateWithoutSettingsLogsInput, ProjectUncheckedCreateWithoutSettingsLogsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSettingsLogsInput
    upsert?: ProjectUpsertWithoutSettingsLogsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSettingsLogsInput, ProjectUpdateWithoutSettingsLogsInput>, ProjectUncheckedUpdateWithoutSettingsLogsInput>
  }

  export type UserCreateNestedOneWithoutUserSettingsUpdatedInput = {
    create?: XOR<UserCreateWithoutUserSettingsUpdatedInput, UserUncheckedCreateWithoutUserSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserSettingsChangeLogCreateNestedManyWithoutSettingInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput> | UserSettingsChangeLogCreateWithoutSettingInput[] | UserSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutSettingInput | UserSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: UserSettingsChangeLogCreateManySettingInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type UserSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput> | UserSettingsChangeLogCreateWithoutSettingInput[] | UserSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutSettingInput | UserSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    createMany?: UserSettingsChangeLogCreateManySettingInputEnvelope
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserSettingsUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsUpdatedInput, UserUncheckedCreateWithoutUserSettingsUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsUpdatedInput
    upsert?: UserUpsertWithoutUserSettingsUpdatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsUpdatedInput, UserUpdateWithoutUserSettingsUpdatedInput>, UserUncheckedUpdateWithoutUserSettingsUpdatedInput>
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserSettingsChangeLogUpdateManyWithoutSettingNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput> | UserSettingsChangeLogCreateWithoutSettingInput[] | UserSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutSettingInput | UserSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: UserSettingsChangeLogCreateManySettingInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutSettingInput | UserSettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput = {
    create?: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput> | UserSettingsChangeLogCreateWithoutSettingInput[] | UserSettingsChangeLogUncheckedCreateWithoutSettingInput[]
    connectOrCreate?: UserSettingsChangeLogCreateOrConnectWithoutSettingInput | UserSettingsChangeLogCreateOrConnectWithoutSettingInput[]
    upsert?: UserSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput | UserSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput[]
    createMany?: UserSettingsChangeLogCreateManySettingInputEnvelope
    set?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    disconnect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    delete?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    connect?: UserSettingsChangeLogWhereUniqueInput | UserSettingsChangeLogWhereUniqueInput[]
    update?: UserSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput | UserSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput[]
    updateMany?: UserSettingsChangeLogUpdateManyWithWhereWithoutSettingInput | UserSettingsChangeLogUpdateManyWithWhereWithoutSettingInput[]
    deleteMany?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
  }

  export type UserSettingCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<UserSettingCreateWithoutChangeLogsInput, UserSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutChangeLogsInput
    connect?: UserSettingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSettingsChangedInput = {
    create?: XOR<UserCreateWithoutUserSettingsChangedInput, UserUncheckedCreateWithoutUserSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsChangedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSettingsChangeLogsInput = {
    create?: XOR<UserCreateWithoutUserSettingsChangeLogsInput, UserUncheckedCreateWithoutUserSettingsChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsChangeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserSettingUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<UserSettingCreateWithoutChangeLogsInput, UserSettingUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutChangeLogsInput
    upsert?: UserSettingUpsertWithoutChangeLogsInput
    connect?: UserSettingWhereUniqueInput
    update?: XOR<XOR<UserSettingUpdateToOneWithWhereWithoutChangeLogsInput, UserSettingUpdateWithoutChangeLogsInput>, UserSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutUserSettingsChangedNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsChangedInput, UserUncheckedCreateWithoutUserSettingsChangedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsChangedInput
    upsert?: UserUpsertWithoutUserSettingsChangedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsChangedInput, UserUpdateWithoutUserSettingsChangedInput>, UserUncheckedUpdateWithoutUserSettingsChangedInput>
  }

  export type UserUpdateOneRequiredWithoutUserSettingsChangeLogsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsChangeLogsInput, UserUncheckedCreateWithoutUserSettingsChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsChangeLogsInput
    upsert?: UserUpsertWithoutUserSettingsChangeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsChangeLogsInput, UserUpdateWithoutUserSettingsChangeLogsInput>, UserUncheckedUpdateWithoutUserSettingsChangeLogsInput>
  }

  export type UserCreateNestedOneWithoutProjectNotificationsInput = {
    create?: XOR<UserCreateWithoutProjectNotificationsInput, UserUncheckedCreateWithoutProjectNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProjectCreateWithoutNotificationsInput, ProjectUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutProjectNotificationsInput, UserUncheckedCreateWithoutProjectNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectNotificationsInput
    upsert?: UserUpsertWithoutProjectNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectNotificationsInput, UserUpdateWithoutProjectNotificationsInput>, UserUncheckedUpdateWithoutProjectNotificationsInput>
  }

  export type ProjectUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<ProjectCreateWithoutNotificationsInput, ProjectUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationsInput
    upsert?: ProjectUpsertWithoutNotificationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutNotificationsInput, ProjectUpdateWithoutNotificationsInput>, ProjectUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProjectCreateNestedOneWithoutUrgentAcknowledgmentsInput = {
    create?: XOR<ProjectCreateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedCreateWithoutUrgentAcknowledgmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentAcknowledgmentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUrgentAcknowledgementsInput = {
    create?: XOR<UserCreateWithoutUrgentAcknowledgementsInput, UserUncheckedCreateWithoutUrgentAcknowledgementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUrgentAcknowledgementsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutUrgentAcknowledgmentsNestedInput = {
    create?: XOR<ProjectCreateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedCreateWithoutUrgentAcknowledgmentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUrgentAcknowledgmentsInput
    upsert?: ProjectUpsertWithoutUrgentAcknowledgmentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUrgentAcknowledgmentsInput, ProjectUpdateWithoutUrgentAcknowledgmentsInput>, ProjectUncheckedUpdateWithoutUrgentAcknowledgmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUrgentAcknowledgementsNestedInput = {
    create?: XOR<UserCreateWithoutUrgentAcknowledgementsInput, UserUncheckedCreateWithoutUrgentAcknowledgementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUrgentAcknowledgementsInput
    upsert?: UserUpsertWithoutUrgentAcknowledgementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUrgentAcknowledgementsInput, UserUpdateWithoutUrgentAcknowledgementsInput>, UserUncheckedUpdateWithoutUrgentAcknowledgementsInput>
  }

  export type UserCreateNestedOneWithoutProjectNotificationPreferencesInput = {
    create?: XOR<UserCreateWithoutProjectNotificationPreferencesInput, UserUncheckedCreateWithoutProjectNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectNotificationPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutNotificationPreferencesInput = {
    create?: XOR<ProjectCreateWithoutNotificationPreferencesInput, ProjectUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationPreferencesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProjectNotificationPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutProjectNotificationPreferencesInput, UserUncheckedCreateWithoutProjectNotificationPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectNotificationPreferencesInput
    upsert?: UserUpsertWithoutProjectNotificationPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectNotificationPreferencesInput, UserUpdateWithoutProjectNotificationPreferencesInput>, UserUncheckedUpdateWithoutProjectNotificationPreferencesInput>
  }

  export type ProjectUpdateOneRequiredWithoutNotificationPreferencesNestedInput = {
    create?: XOR<ProjectCreateWithoutNotificationPreferencesInput, ProjectUncheckedCreateWithoutNotificationPreferencesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNotificationPreferencesInput
    upsert?: ProjectUpsertWithoutNotificationPreferencesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutNotificationPreferencesInput, ProjectUpdateWithoutNotificationPreferencesInput>, ProjectUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type ProjectCreateNestedOneWithoutProjectTeamsInput = {
    create?: XOR<ProjectCreateWithoutProjectTeamsInput, ProjectUncheckedCreateWithoutProjectTeamsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTeamsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutProjectTeamsInput = {
    create?: XOR<TeamCreateWithoutProjectTeamsInput, TeamUncheckedCreateWithoutProjectTeamsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutProjectTeamsInput
    connect?: TeamWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectTeamsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTeamsInput, ProjectUncheckedCreateWithoutProjectTeamsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTeamsInput
    upsert?: ProjectUpsertWithoutProjectTeamsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectTeamsInput, ProjectUpdateWithoutProjectTeamsInput>, ProjectUncheckedUpdateWithoutProjectTeamsInput>
  }

  export type TeamUpdateOneRequiredWithoutProjectTeamsNestedInput = {
    create?: XOR<TeamCreateWithoutProjectTeamsInput, TeamUncheckedCreateWithoutProjectTeamsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutProjectTeamsInput
    upsert?: TeamUpsertWithoutProjectTeamsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutProjectTeamsInput, TeamUpdateWithoutProjectTeamsInput>, TeamUncheckedUpdateWithoutProjectTeamsInput>
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedRolesInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateOneWithoutAssignedRolesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    upsert?: UserUpsertWithoutAssignedRolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedRolesInput, UserUpdateWithoutAssignedRolesInput>, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type ProjectCreateNestedManyWithoutProjectTypeInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectTypeInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutProjectTypeNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectTypeInput | ProjectUpsertWithWhereUniqueWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectTypeInput | ProjectUpdateWithWhereUniqueWithoutProjectTypeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectTypeInput | ProjectUpdateManyWithWhereWithoutProjectTypeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectTypeNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput> | ProjectCreateWithoutProjectTypeInput[] | ProjectUncheckedCreateWithoutProjectTypeInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTypeInput | ProjectCreateOrConnectWithoutProjectTypeInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectTypeInput | ProjectUpsertWithWhereUniqueWithoutProjectTypeInput[]
    createMany?: ProjectCreateManyProjectTypeInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectTypeInput | ProjectUpdateWithWhereUniqueWithoutProjectTypeInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectTypeInput | ProjectUpdateManyWithWhereWithoutProjectTypeInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutProjectStatusInput = {
    create?: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput> | ProjectCreateWithoutProjectStatusInput[] | ProjectUncheckedCreateWithoutProjectStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectStatusInput | ProjectCreateOrConnectWithoutProjectStatusInput[]
    createMany?: ProjectCreateManyProjectStatusInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectStatusInput = {
    create?: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput> | ProjectCreateWithoutProjectStatusInput[] | ProjectUncheckedCreateWithoutProjectStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectStatusInput | ProjectCreateOrConnectWithoutProjectStatusInput[]
    createMany?: ProjectCreateManyProjectStatusInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUpdateManyWithoutProjectStatusNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput> | ProjectCreateWithoutProjectStatusInput[] | ProjectUncheckedCreateWithoutProjectStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectStatusInput | ProjectCreateOrConnectWithoutProjectStatusInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectStatusInput | ProjectUpsertWithWhereUniqueWithoutProjectStatusInput[]
    createMany?: ProjectCreateManyProjectStatusInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectStatusInput | ProjectUpdateWithWhereUniqueWithoutProjectStatusInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectStatusInput | ProjectUpdateManyWithWhereWithoutProjectStatusInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectStatusNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput> | ProjectCreateWithoutProjectStatusInput[] | ProjectUncheckedCreateWithoutProjectStatusInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectStatusInput | ProjectCreateOrConnectWithoutProjectStatusInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectStatusInput | ProjectUpsertWithWhereUniqueWithoutProjectStatusInput[]
    createMany?: ProjectCreateManyProjectStatusInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectStatusInput | ProjectUpdateWithWhereUniqueWithoutProjectStatusInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectStatusInput | ProjectUpdateManyWithWhereWithoutProjectStatusInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutTaskStatusInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTaskStatusInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutTaskStatusNestedInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTaskStatusInput | TaskUpsertWithWhereUniqueWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTaskStatusInput | TaskUpdateWithWhereUniqueWithoutTaskStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTaskStatusInput | TaskUpdateManyWithWhereWithoutTaskStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTaskStatusNestedInput = {
    create?: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput> | TaskCreateWithoutTaskStatusInput[] | TaskUncheckedCreateWithoutTaskStatusInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTaskStatusInput | TaskCreateOrConnectWithoutTaskStatusInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTaskStatusInput | TaskUpsertWithWhereUniqueWithoutTaskStatusInput[]
    createMany?: TaskCreateManyTaskStatusInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTaskStatusInput | TaskUpdateWithWhereUniqueWithoutTaskStatusInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTaskStatusInput | TaskUpdateManyWithWhereWithoutTaskStatusInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ActivityLogCreateWithoutPerformedByInput = {
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    affectedUser?: UserCreateNestedOneWithoutActivityLogsAffectedInput
    project?: ProjectCreateNestedOneWithoutActivityLogsInput
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutPerformedByInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogCreateOrConnectWithoutPerformedByInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput>
  }

  export type ActivityLogCreateManyPerformedByInputEnvelope = {
    data: ActivityLogCreateManyPerformedByInput | ActivityLogCreateManyPerformedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutAffectedUserInput = {
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    performedBy?: UserCreateNestedOneWithoutActivityLogsPerformedInput
    project?: ProjectCreateNestedOneWithoutActivityLogsInput
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutAffectedUserInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogCreateOrConnectWithoutAffectedUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput>
  }

  export type ActivityLogCreateManyAffectedUserInputEnvelope = {
    data: ActivityLogCreateManyAffectedUserInput | ActivityLogCreateManyAffectedUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    performedBy?: UserCreateNestedOneWithoutActivityLogsPerformedInput
    affectedUser?: UserCreateNestedOneWithoutActivityLogsAffectedInput
    project?: ProjectCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutUploaderInput = {
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    task?: TaskCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutUploaderInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    taskId?: number | null
  }

  export type AttachmentCreateOrConnectWithoutUploaderInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type AttachmentCreateManyUploaderInputEnvelope = {
    data: AttachmentCreateManyUploaderInput | AttachmentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type AutomationRuleCreateWithoutCreatorInput = {
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    team?: TeamCreateNestedOneWithoutRulesInput
  }

  export type AutomationRuleUncheckedCreateWithoutCreatorInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
  }

  export type AutomationRuleCreateOrConnectWithoutCreatorInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput>
  }

  export type AutomationRuleCreateManyCreatorInputEnvelope = {
    data: AutomationRuleCreateManyCreatorInput | AutomationRuleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    content: string
    createdAt?: Date | string
    subtask?: SubtaskCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
    mentions?: CommentMentionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
    mentions?: CommentMentionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentMentionCreateWithoutUserInput = {
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutMentionsInput
  }

  export type CommentMentionUncheckedCreateWithoutUserInput = {
    id?: number
    commentId: number
    createdAt?: Date | string
  }

  export type CommentMentionCreateOrConnectWithoutUserInput = {
    where: CommentMentionWhereUniqueInput
    create: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput>
  }

  export type CommentMentionCreateManyUserInputEnvelope = {
    data: CommentMentionCreateManyUserInput | CommentMentionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectNotificationPreferenceCreateWithoutUserInput = {
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutNotificationPreferencesInput
  }

  export type ProjectNotificationPreferenceUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    create: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type ProjectNotificationPreferenceCreateManyUserInputEnvelope = {
    data: ProjectNotificationPreferenceCreateManyUserInput | ProjectNotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectNotificationCreateWithoutUserInput = {
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutNotificationsInput
  }

  export type ProjectNotificationUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectNotificationCreateOrConnectWithoutUserInput = {
    where: ProjectNotificationWhereUniqueInput
    create: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput>
  }

  export type ProjectNotificationCreateManyUserInputEnvelope = {
    data: ProjectNotificationCreateManyUserInput | ProjectNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingCreateWithoutUpdaterInput = {
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSettingsInput
    changeLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingUncheckedCreateWithoutUpdaterInput = {
    id?: number
    projectId: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    changeLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingCreateOrConnectWithoutUpdaterInput = {
    where: ProjectSettingWhereUniqueInput
    create: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type ProjectSettingCreateManyUpdaterInputEnvelope = {
    data: ProjectSettingCreateManyUpdaterInput | ProjectSettingCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingsChangeLogCreateWithoutChangerInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: ProjectSettingCreateNestedOneWithoutChangeLogsInput
    project: ProjectCreateNestedOneWithoutSettingsLogsInput
  }

  export type ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogCreateOrConnectWithoutChangerInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    create: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput>
  }

  export type ProjectSettingsChangeLogCreateManyChangerInputEnvelope = {
    data: ProjectSettingsChangeLogCreateManyChangerInput | ProjectSettingsChangeLogCreateManyChangerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutProjectManagerInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectManagerInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectCreateManyProjectManagerInputEnvelope = {
    data: ProjectCreateManyProjectManagerInput | ProjectCreateManyProjectManagerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutUrgentMarkedByInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUrgentMarkedByInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUrgentMarkedByInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput>
  }

  export type ProjectCreateManyUrgentMarkedByInputEnvelope = {
    data: ProjectCreateManyUrgentMarkedByInput | ProjectCreateManyUrgentMarkedByInput[]
    skipDuplicates?: boolean
  }

  export type SettingsChangeLogCreateWithoutUserInput = {
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: SystemSettingCreateNestedOneWithoutChangeLogsInput
  }

  export type SettingsChangeLogUncheckedCreateWithoutUserInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type SettingsChangeLogCreateOrConnectWithoutUserInput = {
    where: SettingsChangeLogWhereUniqueInput
    create: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput>
  }

  export type SettingsChangeLogCreateManyUserInputEnvelope = {
    data: SettingsChangeLogCreateManyUserInput | SettingsChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutCreatorInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput>
  }

  export type SubtaskCreateManyCreatorInputEnvelope = {
    data: SubtaskCreateManyCreatorInput | SubtaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutAssignedToInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutAssignedToInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput>
  }

  export type SubtaskCreateManyAssignedToInputEnvelope = {
    data: SubtaskCreateManyAssignedToInput | SubtaskCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type SystemSettingCreateWithoutUpdaterInput = {
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    changeLogs?: SettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type SystemSettingUncheckedCreateWithoutUpdaterInput = {
    id?: number
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    changeLogs?: SettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type SystemSettingCreateOrConnectWithoutUpdaterInput = {
    where: SystemSettingWhereUniqueInput
    create: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type SystemSettingCreateManyUpdaterInputEnvelope = {
    data: SystemSettingCreateManyUpdaterInput | SystemSettingCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: TaskCreateManyCreatorInput | TaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type TimeLogCreateWithoutUserInput = {
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    subtask?: SubtaskCreateNestedOneWithoutTimeLogsInput
    task?: TaskCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutUserInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
  }

  export type TimeLogCreateOrConnectWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogCreateManyUserInputEnvelope = {
    data: TimeLogCreateManyUserInput | TimeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingCreateWithoutUpdaterInput = {
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSettingsInput
    changeLogs?: UserSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type UserSettingUncheckedCreateWithoutUpdaterInput = {
    id?: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    changeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type UserSettingCreateOrConnectWithoutUpdaterInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type UserSettingCreateManyUpdaterInputEnvelope = {
    data: UserSettingCreateManyUpdaterInput | UserSettingCreateManyUpdaterInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingCreateWithoutUserInput = {
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutUserSettingsUpdatedInput
    changeLogs?: UserSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type UserSettingUncheckedCreateWithoutUserInput = {
    id?: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updatedBy: number
    changeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type UserSettingCreateOrConnectWithoutUserInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
  }

  export type UserSettingCreateManyUserInputEnvelope = {
    data: UserSettingCreateManyUserInput | UserSettingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsChangeLogCreateWithoutChangerInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: UserSettingCreateNestedOneWithoutChangeLogsInput
    user: UserCreateNestedOneWithoutUserSettingsChangeLogsInput
  }

  export type UserSettingsChangeLogUncheckedCreateWithoutChangerInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogCreateOrConnectWithoutChangerInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    create: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput>
  }

  export type UserSettingsChangeLogCreateManyChangerInputEnvelope = {
    data: UserSettingsChangeLogCreateManyChangerInput | UserSettingsChangeLogCreateManyChangerInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsChangeLogCreateWithoutUserInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: UserSettingCreateNestedOneWithoutChangeLogsInput
    changer: UserCreateNestedOneWithoutUserSettingsChangedInput
  }

  export type UserSettingsChangeLogUncheckedCreateWithoutUserInput = {
    id?: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogCreateOrConnectWithoutUserInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    create: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput>
  }

  export type UserSettingsChangeLogCreateManyUserInputEnvelope = {
    data: UserSettingsChangeLogCreateManyUserInput | UserSettingsChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutUsersInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutUsersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type TaskCreateWithoutAssigneesInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneesInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
  }

  export type TeamCreateWithoutTeamLeadInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamLeadInput = {
    id?: number
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamLeadInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput>
  }

  export type TeamCreateManyTeamLeadInputEnvelope = {
    data: TeamCreateManyTeamLeadInput | TeamCreateManyTeamLeadInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    role?: string
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: number
    teamId: number
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
    assigner?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutAssignerInput = {
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutAssignerInput = {
    id?: number
    userId: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutAssignerInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput>
  }

  export type UserRoleCreateManyAssignerInputEnvelope = {
    data: UserRoleCreateManyAssignerInput | UserRoleCreateManyAssignerInput[]
    skipDuplicates?: boolean
  }

  export type UrgentProjectAcknowledgementCreateWithoutUserInput = {
    acknowledgedAt?: Date | string
    project: ProjectCreateNestedOneWithoutUrgentAcknowledgmentsInput
  }

  export type UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput = {
    id?: number
    projectId: number
    acknowledgedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementCreateOrConnectWithoutUserInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    create: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput>
  }

  export type UrgentProjectAcknowledgementCreateManyUserInputEnvelope = {
    data: UrgentProjectAcknowledgementCreateManyUserInput | UrgentProjectAcknowledgementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutPerformedByInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutPerformedByInput, ActivityLogUncheckedUpdateWithoutPerformedByInput>
    create: XOR<ActivityLogCreateWithoutPerformedByInput, ActivityLogUncheckedCreateWithoutPerformedByInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutPerformedByInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutPerformedByInput, ActivityLogUncheckedUpdateWithoutPerformedByInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutPerformedByInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutPerformedByInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    actionType?: StringNullableFilter<"ActivityLog"> | string | null
    actionCategory?: StringNullableFilter<"ActivityLog"> | string | null
    actionSummary?: StringNullableFilter<"ActivityLog"> | string | null
    actionDetails?: StringNullableFilter<"ActivityLog"> | string | null
    performedById?: IntNullableFilter<"ActivityLog"> | number | null
    affectedUserId?: IntNullableFilter<"ActivityLog"> | number | null
    projectId?: IntNullableFilter<"ActivityLog"> | number | null
    entityType?: StringNullableFilter<"ActivityLog"> | string | null
    entityId?: IntNullableFilter<"ActivityLog"> | number | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    action?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringNullableFilter<"ActivityLog"> | string | null
    userId?: IntNullableFilter<"ActivityLog"> | number | null
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAffectedUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAffectedUserInput, ActivityLogUncheckedUpdateWithoutAffectedUserInput>
    create: XOR<ActivityLogCreateWithoutAffectedUserInput, ActivityLogUncheckedCreateWithoutAffectedUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAffectedUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAffectedUserInput, ActivityLogUncheckedUpdateWithoutAffectedUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAffectedUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAffectedUserInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutUploaderInput, AttachmentUncheckedUpdateWithoutUploaderInput>
    create: XOR<AttachmentCreateWithoutUploaderInput, AttachmentUncheckedCreateWithoutUploaderInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutUploaderInput, AttachmentUncheckedUpdateWithoutUploaderInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutUploaderInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: IntFilter<"Attachment"> | number
    fileName?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    fileType?: StringNullableFilter<"Attachment"> | string | null
    fileSize?: IntNullableFilter<"Attachment"> | number | null
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
    taskId?: IntNullableFilter<"Attachment"> | number | null
    uploadedById?: IntFilter<"Attachment"> | number
  }

  export type AutomationRuleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AutomationRuleWhereUniqueInput
    update: XOR<AutomationRuleUpdateWithoutCreatorInput, AutomationRuleUncheckedUpdateWithoutCreatorInput>
    create: XOR<AutomationRuleCreateWithoutCreatorInput, AutomationRuleUncheckedCreateWithoutCreatorInput>
  }

  export type AutomationRuleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AutomationRuleWhereUniqueInput
    data: XOR<AutomationRuleUpdateWithoutCreatorInput, AutomationRuleUncheckedUpdateWithoutCreatorInput>
  }

  export type AutomationRuleUpdateManyWithWhereWithoutCreatorInput = {
    where: AutomationRuleScalarWhereInput
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AutomationRuleScalarWhereInput = {
    AND?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    OR?: AutomationRuleScalarWhereInput[]
    NOT?: AutomationRuleScalarWhereInput | AutomationRuleScalarWhereInput[]
    id?: IntFilter<"AutomationRule"> | number
    name?: StringFilter<"AutomationRule"> | string
    description?: StringNullableFilter<"AutomationRule"> | string | null
    triggerType?: StringFilter<"AutomationRule"> | string
    triggerCondition?: StringNullableFilter<"AutomationRule"> | string | null
    actionType?: StringFilter<"AutomationRule"> | string
    actionConfig?: StringNullableFilter<"AutomationRule"> | string | null
    isActive?: BoolFilter<"AutomationRule"> | boolean
    createdAt?: DateTimeFilter<"AutomationRule"> | Date | string
    createdById?: IntFilter<"AutomationRule"> | number
    teamId?: IntNullableFilter<"AutomationRule"> | number | null
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    taskId?: IntNullableFilter<"Comment"> | number | null
    subtaskId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntFilter<"Comment"> | number
  }

  export type CommentMentionUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentMentionWhereUniqueInput
    update: XOR<CommentMentionUpdateWithoutUserInput, CommentMentionUncheckedUpdateWithoutUserInput>
    create: XOR<CommentMentionCreateWithoutUserInput, CommentMentionUncheckedCreateWithoutUserInput>
  }

  export type CommentMentionUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentMentionWhereUniqueInput
    data: XOR<CommentMentionUpdateWithoutUserInput, CommentMentionUncheckedUpdateWithoutUserInput>
  }

  export type CommentMentionUpdateManyWithWhereWithoutUserInput = {
    where: CommentMentionScalarWhereInput
    data: XOR<CommentMentionUpdateManyMutationInput, CommentMentionUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentMentionScalarWhereInput = {
    AND?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
    OR?: CommentMentionScalarWhereInput[]
    NOT?: CommentMentionScalarWhereInput | CommentMentionScalarWhereInput[]
    id?: IntFilter<"CommentMention"> | number
    commentId?: IntFilter<"CommentMention"> | number
    userId?: IntFilter<"CommentMention"> | number
    createdAt?: DateTimeFilter<"CommentMention"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: IntFilter<"Notification"> | number
  }

  export type ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    update: XOR<ProjectNotificationPreferenceUpdateWithoutUserInput, ProjectNotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectNotificationPreferenceCreateWithoutUserInput, ProjectNotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    data: XOR<ProjectNotificationPreferenceUpdateWithoutUserInput, ProjectNotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ProjectNotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: ProjectNotificationPreferenceScalarWhereInput
    data: XOR<ProjectNotificationPreferenceUpdateManyMutationInput, ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectNotificationPreferenceScalarWhereInput = {
    AND?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
    OR?: ProjectNotificationPreferenceScalarWhereInput[]
    NOT?: ProjectNotificationPreferenceScalarWhereInput | ProjectNotificationPreferenceScalarWhereInput[]
    id?: IntFilter<"ProjectNotificationPreference"> | number
    projectId?: IntFilter<"ProjectNotificationPreference"> | number
    userId?: IntFilter<"ProjectNotificationPreference"> | number
    soundEnabled?: BoolFilter<"ProjectNotificationPreference"> | boolean
    taskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    dependencyNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    todayTaskNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    projectAdminNotifications?: BoolFilter<"ProjectNotificationPreference"> | boolean
    updatedAt?: DateTimeFilter<"ProjectNotificationPreference"> | Date | string
  }

  export type ProjectNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectNotificationWhereUniqueInput
    update: XOR<ProjectNotificationUpdateWithoutUserInput, ProjectNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectNotificationCreateWithoutUserInput, ProjectNotificationUncheckedCreateWithoutUserInput>
  }

  export type ProjectNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectNotificationWhereUniqueInput
    data: XOR<ProjectNotificationUpdateWithoutUserInput, ProjectNotificationUncheckedUpdateWithoutUserInput>
  }

  export type ProjectNotificationUpdateManyWithWhereWithoutUserInput = {
    where: ProjectNotificationScalarWhereInput
    data: XOR<ProjectNotificationUpdateManyMutationInput, ProjectNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectNotificationScalarWhereInput = {
    AND?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
    OR?: ProjectNotificationScalarWhereInput[]
    NOT?: ProjectNotificationScalarWhereInput | ProjectNotificationScalarWhereInput[]
    id?: IntFilter<"ProjectNotification"> | number
    projectId?: IntFilter<"ProjectNotification"> | number
    userId?: IntFilter<"ProjectNotification"> | number
    type?: StringFilter<"ProjectNotification"> | string
    entityType?: StringFilter<"ProjectNotification"> | string
    entityId?: IntNullableFilter<"ProjectNotification"> | number | null
    title?: StringFilter<"ProjectNotification"> | string
    message?: StringFilter<"ProjectNotification"> | string
    isRead?: BoolFilter<"ProjectNotification"> | boolean
    soundRequired?: BoolFilter<"ProjectNotification"> | boolean
    isUrgent?: BoolFilter<"ProjectNotification"> | boolean
    requiresAcknowledgment?: BoolFilter<"ProjectNotification"> | boolean
    acknowledgedAt?: DateTimeNullableFilter<"ProjectNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectNotification"> | Date | string
  }

  export type ProjectSettingUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: ProjectSettingWhereUniqueInput
    update: XOR<ProjectSettingUpdateWithoutUpdaterInput, ProjectSettingUncheckedUpdateWithoutUpdaterInput>
    create: XOR<ProjectSettingCreateWithoutUpdaterInput, ProjectSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type ProjectSettingUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: ProjectSettingWhereUniqueInput
    data: XOR<ProjectSettingUpdateWithoutUpdaterInput, ProjectSettingUncheckedUpdateWithoutUpdaterInput>
  }

  export type ProjectSettingUpdateManyWithWhereWithoutUpdaterInput = {
    where: ProjectSettingScalarWhereInput
    data: XOR<ProjectSettingUpdateManyMutationInput, ProjectSettingUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type ProjectSettingScalarWhereInput = {
    AND?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
    OR?: ProjectSettingScalarWhereInput[]
    NOT?: ProjectSettingScalarWhereInput | ProjectSettingScalarWhereInput[]
    id?: IntFilter<"ProjectSetting"> | number
    projectId?: IntFilter<"ProjectSetting"> | number
    key?: StringFilter<"ProjectSetting"> | string
    value?: StringFilter<"ProjectSetting"> | string
    category?: StringFilter<"ProjectSetting"> | string
    enabled?: BoolFilter<"ProjectSetting"> | boolean
    updatedAt?: DateTimeFilter<"ProjectSetting"> | Date | string
    updatedBy?: IntFilter<"ProjectSetting"> | number
  }

  export type ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    update: XOR<ProjectSettingsChangeLogUpdateWithoutChangerInput, ProjectSettingsChangeLogUncheckedUpdateWithoutChangerInput>
    create: XOR<ProjectSettingsChangeLogCreateWithoutChangerInput, ProjectSettingsChangeLogUncheckedCreateWithoutChangerInput>
  }

  export type ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    data: XOR<ProjectSettingsChangeLogUpdateWithoutChangerInput, ProjectSettingsChangeLogUncheckedUpdateWithoutChangerInput>
  }

  export type ProjectSettingsChangeLogUpdateManyWithWhereWithoutChangerInput = {
    where: ProjectSettingsChangeLogScalarWhereInput
    data: XOR<ProjectSettingsChangeLogUpdateManyMutationInput, ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerInput>
  }

  export type ProjectSettingsChangeLogScalarWhereInput = {
    AND?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
    OR?: ProjectSettingsChangeLogScalarWhereInput[]
    NOT?: ProjectSettingsChangeLogScalarWhereInput | ProjectSettingsChangeLogScalarWhereInput[]
    id?: IntFilter<"ProjectSettingsChangeLog"> | number
    projectId?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingKey?: StringFilter<"ProjectSettingsChangeLog"> | string
    category?: StringFilter<"ProjectSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    newValue?: StringFilter<"ProjectSettingsChangeLog"> | string
    reason?: StringNullableFilter<"ProjectSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"ProjectSettingsChangeLog"> | number
    settingId?: IntFilter<"ProjectSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"ProjectSettingsChangeLog"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectManagerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    type?: StringFilter<"Project"> | string
    projectTypeId?: IntNullableFilter<"Project"> | number | null
    projectStatusId?: IntNullableFilter<"Project"> | number | null
    description?: StringNullableFilter<"Project"> | string | null
    scope?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    priority?: StringFilter<"Project"> | string
    urgentReason?: StringNullableFilter<"Project"> | string | null
    urgentMarkedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    urgentMarkedById?: IntNullableFilter<"Project"> | number | null
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    projectManagerId?: IntNullableFilter<"Project"> | number | null
    createdById?: IntNullableFilter<"Project"> | number | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutUrgentMarkedByInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUrgentMarkedByInput, ProjectUncheckedUpdateWithoutUrgentMarkedByInput>
    create: XOR<ProjectCreateWithoutUrgentMarkedByInput, ProjectUncheckedCreateWithoutUrgentMarkedByInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUrgentMarkedByInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUrgentMarkedByInput, ProjectUncheckedUpdateWithoutUrgentMarkedByInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUrgentMarkedByInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUrgentMarkedByInput>
  }

  export type SettingsChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SettingsChangeLogWhereUniqueInput
    update: XOR<SettingsChangeLogUpdateWithoutUserInput, SettingsChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<SettingsChangeLogCreateWithoutUserInput, SettingsChangeLogUncheckedCreateWithoutUserInput>
  }

  export type SettingsChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SettingsChangeLogWhereUniqueInput
    data: XOR<SettingsChangeLogUpdateWithoutUserInput, SettingsChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type SettingsChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: SettingsChangeLogScalarWhereInput
    data: XOR<SettingsChangeLogUpdateManyMutationInput, SettingsChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SettingsChangeLogScalarWhereInput = {
    AND?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
    OR?: SettingsChangeLogScalarWhereInput[]
    NOT?: SettingsChangeLogScalarWhereInput | SettingsChangeLogScalarWhereInput[]
    id?: IntFilter<"SettingsChangeLog"> | number
    settingKey?: StringFilter<"SettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"SettingsChangeLog"> | string | null
    newValue?: StringFilter<"SettingsChangeLog"> | string
    reason?: StringNullableFilter<"SettingsChangeLog"> | string | null
    userId?: IntFilter<"SettingsChangeLog"> | number
    settingId?: IntFilter<"SettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"SettingsChangeLog"> | Date | string
  }

  export type SubtaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutCreatorInput, SubtaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<SubtaskCreateWithoutCreatorInput, SubtaskUncheckedCreateWithoutCreatorInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutCreatorInput, SubtaskUncheckedUpdateWithoutCreatorInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutCreatorInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SubtaskScalarWhereInput = {
    AND?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    OR?: SubtaskScalarWhereInput[]
    NOT?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[]
    id?: IntFilter<"Subtask"> | number
    title?: StringFilter<"Subtask"> | string
    description?: StringNullableFilter<"Subtask"> | string | null
    status?: StringFilter<"Subtask"> | string
    priority?: StringFilter<"Subtask"> | string
    startDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"Subtask"> | Date | string | null
    estimatedHours?: FloatFilter<"Subtask"> | number
    actualHours?: FloatFilter<"Subtask"> | number
    parentTaskId?: IntFilter<"Subtask"> | number
    assignedToId?: IntNullableFilter<"Subtask"> | number | null
    teamId?: IntNullableFilter<"Subtask"> | number | null
    createdById?: IntFilter<"Subtask"> | number
    createdAt?: DateTimeFilter<"Subtask"> | Date | string
    updatedAt?: DateTimeFilter<"Subtask"> | Date | string
  }

  export type SubtaskUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutAssignedToInput, SubtaskUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SubtaskCreateWithoutAssignedToInput, SubtaskUncheckedCreateWithoutAssignedToInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutAssignedToInput, SubtaskUncheckedUpdateWithoutAssignedToInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutAssignedToInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type SystemSettingUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: SystemSettingWhereUniqueInput
    update: XOR<SystemSettingUpdateWithoutUpdaterInput, SystemSettingUncheckedUpdateWithoutUpdaterInput>
    create: XOR<SystemSettingCreateWithoutUpdaterInput, SystemSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type SystemSettingUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: SystemSettingWhereUniqueInput
    data: XOR<SystemSettingUpdateWithoutUpdaterInput, SystemSettingUncheckedUpdateWithoutUpdaterInput>
  }

  export type SystemSettingUpdateManyWithWhereWithoutUpdaterInput = {
    where: SystemSettingScalarWhereInput
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type SystemSettingScalarWhereInput = {
    AND?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    OR?: SystemSettingScalarWhereInput[]
    NOT?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    id?: IntFilter<"SystemSetting"> | number
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedBy?: IntFilter<"SystemSetting"> | number
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    taskStatusId?: IntNullableFilter<"Task"> | number | null
    priority?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    plannedDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    estimatedHours?: FloatFilter<"Task"> | number
    actualHours?: FloatFilter<"Task"> | number
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    projectId?: IntFilter<"Task"> | number
    teamId?: IntNullableFilter<"Task"> | number | null
    createdById?: IntNullableFilter<"Task"> | number | null
    deliverableId?: IntNullableFilter<"Task"> | number | null
    startedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
  }

  export type TimeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutUserInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeLogScalarWhereInput = {
    AND?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    OR?: TimeLogScalarWhereInput[]
    NOT?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    id?: IntFilter<"TimeLog"> | number
    hoursLogged?: FloatFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    userId?: IntFilter<"TimeLog"> | number
    taskId?: IntNullableFilter<"TimeLog"> | number | null
    subtaskId?: IntNullableFilter<"TimeLog"> | number | null
  }

  export type UserSettingUpsertWithWhereUniqueWithoutUpdaterInput = {
    where: UserSettingWhereUniqueInput
    update: XOR<UserSettingUpdateWithoutUpdaterInput, UserSettingUncheckedUpdateWithoutUpdaterInput>
    create: XOR<UserSettingCreateWithoutUpdaterInput, UserSettingUncheckedCreateWithoutUpdaterInput>
  }

  export type UserSettingUpdateWithWhereUniqueWithoutUpdaterInput = {
    where: UserSettingWhereUniqueInput
    data: XOR<UserSettingUpdateWithoutUpdaterInput, UserSettingUncheckedUpdateWithoutUpdaterInput>
  }

  export type UserSettingUpdateManyWithWhereWithoutUpdaterInput = {
    where: UserSettingScalarWhereInput
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyWithoutUpdaterInput>
  }

  export type UserSettingScalarWhereInput = {
    AND?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
    OR?: UserSettingScalarWhereInput[]
    NOT?: UserSettingScalarWhereInput | UserSettingScalarWhereInput[]
    id?: IntFilter<"UserSetting"> | number
    userId?: IntFilter<"UserSetting"> | number
    key?: StringFilter<"UserSetting"> | string
    value?: StringFilter<"UserSetting"> | string
    category?: StringFilter<"UserSetting"> | string
    updatedAt?: DateTimeFilter<"UserSetting"> | Date | string
    updatedBy?: IntFilter<"UserSetting"> | number
  }

  export type UserSettingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSettingWhereUniqueInput
    update: XOR<UserSettingUpdateWithoutUserInput, UserSettingUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingCreateWithoutUserInput, UserSettingUncheckedCreateWithoutUserInput>
  }

  export type UserSettingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSettingWhereUniqueInput
    data: XOR<UserSettingUpdateWithoutUserInput, UserSettingUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingUpdateManyWithWhereWithoutUserInput = {
    where: UserSettingScalarWhereInput
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSettingsChangeLogUpsertWithWhereUniqueWithoutChangerInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    update: XOR<UserSettingsChangeLogUpdateWithoutChangerInput, UserSettingsChangeLogUncheckedUpdateWithoutChangerInput>
    create: XOR<UserSettingsChangeLogCreateWithoutChangerInput, UserSettingsChangeLogUncheckedCreateWithoutChangerInput>
  }

  export type UserSettingsChangeLogUpdateWithWhereUniqueWithoutChangerInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    data: XOR<UserSettingsChangeLogUpdateWithoutChangerInput, UserSettingsChangeLogUncheckedUpdateWithoutChangerInput>
  }

  export type UserSettingsChangeLogUpdateManyWithWhereWithoutChangerInput = {
    where: UserSettingsChangeLogScalarWhereInput
    data: XOR<UserSettingsChangeLogUpdateManyMutationInput, UserSettingsChangeLogUncheckedUpdateManyWithoutChangerInput>
  }

  export type UserSettingsChangeLogScalarWhereInput = {
    AND?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
    OR?: UserSettingsChangeLogScalarWhereInput[]
    NOT?: UserSettingsChangeLogScalarWhereInput | UserSettingsChangeLogScalarWhereInput[]
    id?: IntFilter<"UserSettingsChangeLog"> | number
    userId?: IntFilter<"UserSettingsChangeLog"> | number
    settingKey?: StringFilter<"UserSettingsChangeLog"> | string
    category?: StringFilter<"UserSettingsChangeLog"> | string
    oldValue?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    newValue?: StringFilter<"UserSettingsChangeLog"> | string
    reason?: StringNullableFilter<"UserSettingsChangeLog"> | string | null
    changedBy?: IntFilter<"UserSettingsChangeLog"> | number
    settingId?: IntFilter<"UserSettingsChangeLog"> | number
    createdAt?: DateTimeFilter<"UserSettingsChangeLog"> | Date | string
  }

  export type UserSettingsChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    update: XOR<UserSettingsChangeLogUpdateWithoutUserInput, UserSettingsChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsChangeLogCreateWithoutUserInput, UserSettingsChangeLogUncheckedCreateWithoutUserInput>
  }

  export type UserSettingsChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    data: XOR<UserSettingsChangeLogUpdateWithoutUserInput, UserSettingsChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: UserSettingsChangeLogScalarWhereInput
    data: XOR<UserSettingsChangeLogUpdateManyMutationInput, UserSettingsChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamUpsertWithoutUsersInput = {
    update: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutUsersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
    create: XOR<TaskCreateWithoutAssigneesInput, TaskUncheckedCreateWithoutAssigneesInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneesInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneesInput, TaskUncheckedUpdateWithoutAssigneesInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneesInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneesInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutTeamLeadInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutTeamLeadInput, TeamUncheckedUpdateWithoutTeamLeadInput>
    create: XOR<TeamCreateWithoutTeamLeadInput, TeamUncheckedCreateWithoutTeamLeadInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutTeamLeadInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutTeamLeadInput, TeamUncheckedUpdateWithoutTeamLeadInput>
  }

  export type TeamUpdateManyWithWhereWithoutTeamLeadInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutTeamLeadInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    teamLeadId?: IntNullableFilter<"Team"> | number | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: IntFilter<"TeamMember"> | number
    teamId?: IntFilter<"TeamMember"> | number
    userId?: IntFilter<"TeamMember"> | number
    role?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    scopeType?: StringNullableFilter<"UserRole"> | string | null
    scopeId?: IntNullableFilter<"UserRole"> | number | null
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: IntNullableFilter<"UserRole"> | number | null
  }

  export type UserRoleUpsertWithWhereUniqueWithoutAssignerInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutAssignerInput, UserRoleUncheckedUpdateWithoutAssignerInput>
    create: XOR<UserRoleCreateWithoutAssignerInput, UserRoleUncheckedCreateWithoutAssignerInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutAssignerInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutAssignerInput, UserRoleUncheckedUpdateWithoutAssignerInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutAssignerInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutAssignerInput>
  }

  export type UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutUserInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    update: XOR<UrgentProjectAcknowledgementUpdateWithoutUserInput, UrgentProjectAcknowledgementUncheckedUpdateWithoutUserInput>
    create: XOR<UrgentProjectAcknowledgementCreateWithoutUserInput, UrgentProjectAcknowledgementUncheckedCreateWithoutUserInput>
  }

  export type UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutUserInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    data: XOR<UrgentProjectAcknowledgementUpdateWithoutUserInput, UrgentProjectAcknowledgementUncheckedUpdateWithoutUserInput>
  }

  export type UrgentProjectAcknowledgementUpdateManyWithWhereWithoutUserInput = {
    where: UrgentProjectAcknowledgementScalarWhereInput
    data: XOR<UrgentProjectAcknowledgementUpdateManyMutationInput, UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserInput>
  }

  export type UrgentProjectAcknowledgementScalarWhereInput = {
    AND?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
    OR?: UrgentProjectAcknowledgementScalarWhereInput[]
    NOT?: UrgentProjectAcknowledgementScalarWhereInput | UrgentProjectAcknowledgementScalarWhereInput[]
    id?: IntFilter<"UrgentProjectAcknowledgement"> | number
    projectId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    userId?: IntFilter<"UrgentProjectAcknowledgement"> | number
    acknowledgedAt?: DateTimeFilter<"UrgentProjectAcknowledgement"> | Date | string
  }

  export type AutomationRuleCreateWithoutTeamInput = {
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedRulesInput
  }

  export type AutomationRuleUncheckedCreateWithoutTeamInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdById: number
  }

  export type AutomationRuleCreateOrConnectWithoutTeamInput = {
    where: AutomationRuleWhereUniqueInput
    create: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput>
  }

  export type AutomationRuleCreateManyTeamInputEnvelope = {
    data: AutomationRuleCreateManyTeamInput | AutomationRuleCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutTeamInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutTeamInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutTeamInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput>
  }

  export type SubtaskCreateManyTeamInputEnvelope = {
    data: SubtaskCreateManyTeamInput | SubtaskCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTeamInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutTeamInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutTeamInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskCreateManyTeamInputEnvelope = {
    data: TaskCreateManyTeamInput | TaskCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTeamInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserCreateManyTeamInputEnvelope = {
    data: UserCreateManyTeamInput | UserCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTeamsLedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsLedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsLedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsLedInput, UserUncheckedCreateWithoutTeamsLedInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: number
    userId: number
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTeamCreateWithoutTeamInput = {
    assignedAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectTeamsInput
  }

  export type ProjectTeamUncheckedCreateWithoutTeamInput = {
    id?: number
    projectId: number
    assignedAt?: Date | string
  }

  export type ProjectTeamCreateOrConnectWithoutTeamInput = {
    where: ProjectTeamWhereUniqueInput
    create: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput>
  }

  export type ProjectTeamCreateManyTeamInputEnvelope = {
    data: ProjectTeamCreateManyTeamInput | ProjectTeamCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type AutomationRuleUpsertWithWhereUniqueWithoutTeamInput = {
    where: AutomationRuleWhereUniqueInput
    update: XOR<AutomationRuleUpdateWithoutTeamInput, AutomationRuleUncheckedUpdateWithoutTeamInput>
    create: XOR<AutomationRuleCreateWithoutTeamInput, AutomationRuleUncheckedCreateWithoutTeamInput>
  }

  export type AutomationRuleUpdateWithWhereUniqueWithoutTeamInput = {
    where: AutomationRuleWhereUniqueInput
    data: XOR<AutomationRuleUpdateWithoutTeamInput, AutomationRuleUncheckedUpdateWithoutTeamInput>
  }

  export type AutomationRuleUpdateManyWithWhereWithoutTeamInput = {
    where: AutomationRuleScalarWhereInput
    data: XOR<AutomationRuleUpdateManyMutationInput, AutomationRuleUncheckedUpdateManyWithoutTeamInput>
  }

  export type SubtaskUpsertWithWhereUniqueWithoutTeamInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutTeamInput, SubtaskUncheckedUpdateWithoutTeamInput>
    create: XOR<SubtaskCreateWithoutTeamInput, SubtaskUncheckedCreateWithoutTeamInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutTeamInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutTeamInput, SubtaskUncheckedUpdateWithoutTeamInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutTeamInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutTeamInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
  }

  export type TaskUpdateManyWithWhereWithoutTeamInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
    create: XOR<UserCreateWithoutTeamInput, UserUncheckedCreateWithoutTeamInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamInput, UserUncheckedUpdateWithoutTeamInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    teamId?: IntNullableFilter<"User"> | number | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
  }

  export type UserUpsertWithoutTeamsLedInput = {
    update: XOR<UserUpdateWithoutTeamsLedInput, UserUncheckedUpdateWithoutTeamsLedInput>
    create: XOR<UserCreateWithoutTeamsLedInput, UserUncheckedCreateWithoutTeamsLedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsLedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsLedInput, UserUncheckedUpdateWithoutTeamsLedInput>
  }

  export type UserUpdateWithoutTeamsLedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsLedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type ProjectTeamUpsertWithWhereUniqueWithoutTeamInput = {
    where: ProjectTeamWhereUniqueInput
    update: XOR<ProjectTeamUpdateWithoutTeamInput, ProjectTeamUncheckedUpdateWithoutTeamInput>
    create: XOR<ProjectTeamCreateWithoutTeamInput, ProjectTeamUncheckedCreateWithoutTeamInput>
  }

  export type ProjectTeamUpdateWithWhereUniqueWithoutTeamInput = {
    where: ProjectTeamWhereUniqueInput
    data: XOR<ProjectTeamUpdateWithoutTeamInput, ProjectTeamUncheckedUpdateWithoutTeamInput>
  }

  export type ProjectTeamUpdateManyWithWhereWithoutTeamInput = {
    where: ProjectTeamScalarWhereInput
    data: XOR<ProjectTeamUpdateManyMutationInput, ProjectTeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type ProjectTeamScalarWhereInput = {
    AND?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
    OR?: ProjectTeamScalarWhereInput[]
    NOT?: ProjectTeamScalarWhereInput | ProjectTeamScalarWhereInput[]
    id?: IntFilter<"ProjectTeam"> | number
    projectId?: IntFilter<"ProjectTeam"> | number
    teamId?: IntFilter<"ProjectTeam"> | number
    assignedAt?: DateTimeFilter<"ProjectTeam"> | Date | string
  }

  export type DeliverableCreateWithoutProjectInput = {
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutDeliverableInput
  }

  export type DeliverableUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutDeliverableInput
  }

  export type DeliverableCreateOrConnectWithoutProjectInput = {
    where: DeliverableWhereUniqueInput
    create: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput>
  }

  export type DeliverableCreateManyProjectInputEnvelope = {
    data: DeliverableCreateManyProjectInput | DeliverableCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectNotificationPreferenceCreateWithoutProjectInput = {
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectNotificationPreferencesInput
  }

  export type ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationPreferenceCreateOrConnectWithoutProjectInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    create: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotificationPreferenceCreateManyProjectInputEnvelope = {
    data: ProjectNotificationPreferenceCreateManyProjectInput | ProjectNotificationPreferenceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectNotificationCreateWithoutProjectInput = {
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProjectNotificationsInput
  }

  export type ProjectNotificationUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectNotificationCreateOrConnectWithoutProjectInput = {
    where: ProjectNotificationWhereUniqueInput
    create: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotificationCreateManyProjectInputEnvelope = {
    data: ProjectNotificationCreateManyProjectInput | ProjectNotificationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectPhaseCreateWithoutProjectInput = {
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectPhaseUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectPhaseCreateOrConnectWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    create: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput>
  }

  export type ProjectPhaseCreateManyProjectInputEnvelope = {
    data: ProjectPhaseCreateManyProjectInput | ProjectPhaseCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingCreateWithoutProjectInput = {
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutProjectSettingsUpdatedInput
    changeLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingUncheckedCreateWithoutProjectInput = {
    id?: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updatedBy: number
    changeLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutSettingInput
  }

  export type ProjectSettingCreateOrConnectWithoutProjectInput = {
    where: ProjectSettingWhereUniqueInput
    create: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingCreateManyProjectInputEnvelope = {
    data: ProjectSettingCreateManyProjectInput | ProjectSettingCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSettingsChangeLogCreateWithoutProjectInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    setting: ProjectSettingCreateNestedOneWithoutChangeLogsInput
    changer: UserCreateNestedOneWithoutProjectSettingsChangedInput
  }

  export type ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput = {
    id?: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogCreateOrConnectWithoutProjectInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    create: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingsChangeLogCreateManyProjectInputEnvelope = {
    data: ProjectSettingsChangeLogCreateManyProjectInput | ProjectSettingsChangeLogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUserCreateWithoutProjectInput = {
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectUserUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectUserCreateOrConnectWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    create: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUserCreateManyProjectInputEnvelope = {
    data: ProjectUserCreateManyProjectInput | ProjectUserCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProjectsManagedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsManagedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsManagedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsManagedInput, UserUncheckedCreateWithoutProjectsManagedInput>
  }

  export type UserCreateWithoutProjectsMarkedUrgentInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsMarkedUrgentInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsMarkedUrgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsMarkedUrgentInput, UserUncheckedCreateWithoutProjectsMarkedUrgentInput>
  }

  export type ProjectTypeCreateWithoutProjectsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    displayOrder?: number
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTypeUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    displayOrder?: number
    color?: string | null
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTypeCreateOrConnectWithoutProjectsInput = {
    where: ProjectTypeWhereUniqueInput
    create: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectStatusCreateWithoutProjectsInput = {
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStatusUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isUrgent?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectStatusCreateOrConnectWithoutProjectsInput = {
    where: ProjectStatusWhereUniqueInput
    create: XOR<ProjectStatusCreateWithoutProjectsInput, ProjectStatusUncheckedCreateWithoutProjectsInput>
  }

  export type ScopeHistoryCreateWithoutProjectInput = {
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
  }

  export type ScopeHistoryUncheckedCreateWithoutProjectInput = {
    id?: number
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
  }

  export type ScopeHistoryCreateOrConnectWithoutProjectInput = {
    where: ScopeHistoryWhereUniqueInput
    create: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput>
  }

  export type ScopeHistoryCreateManyProjectInputEnvelope = {
    data: ScopeHistoryCreateManyProjectInput | ScopeHistoryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutProjectInput = {
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    performedBy?: UserCreateNestedOneWithoutActivityLogsPerformedInput
    affectedUser?: UserCreateNestedOneWithoutActivityLogsAffectedInput
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutProjectInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogCreateOrConnectWithoutProjectInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput>
  }

  export type ActivityLogCreateManyProjectInputEnvelope = {
    data: ActivityLogCreateManyProjectInput | ActivityLogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTeamCreateWithoutProjectInput = {
    assignedAt?: Date | string
    team: TeamCreateNestedOneWithoutProjectTeamsInput
  }

  export type ProjectTeamUncheckedCreateWithoutProjectInput = {
    id?: number
    teamId: number
    assignedAt?: Date | string
  }

  export type ProjectTeamCreateOrConnectWithoutProjectInput = {
    where: ProjectTeamWhereUniqueInput
    create: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTeamCreateManyProjectInputEnvelope = {
    data: ProjectTeamCreateManyProjectInput | ProjectTeamCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UrgentProjectAcknowledgementCreateWithoutProjectInput = {
    acknowledgedAt?: Date | string
    user: UserCreateNestedOneWithoutUrgentAcknowledgementsInput
  }

  export type UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput = {
    id?: number
    userId: number
    acknowledgedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementCreateOrConnectWithoutProjectInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    create: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput>
  }

  export type UrgentProjectAcknowledgementCreateManyProjectInputEnvelope = {
    data: UrgentProjectAcknowledgementCreateManyProjectInput | UrgentProjectAcknowledgementCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DeliverableUpsertWithWhereUniqueWithoutProjectInput = {
    where: DeliverableWhereUniqueInput
    update: XOR<DeliverableUpdateWithoutProjectInput, DeliverableUncheckedUpdateWithoutProjectInput>
    create: XOR<DeliverableCreateWithoutProjectInput, DeliverableUncheckedCreateWithoutProjectInput>
  }

  export type DeliverableUpdateWithWhereUniqueWithoutProjectInput = {
    where: DeliverableWhereUniqueInput
    data: XOR<DeliverableUpdateWithoutProjectInput, DeliverableUncheckedUpdateWithoutProjectInput>
  }

  export type DeliverableUpdateManyWithWhereWithoutProjectInput = {
    where: DeliverableScalarWhereInput
    data: XOR<DeliverableUpdateManyMutationInput, DeliverableUncheckedUpdateManyWithoutProjectInput>
  }

  export type DeliverableScalarWhereInput = {
    AND?: DeliverableScalarWhereInput | DeliverableScalarWhereInput[]
    OR?: DeliverableScalarWhereInput[]
    NOT?: DeliverableScalarWhereInput | DeliverableScalarWhereInput[]
    id?: IntFilter<"Deliverable"> | number
    projectId?: IntFilter<"Deliverable"> | number
    name?: StringFilter<"Deliverable"> | string
    description?: StringNullableFilter<"Deliverable"> | string | null
    acceptanceCriteria?: StringNullableFilter<"Deliverable"> | string | null
    status?: StringFilter<"Deliverable"> | string
    createdAt?: DateTimeFilter<"Deliverable"> | Date | string
    updatedAt?: DateTimeFilter<"Deliverable"> | Date | string
  }

  export type ProjectNotificationPreferenceUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    update: XOR<ProjectNotificationPreferenceUpdateWithoutProjectInput, ProjectNotificationPreferenceUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectNotificationPreferenceCreateWithoutProjectInput, ProjectNotificationPreferenceUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotificationPreferenceUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotificationPreferenceWhereUniqueInput
    data: XOR<ProjectNotificationPreferenceUpdateWithoutProjectInput, ProjectNotificationPreferenceUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectNotificationPreferenceUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectNotificationPreferenceScalarWhereInput
    data: XOR<ProjectNotificationPreferenceUpdateManyMutationInput, ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectNotificationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotificationWhereUniqueInput
    update: XOR<ProjectNotificationUpdateWithoutProjectInput, ProjectNotificationUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectNotificationCreateWithoutProjectInput, ProjectNotificationUncheckedCreateWithoutProjectInput>
  }

  export type ProjectNotificationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectNotificationWhereUniqueInput
    data: XOR<ProjectNotificationUpdateWithoutProjectInput, ProjectNotificationUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectNotificationUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectNotificationScalarWhereInput
    data: XOR<ProjectNotificationUpdateManyMutationInput, ProjectNotificationUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectPhaseUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    update: XOR<ProjectPhaseUpdateWithoutProjectInput, ProjectPhaseUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectPhaseCreateWithoutProjectInput, ProjectPhaseUncheckedCreateWithoutProjectInput>
  }

  export type ProjectPhaseUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectPhaseWhereUniqueInput
    data: XOR<ProjectPhaseUpdateWithoutProjectInput, ProjectPhaseUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectPhaseUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectPhaseScalarWhereInput
    data: XOR<ProjectPhaseUpdateManyMutationInput, ProjectPhaseUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectPhaseScalarWhereInput = {
    AND?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
    OR?: ProjectPhaseScalarWhereInput[]
    NOT?: ProjectPhaseScalarWhereInput | ProjectPhaseScalarWhereInput[]
    id?: IntFilter<"ProjectPhase"> | number
    projectId?: IntFilter<"ProjectPhase"> | number
    name?: StringFilter<"ProjectPhase"> | string
    description?: StringNullableFilter<"ProjectPhase"> | string | null
    sequenceOrder?: IntFilter<"ProjectPhase"> | number
    startDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ProjectPhase"> | Date | string | null
    status?: StringFilter<"ProjectPhase"> | string
    createdAt?: DateTimeFilter<"ProjectPhase"> | Date | string
  }

  export type ProjectSettingUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingWhereUniqueInput
    update: XOR<ProjectSettingUpdateWithoutProjectInput, ProjectSettingUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSettingCreateWithoutProjectInput, ProjectSettingUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingWhereUniqueInput
    data: XOR<ProjectSettingUpdateWithoutProjectInput, ProjectSettingUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSettingUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSettingScalarWhereInput
    data: XOR<ProjectSettingUpdateManyMutationInput, ProjectSettingUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    update: XOR<ProjectSettingsChangeLogUpdateWithoutProjectInput, ProjectSettingsChangeLogUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSettingsChangeLogCreateWithoutProjectInput, ProjectSettingsChangeLogUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    data: XOR<ProjectSettingsChangeLogUpdateWithoutProjectInput, ProjectSettingsChangeLogUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSettingsChangeLogUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSettingsChangeLogScalarWhereInput
    data: XOR<ProjectSettingsChangeLogUpdateManyMutationInput, ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUserUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    update: XOR<ProjectUserUpdateWithoutProjectInput, ProjectUserUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUserCreateWithoutProjectInput, ProjectUserUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUserUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUserWhereUniqueInput
    data: XOR<ProjectUserUpdateWithoutProjectInput, ProjectUserUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUserUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUserScalarWhereInput
    data: XOR<ProjectUserUpdateManyMutationInput, ProjectUserUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUserScalarWhereInput = {
    AND?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
    OR?: ProjectUserScalarWhereInput[]
    NOT?: ProjectUserScalarWhereInput | ProjectUserScalarWhereInput[]
    id?: IntFilter<"ProjectUser"> | number
    projectId?: IntFilter<"ProjectUser"> | number
    userId?: IntFilter<"ProjectUser"> | number
    role?: StringFilter<"ProjectUser"> | string
    allocationPercentage?: IntFilter<"ProjectUser"> | number
    joinedAt?: DateTimeFilter<"ProjectUser"> | Date | string
    leftAt?: DateTimeNullableFilter<"ProjectUser"> | Date | string | null
    createdAt?: DateTimeFilter<"ProjectUser"> | Date | string
  }

  export type UserUpsertWithoutProjectsManagedInput = {
    update: XOR<UserUpdateWithoutProjectsManagedInput, UserUncheckedUpdateWithoutProjectsManagedInput>
    create: XOR<UserCreateWithoutProjectsManagedInput, UserUncheckedCreateWithoutProjectsManagedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsManagedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsManagedInput, UserUncheckedUpdateWithoutProjectsManagedInput>
  }

  export type UserUpdateWithoutProjectsManagedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsManagedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutProjectsMarkedUrgentInput = {
    update: XOR<UserUpdateWithoutProjectsMarkedUrgentInput, UserUncheckedUpdateWithoutProjectsMarkedUrgentInput>
    create: XOR<UserCreateWithoutProjectsMarkedUrgentInput, UserUncheckedCreateWithoutProjectsMarkedUrgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsMarkedUrgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsMarkedUrgentInput, UserUncheckedUpdateWithoutProjectsMarkedUrgentInput>
  }

  export type UserUpdateWithoutProjectsMarkedUrgentInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsMarkedUrgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectTypeUpsertWithoutProjectsInput = {
    update: XOR<ProjectTypeUpdateWithoutProjectsInput, ProjectTypeUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectTypeCreateWithoutProjectsInput, ProjectTypeUncheckedCreateWithoutProjectsInput>
    where?: ProjectTypeWhereInput
  }

  export type ProjectTypeUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProjectTypeWhereInput
    data: XOR<ProjectTypeUpdateWithoutProjectsInput, ProjectTypeUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectTypeUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTypeUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusUpsertWithoutProjectsInput = {
    update: XOR<ProjectStatusUpdateWithoutProjectsInput, ProjectStatusUncheckedUpdateWithoutProjectsInput>
    create: XOR<ProjectStatusCreateWithoutProjectsInput, ProjectStatusUncheckedCreateWithoutProjectsInput>
    where?: ProjectStatusWhereInput
  }

  export type ProjectStatusUpdateToOneWithWhereWithoutProjectsInput = {
    where?: ProjectStatusWhereInput
    data: XOR<ProjectStatusUpdateWithoutProjectsInput, ProjectStatusUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectStatusUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScopeHistoryWhereUniqueInput
    update: XOR<ScopeHistoryUpdateWithoutProjectInput, ScopeHistoryUncheckedUpdateWithoutProjectInput>
    create: XOR<ScopeHistoryCreateWithoutProjectInput, ScopeHistoryUncheckedCreateWithoutProjectInput>
  }

  export type ScopeHistoryUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScopeHistoryWhereUniqueInput
    data: XOR<ScopeHistoryUpdateWithoutProjectInput, ScopeHistoryUncheckedUpdateWithoutProjectInput>
  }

  export type ScopeHistoryUpdateManyWithWhereWithoutProjectInput = {
    where: ScopeHistoryScalarWhereInput
    data: XOR<ScopeHistoryUpdateManyMutationInput, ScopeHistoryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScopeHistoryScalarWhereInput = {
    AND?: ScopeHistoryScalarWhereInput | ScopeHistoryScalarWhereInput[]
    OR?: ScopeHistoryScalarWhereInput[]
    NOT?: ScopeHistoryScalarWhereInput | ScopeHistoryScalarWhereInput[]
    id?: IntFilter<"ScopeHistory"> | number
    projectId?: IntFilter<"ScopeHistory"> | number
    scopeText?: StringFilter<"ScopeHistory"> | string
    changeReason?: StringNullableFilter<"ScopeHistory"> | string | null
    changedById?: IntFilter<"ScopeHistory"> | number
    createdAt?: DateTimeFilter<"ScopeHistory"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutProjectInput, ActivityLogUncheckedUpdateWithoutProjectInput>
    create: XOR<ActivityLogCreateWithoutProjectInput, ActivityLogUncheckedCreateWithoutProjectInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutProjectInput, ActivityLogUncheckedUpdateWithoutProjectInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutProjectInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTeamUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTeamWhereUniqueInput
    update: XOR<ProjectTeamUpdateWithoutProjectInput, ProjectTeamUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTeamCreateWithoutProjectInput, ProjectTeamUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTeamUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTeamWhereUniqueInput
    data: XOR<ProjectTeamUpdateWithoutProjectInput, ProjectTeamUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTeamUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTeamScalarWhereInput
    data: XOR<ProjectTeamUpdateManyMutationInput, ProjectTeamUncheckedUpdateManyWithoutProjectInput>
  }

  export type UrgentProjectAcknowledgementUpsertWithWhereUniqueWithoutProjectInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    update: XOR<UrgentProjectAcknowledgementUpdateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedUpdateWithoutProjectInput>
    create: XOR<UrgentProjectAcknowledgementCreateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedCreateWithoutProjectInput>
  }

  export type UrgentProjectAcknowledgementUpdateWithWhereUniqueWithoutProjectInput = {
    where: UrgentProjectAcknowledgementWhereUniqueInput
    data: XOR<UrgentProjectAcknowledgementUpdateWithoutProjectInput, UrgentProjectAcknowledgementUncheckedUpdateWithoutProjectInput>
  }

  export type UrgentProjectAcknowledgementUpdateManyWithWhereWithoutProjectInput = {
    where: UrgentProjectAcknowledgementScalarWhereInput
    data: XOR<UrgentProjectAcknowledgementUpdateManyMutationInput, UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectInput>
  }

  export type AttachmentCreateWithoutTaskInput = {
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    uploader: UserCreateNestedOneWithoutUploadedFilesInput
  }

  export type AttachmentUncheckedCreateWithoutTaskInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    uploadedById: number
  }

  export type AttachmentCreateOrConnectWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput>
  }

  export type AttachmentCreateManyTaskInputEnvelope = {
    data: AttachmentCreateManyTaskInput | AttachmentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTaskInput = {
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    subtask?: SubtaskCreateNestedOneWithoutCommentsInput
    mentions?: CommentMentionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutTaskInput = {
    id?: number
    content: string
    createdAt?: Date | string
    subtaskId?: number | null
    userId: number
    mentions?: CommentMentionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutTaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentCreateManyTaskInputEnvelope = {
    data: CommentCreateManyTaskInput | CommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskCreateWithoutParentTaskInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutParentTaskInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutParentTaskInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
  }

  export type SubtaskCreateManyParentTaskInputEnvelope = {
    data: SubtaskCreateManyParentTaskInput | SubtaskCreateManyParentTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskDependencyCreateWithoutDependsOnTaskInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutDependenciesInput
  }

  export type TaskDependencyUncheckedCreateWithoutDependsOnTaskInput = {
    taskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskDependencyCreateOrConnectWithoutDependsOnTaskInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput>
  }

  export type TaskDependencyCreateManyDependsOnTaskInputEnvelope = {
    data: TaskDependencyCreateManyDependsOnTaskInput | TaskDependencyCreateManyDependsOnTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskDependencyCreateWithoutTaskInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    dependsOnTask: TaskCreateNestedOneWithoutDependentsInput
  }

  export type TaskDependencyUncheckedCreateWithoutTaskInput = {
    dependsOnTaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskDependencyCreateOrConnectWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    create: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
  }

  export type TaskDependencyCreateManyTaskInputEnvelope = {
    data: TaskDependencyCreateManyTaskInput | TaskDependencyCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskLabelCreateWithoutTaskInput = {
    createdAt?: Date | string
    label: LabelCreateNestedOneWithoutTasksInput
  }

  export type TaskLabelUncheckedCreateWithoutTaskInput = {
    labelId: number
    createdAt?: Date | string
  }

  export type TaskLabelCreateOrConnectWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelCreateManyTaskInputEnvelope = {
    data: TaskLabelCreateManyTaskInput | TaskLabelCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type DeliverableCreateWithoutTasksInput = {
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDeliverablesInput
  }

  export type DeliverableUncheckedCreateWithoutTasksInput = {
    id?: number
    projectId: number
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliverableCreateOrConnectWithoutTasksInput = {
    where: DeliverableWhereUniqueInput
    create: XOR<DeliverableCreateWithoutTasksInput, DeliverableUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksCreatedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksCreatedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
  }

  export type TeamCreateWithoutTasksInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTasksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type TaskStatusCreateWithoutTasksInput = {
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskStatusUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    color?: string
    isDefault?: boolean
    isFinal?: boolean
    isBlocking?: boolean
    orderIndex?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskStatusCreateOrConnectWithoutTasksInput = {
    where: TaskStatusWhereUniqueInput
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
  }

  export type TimeLogCreateWithoutTaskInput = {
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    subtask?: SubtaskCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutTaskInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    subtaskId?: number | null
  }

  export type TimeLogCreateOrConnectWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogCreateManyTaskInputEnvelope = {
    data: TimeLogCreateManyTaskInput | TimeLogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedTasksInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutTaskInput, AttachmentUncheckedUpdateWithoutTaskInput>
    create: XOR<AttachmentCreateWithoutTaskInput, AttachmentUncheckedCreateWithoutTaskInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutTaskInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutTaskInput, AttachmentUncheckedUpdateWithoutTaskInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutTaskInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutTaskInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
    create: XOR<CommentCreateWithoutTaskInput, CommentUncheckedCreateWithoutTaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTaskInput, CommentUncheckedUpdateWithoutTaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutTaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type SubtaskUpsertWithWhereUniqueWithoutParentTaskInput = {
    where: SubtaskWhereUniqueInput
    update: XOR<SubtaskUpdateWithoutParentTaskInput, SubtaskUncheckedUpdateWithoutParentTaskInput>
    create: XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
  }

  export type SubtaskUpdateWithWhereUniqueWithoutParentTaskInput = {
    where: SubtaskWhereUniqueInput
    data: XOR<SubtaskUpdateWithoutParentTaskInput, SubtaskUncheckedUpdateWithoutParentTaskInput>
  }

  export type SubtaskUpdateManyWithWhereWithoutParentTaskInput = {
    where: SubtaskScalarWhereInput
    data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutParentTaskInput>
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutDependsOnTaskInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutDependsOnTaskInput, TaskDependencyUncheckedUpdateWithoutDependsOnTaskInput>
    create: XOR<TaskDependencyCreateWithoutDependsOnTaskInput, TaskDependencyUncheckedCreateWithoutDependsOnTaskInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutDependsOnTaskInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutDependsOnTaskInput, TaskDependencyUncheckedUpdateWithoutDependsOnTaskInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutDependsOnTaskInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskInput>
  }

  export type TaskDependencyScalarWhereInput = {
    AND?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    OR?: TaskDependencyScalarWhereInput[]
    NOT?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[]
    taskId?: IntFilter<"TaskDependency"> | number
    dependsOnTaskId?: IntFilter<"TaskDependency"> | number
    dependencyType?: StringFilter<"TaskDependency"> | string
    createdById?: IntFilter<"TaskDependency"> | number
    createdAt?: DateTimeFilter<"TaskDependency"> | Date | string
  }

  export type TaskDependencyUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    update: XOR<TaskDependencyUpdateWithoutTaskInput, TaskDependencyUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
  }

  export type TaskDependencyUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskDependencyWhereUniqueInput
    data: XOR<TaskDependencyUpdateWithoutTaskInput, TaskDependencyUncheckedUpdateWithoutTaskInput>
  }

  export type TaskDependencyUpdateManyWithWhereWithoutTaskInput = {
    where: TaskDependencyScalarWhereInput
    data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLabelCreateWithoutTaskInput, TaskLabelUncheckedCreateWithoutTaskInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutTaskInput, TaskLabelUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLabelScalarWhereInput = {
    AND?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    OR?: TaskLabelScalarWhereInput[]
    NOT?: TaskLabelScalarWhereInput | TaskLabelScalarWhereInput[]
    taskId?: IntFilter<"TaskLabel"> | number
    labelId?: IntFilter<"TaskLabel"> | number
    createdAt?: DateTimeFilter<"TaskLabel"> | Date | string
  }

  export type DeliverableUpsertWithoutTasksInput = {
    update: XOR<DeliverableUpdateWithoutTasksInput, DeliverableUncheckedUpdateWithoutTasksInput>
    create: XOR<DeliverableCreateWithoutTasksInput, DeliverableUncheckedCreateWithoutTasksInput>
    where?: DeliverableWhereInput
  }

  export type DeliverableUpdateToOneWithWhereWithoutTasksInput = {
    where?: DeliverableWhereInput
    data: XOR<DeliverableUpdateWithoutTasksInput, DeliverableUncheckedUpdateWithoutTasksInput>
  }

  export type DeliverableUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDeliverablesNestedInput
  }

  export type DeliverableUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksCreatedInput = {
    update: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
    create: XOR<UserCreateWithoutTasksCreatedInput, UserUncheckedCreateWithoutTasksCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksCreatedInput, UserUncheckedUpdateWithoutTasksCreatedInput>
  }

  export type UserUpdateWithoutTasksCreatedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutTasksInput = {
    update: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTasksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type TeamUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskStatusUpsertWithoutTasksInput = {
    update: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
    create: XOR<TaskStatusCreateWithoutTasksInput, TaskStatusUncheckedCreateWithoutTasksInput>
    where?: TaskStatusWhereInput
  }

  export type TaskStatusUpdateToOneWithWhereWithoutTasksInput = {
    where?: TaskStatusWhereInput
    data: XOR<TaskStatusUpdateWithoutTasksInput, TaskStatusUncheckedUpdateWithoutTasksInput>
  }

  export type TaskStatusUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskStatusUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    isBlocking?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TimeLogCreateWithoutTaskInput, TimeLogUncheckedCreateWithoutTaskInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutTaskInput, TimeLogUncheckedUpdateWithoutTaskInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutTaskInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedTasksInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedTasksInput>
  }

  export type CommentCreateWithoutSubtaskInput = {
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
    mentions?: CommentMentionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutSubtaskInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    userId: number
    mentions?: CommentMentionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutSubtaskInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput>
  }

  export type CommentCreateManySubtaskInputEnvelope = {
    data: CommentCreateManySubtaskInput | CommentCreateManySubtaskInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskDependencyCreateWithoutDependsOnSubtaskInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    subtask: SubtaskCreateNestedOneWithoutDependentsInput
  }

  export type SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput = {
    subtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type SubtaskDependencyCreateOrConnectWithoutDependsOnSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    create: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput>
  }

  export type SubtaskDependencyCreateManyDependsOnSubtaskInputEnvelope = {
    data: SubtaskDependencyCreateManyDependsOnSubtaskInput | SubtaskDependencyCreateManyDependsOnSubtaskInput[]
    skipDuplicates?: boolean
  }

  export type SubtaskDependencyCreateWithoutSubtaskInput = {
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
    dependsOnSubtask: SubtaskCreateNestedOneWithoutDependenciesInput
  }

  export type SubtaskDependencyUncheckedCreateWithoutSubtaskInput = {
    dependsOnSubtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type SubtaskDependencyCreateOrConnectWithoutSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    create: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput>
  }

  export type SubtaskDependencyCreateManySubtaskInputEnvelope = {
    data: SubtaskDependencyCreateManySubtaskInput | SubtaskDependencyCreateManySubtaskInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedSubtasksInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSubtasksInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSubtasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSubtasksInput, UserUncheckedCreateWithoutCreatedSubtasksInput>
  }

  export type TeamCreateWithoutSubtasksInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSubtasksInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSubtasksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSubtasksInput, TeamUncheckedCreateWithoutSubtasksInput>
  }

  export type UserCreateWithoutAssignedSubtasksInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedSubtasksInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedSubtasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedSubtasksInput, UserUncheckedCreateWithoutAssignedSubtasksInput>
  }

  export type TaskCreateWithoutSubtasksInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutSubtasksInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutSubtasksInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
  }

  export type TimeLogCreateWithoutSubtaskInput = {
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    task?: TaskCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutSubtaskInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    taskId?: number | null
  }

  export type TimeLogCreateOrConnectWithoutSubtaskInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput>
  }

  export type TimeLogCreateManySubtaskInputEnvelope = {
    data: TimeLogCreateManySubtaskInput | TimeLogCreateManySubtaskInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutSubtaskInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutSubtaskInput, CommentUncheckedUpdateWithoutSubtaskInput>
    create: XOR<CommentCreateWithoutSubtaskInput, CommentUncheckedCreateWithoutSubtaskInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutSubtaskInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutSubtaskInput, CommentUncheckedUpdateWithoutSubtaskInput>
  }

  export type CommentUpdateManyWithWhereWithoutSubtaskInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutSubtaskInput>
  }

  export type SubtaskDependencyUpsertWithWhereUniqueWithoutDependsOnSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    update: XOR<SubtaskDependencyUpdateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedUpdateWithoutDependsOnSubtaskInput>
    create: XOR<SubtaskDependencyCreateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedCreateWithoutDependsOnSubtaskInput>
  }

  export type SubtaskDependencyUpdateWithWhereUniqueWithoutDependsOnSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    data: XOR<SubtaskDependencyUpdateWithoutDependsOnSubtaskInput, SubtaskDependencyUncheckedUpdateWithoutDependsOnSubtaskInput>
  }

  export type SubtaskDependencyUpdateManyWithWhereWithoutDependsOnSubtaskInput = {
    where: SubtaskDependencyScalarWhereInput
    data: XOR<SubtaskDependencyUpdateManyMutationInput, SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskInput>
  }

  export type SubtaskDependencyScalarWhereInput = {
    AND?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
    OR?: SubtaskDependencyScalarWhereInput[]
    NOT?: SubtaskDependencyScalarWhereInput | SubtaskDependencyScalarWhereInput[]
    subtaskId?: IntFilter<"SubtaskDependency"> | number
    dependsOnSubtaskId?: IntFilter<"SubtaskDependency"> | number
    dependencyType?: StringFilter<"SubtaskDependency"> | string
    createdById?: IntFilter<"SubtaskDependency"> | number
    createdAt?: DateTimeFilter<"SubtaskDependency"> | Date | string
  }

  export type SubtaskDependencyUpsertWithWhereUniqueWithoutSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    update: XOR<SubtaskDependencyUpdateWithoutSubtaskInput, SubtaskDependencyUncheckedUpdateWithoutSubtaskInput>
    create: XOR<SubtaskDependencyCreateWithoutSubtaskInput, SubtaskDependencyUncheckedCreateWithoutSubtaskInput>
  }

  export type SubtaskDependencyUpdateWithWhereUniqueWithoutSubtaskInput = {
    where: SubtaskDependencyWhereUniqueInput
    data: XOR<SubtaskDependencyUpdateWithoutSubtaskInput, SubtaskDependencyUncheckedUpdateWithoutSubtaskInput>
  }

  export type SubtaskDependencyUpdateManyWithWhereWithoutSubtaskInput = {
    where: SubtaskDependencyScalarWhereInput
    data: XOR<SubtaskDependencyUpdateManyMutationInput, SubtaskDependencyUncheckedUpdateManyWithoutSubtaskInput>
  }

  export type UserUpsertWithoutCreatedSubtasksInput = {
    update: XOR<UserUpdateWithoutCreatedSubtasksInput, UserUncheckedUpdateWithoutCreatedSubtasksInput>
    create: XOR<UserCreateWithoutCreatedSubtasksInput, UserUncheckedCreateWithoutCreatedSubtasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSubtasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSubtasksInput, UserUncheckedUpdateWithoutCreatedSubtasksInput>
  }

  export type UserUpdateWithoutCreatedSubtasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutSubtasksInput = {
    update: XOR<TeamUpdateWithoutSubtasksInput, TeamUncheckedUpdateWithoutSubtasksInput>
    create: XOR<TeamCreateWithoutSubtasksInput, TeamUncheckedCreateWithoutSubtasksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSubtasksInput, TeamUncheckedUpdateWithoutSubtasksInput>
  }

  export type TeamUpdateWithoutSubtasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutAssignedSubtasksInput = {
    update: XOR<UserUpdateWithoutAssignedSubtasksInput, UserUncheckedUpdateWithoutAssignedSubtasksInput>
    create: XOR<UserCreateWithoutAssignedSubtasksInput, UserUncheckedCreateWithoutAssignedSubtasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedSubtasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedSubtasksInput, UserUncheckedUpdateWithoutAssignedSubtasksInput>
  }

  export type UserUpdateWithoutAssignedSubtasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithoutSubtasksInput = {
    update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
    create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>
  }

  export type TaskUpdateWithoutSubtasksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubtasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TimeLogUpsertWithWhereUniqueWithoutSubtaskInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutSubtaskInput, TimeLogUncheckedUpdateWithoutSubtaskInput>
    create: XOR<TimeLogCreateWithoutSubtaskInput, TimeLogUncheckedCreateWithoutSubtaskInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutSubtaskInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutSubtaskInput, TimeLogUncheckedUpdateWithoutSubtaskInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutSubtaskInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutSubtaskInput>
  }

  export type SubtaskCreateWithoutDependenciesInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutDependenciesInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutDependenciesInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutDependenciesInput, SubtaskUncheckedCreateWithoutDependenciesInput>
  }

  export type SubtaskCreateWithoutDependentsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutDependentsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutDependentsInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutDependentsInput, SubtaskUncheckedCreateWithoutDependentsInput>
  }

  export type SubtaskUpsertWithoutDependenciesInput = {
    update: XOR<SubtaskUpdateWithoutDependenciesInput, SubtaskUncheckedUpdateWithoutDependenciesInput>
    create: XOR<SubtaskCreateWithoutDependenciesInput, SubtaskUncheckedCreateWithoutDependenciesInput>
    where?: SubtaskWhereInput
  }

  export type SubtaskUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: SubtaskWhereInput
    data: XOR<SubtaskUpdateWithoutDependenciesInput, SubtaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type SubtaskUpdateWithoutDependenciesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutDependenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUpsertWithoutDependentsInput = {
    update: XOR<SubtaskUpdateWithoutDependentsInput, SubtaskUncheckedUpdateWithoutDependentsInput>
    create: XOR<SubtaskCreateWithoutDependentsInput, SubtaskUncheckedCreateWithoutDependentsInput>
    where?: SubtaskWhereInput
  }

  export type SubtaskUpdateToOneWithWhereWithoutDependentsInput = {
    where?: SubtaskWhereInput
    data: XOR<SubtaskUpdateWithoutDependentsInput, SubtaskUncheckedUpdateWithoutDependentsInput>
  }

  export type SubtaskUpdateWithoutDependentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutDependentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type SubtaskCreateWithoutCommentsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutCommentsInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutCommentsInput, SubtaskUncheckedCreateWithoutCommentsInput>
  }

  export type TaskCreateWithoutCommentsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type CommentMentionCreateWithoutCommentInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentMentionsInput
  }

  export type CommentMentionUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type CommentMentionCreateOrConnectWithoutCommentInput = {
    where: CommentMentionWhereUniqueInput
    create: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput>
  }

  export type CommentMentionCreateManyCommentInputEnvelope = {
    data: CommentMentionCreateManyCommentInput | CommentMentionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubtaskUpsertWithoutCommentsInput = {
    update: XOR<SubtaskUpdateWithoutCommentsInput, SubtaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<SubtaskCreateWithoutCommentsInput, SubtaskUncheckedCreateWithoutCommentsInput>
    where?: SubtaskWhereInput
  }

  export type SubtaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SubtaskWhereInput
    data: XOR<SubtaskUpdateWithoutCommentsInput, SubtaskUncheckedUpdateWithoutCommentsInput>
  }

  export type SubtaskUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type CommentMentionUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentMentionWhereUniqueInput
    update: XOR<CommentMentionUpdateWithoutCommentInput, CommentMentionUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentMentionCreateWithoutCommentInput, CommentMentionUncheckedCreateWithoutCommentInput>
  }

  export type CommentMentionUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentMentionWhereUniqueInput
    data: XOR<CommentMentionUpdateWithoutCommentInput, CommentMentionUncheckedUpdateWithoutCommentInput>
  }

  export type CommentMentionUpdateManyWithWhereWithoutCommentInput = {
    where: CommentMentionScalarWhereInput
    data: XOR<CommentMentionUpdateManyMutationInput, CommentMentionUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentCreateWithoutMentionsInput = {
    content: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    subtask?: SubtaskCreateNestedOneWithoutCommentsInput
    task?: TaskCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutMentionsInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
    userId: number
  }

  export type CommentCreateOrConnectWithoutMentionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutMentionsInput, CommentUncheckedCreateWithoutMentionsInput>
  }

  export type UserCreateWithoutCommentMentionsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentMentionsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentMentionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentMentionsInput, UserUncheckedCreateWithoutCommentMentionsInput>
  }

  export type CommentUpsertWithoutMentionsInput = {
    update: XOR<CommentUpdateWithoutMentionsInput, CommentUncheckedUpdateWithoutMentionsInput>
    create: XOR<CommentCreateWithoutMentionsInput, CommentUncheckedCreateWithoutMentionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutMentionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutMentionsInput, CommentUncheckedUpdateWithoutMentionsInput>
  }

  export type CommentUpdateWithoutMentionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    subtask?: SubtaskUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutMentionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutCommentMentionsInput = {
    update: XOR<UserUpdateWithoutCommentMentionsInput, UserUncheckedUpdateWithoutCommentMentionsInput>
    create: XOR<UserCreateWithoutCommentMentionsInput, UserUncheckedCreateWithoutCommentMentionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentMentionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentMentionsInput, UserUncheckedUpdateWithoutCommentMentionsInput>
  }

  export type UserUpdateWithoutCommentMentionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentMentionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskLabelCreateWithoutLabelInput = {
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutLabelsInput
  }

  export type TaskLabelUncheckedCreateWithoutLabelInput = {
    taskId: number
    createdAt?: Date | string
  }

  export type TaskLabelCreateOrConnectWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelCreateManyLabelInputEnvelope = {
    data: TaskLabelCreateManyLabelInput | TaskLabelCreateManyLabelInput[]
    skipDuplicates?: boolean
  }

  export type TaskLabelUpsertWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    update: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
    create: XOR<TaskLabelCreateWithoutLabelInput, TaskLabelUncheckedCreateWithoutLabelInput>
  }

  export type TaskLabelUpdateWithWhereUniqueWithoutLabelInput = {
    where: TaskLabelWhereUniqueInput
    data: XOR<TaskLabelUpdateWithoutLabelInput, TaskLabelUncheckedUpdateWithoutLabelInput>
  }

  export type TaskLabelUpdateManyWithWhereWithoutLabelInput = {
    where: TaskLabelScalarWhereInput
    data: XOR<TaskLabelUpdateManyMutationInput, TaskLabelUncheckedUpdateManyWithoutLabelInput>
  }

  export type LabelCreateWithoutTasksInput = {
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LabelUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    color: string
    description?: string | null
    createdAt?: Date | string
  }

  export type LabelCreateOrConnectWithoutTasksInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutLabelsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutLabelsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutLabelsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
  }

  export type LabelUpsertWithoutTasksInput = {
    update: XOR<LabelUpdateWithoutTasksInput, LabelUncheckedUpdateWithoutTasksInput>
    create: XOR<LabelCreateWithoutTasksInput, LabelUncheckedCreateWithoutTasksInput>
    where?: LabelWhereInput
  }

  export type LabelUpdateToOneWithWhereWithoutTasksInput = {
    where?: LabelWhereInput
    data: XOR<LabelUpdateWithoutTasksInput, LabelUncheckedUpdateWithoutTasksInput>
  }

  export type LabelUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpsertWithoutLabelsInput = {
    update: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
    create: XOR<TaskCreateWithoutLabelsInput, TaskUncheckedCreateWithoutLabelsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutLabelsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutLabelsInput, TaskUncheckedUpdateWithoutLabelsInput>
  }

  export type TaskUpdateWithoutLabelsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutLabelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskCreateWithoutDependentsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutDependentsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutDependentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
  }

  export type TaskCreateWithoutDependenciesInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutDependenciesInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutDependenciesInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
  }

  export type TaskUpsertWithoutDependentsInput = {
    update: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
    create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>
  }

  export type TaskUpdateWithoutDependentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUpsertWithoutDependenciesInput = {
    update: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
    create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutDependenciesInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>
  }

  export type TaskUpdateWithoutDependenciesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutDependenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type SubtaskCreateWithoutTimeLogsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyCreateNestedManyWithoutSubtaskInput
    creator: UserCreateNestedOneWithoutCreatedSubtasksInput
    team?: TeamCreateNestedOneWithoutSubtasksInput
    assignedTo?: UserCreateNestedOneWithoutAssignedSubtasksInput
    parentTask: TaskCreateNestedOneWithoutSubtasksInput
  }

  export type SubtaskUncheckedCreateWithoutTimeLogsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSubtaskInput
    dependencies?: SubtaskDependencyUncheckedCreateNestedManyWithoutDependsOnSubtaskInput
    dependents?: SubtaskDependencyUncheckedCreateNestedManyWithoutSubtaskInput
  }

  export type SubtaskCreateOrConnectWithoutTimeLogsInput = {
    where: SubtaskWhereUniqueInput
    create: XOR<SubtaskCreateWithoutTimeLogsInput, SubtaskUncheckedCreateWithoutTimeLogsInput>
  }

  export type TaskCreateWithoutTimeLogsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutTimeLogsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutTimeLogsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
  }

  export type UserCreateWithoutTimeLogsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimeLogsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
  }

  export type SubtaskUpsertWithoutTimeLogsInput = {
    update: XOR<SubtaskUpdateWithoutTimeLogsInput, SubtaskUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<SubtaskCreateWithoutTimeLogsInput, SubtaskUncheckedCreateWithoutTimeLogsInput>
    where?: SubtaskWhereInput
  }

  export type SubtaskUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: SubtaskWhereInput
    data: XOR<SubtaskUpdateWithoutTimeLogsInput, SubtaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type SubtaskUpdateWithoutTimeLogsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutTimeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type TaskUpsertWithoutTimeLogsInput = {
    update: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<TaskCreateWithoutTimeLogsInput, TaskUncheckedCreateWithoutTimeLogsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTimeLogsInput, TaskUncheckedUpdateWithoutTimeLogsInput>
  }

  export type TaskUpdateWithoutTimeLogsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTimeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type UserUpsertWithoutTimeLogsInput = {
    update: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateWithoutTimeLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutRulesInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRulesInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRulesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRulesInput, TeamUncheckedCreateWithoutRulesInput>
  }

  export type UserCreateWithoutCreatedRulesInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRulesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
  }

  export type TeamUpsertWithoutRulesInput = {
    update: XOR<TeamUpdateWithoutRulesInput, TeamUncheckedUpdateWithoutRulesInput>
    create: XOR<TeamCreateWithoutRulesInput, TeamUncheckedCreateWithoutRulesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRulesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRulesInput, TeamUncheckedUpdateWithoutRulesInput>
  }

  export type TeamUpdateWithoutRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutCreatedRulesInput = {
    update: XOR<UserUpdateWithoutCreatedRulesInput, UserUncheckedUpdateWithoutCreatedRulesInput>
    create: XOR<UserCreateWithoutCreatedRulesInput, UserUncheckedCreateWithoutCreatedRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRulesInput, UserUncheckedUpdateWithoutCreatedRulesInput>
  }

  export type UserUpdateWithoutCreatedRulesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityLogsPerformedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsPerformedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsPerformedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsPerformedInput, UserUncheckedCreateWithoutActivityLogsPerformedInput>
  }

  export type UserCreateWithoutActivityLogsAffectedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsAffectedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsAffectedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsAffectedInput, UserUncheckedCreateWithoutActivityLogsAffectedInput>
  }

  export type ProjectCreateWithoutActivityLogsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutActivityLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutActivityLogsInput, ProjectUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserCreateWithoutActivityLogsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsPerformedInput = {
    update: XOR<UserUpdateWithoutActivityLogsPerformedInput, UserUncheckedUpdateWithoutActivityLogsPerformedInput>
    create: XOR<UserCreateWithoutActivityLogsPerformedInput, UserUncheckedCreateWithoutActivityLogsPerformedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsPerformedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsPerformedInput, UserUncheckedUpdateWithoutActivityLogsPerformedInput>
  }

  export type UserUpdateWithoutActivityLogsPerformedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsPerformedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutActivityLogsAffectedInput = {
    update: XOR<UserUpdateWithoutActivityLogsAffectedInput, UserUncheckedUpdateWithoutActivityLogsAffectedInput>
    create: XOR<UserCreateWithoutActivityLogsAffectedInput, UserUncheckedCreateWithoutActivityLogsAffectedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsAffectedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsAffectedInput, UserUncheckedUpdateWithoutActivityLogsAffectedInput>
  }

  export type UserUpdateWithoutActivityLogsAffectedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsAffectedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutActivityLogsInput = {
    update: XOR<ProjectUpdateWithoutActivityLogsInput, ProjectUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<ProjectCreateWithoutActivityLogsInput, ProjectUncheckedCreateWithoutActivityLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutActivityLogsInput, ProjectUncheckedUpdateWithoutActivityLogsInput>
  }

  export type ProjectUpdateWithoutActivityLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutProjectUsersInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectUsersInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectUsersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
  }

  export type ProjectUpsertWithoutProjectUsersInput = {
    update: XOR<ProjectUpdateWithoutProjectUsersInput, ProjectUncheckedUpdateWithoutProjectUsersInput>
    create: XOR<ProjectCreateWithoutProjectUsersInput, ProjectUncheckedCreateWithoutProjectUsersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectUsersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectUsersInput, ProjectUncheckedUpdateWithoutProjectUsersInput>
  }

  export type ProjectUpdateWithoutProjectUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPhasesInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPhasesInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPhasesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
  }

  export type ProjectUpsertWithoutPhasesInput = {
    update: XOR<ProjectUpdateWithoutPhasesInput, ProjectUncheckedUpdateWithoutPhasesInput>
    create: XOR<ProjectCreateWithoutPhasesInput, ProjectUncheckedCreateWithoutPhasesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPhasesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPhasesInput, ProjectUncheckedUpdateWithoutPhasesInput>
  }

  export type ProjectUpdateWithoutPhasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPhasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutDeliverablesInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDeliverablesInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDeliverablesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDeliverablesInput, ProjectUncheckedCreateWithoutDeliverablesInput>
  }

  export type TaskCreateWithoutDeliverableInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutDeliverableInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutDeliverableInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput>
  }

  export type TaskCreateManyDeliverableInputEnvelope = {
    data: TaskCreateManyDeliverableInput | TaskCreateManyDeliverableInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDeliverablesInput = {
    update: XOR<ProjectUpdateWithoutDeliverablesInput, ProjectUncheckedUpdateWithoutDeliverablesInput>
    create: XOR<ProjectCreateWithoutDeliverablesInput, ProjectUncheckedCreateWithoutDeliverablesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDeliverablesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDeliverablesInput, ProjectUncheckedUpdateWithoutDeliverablesInput>
  }

  export type ProjectUpdateWithoutDeliverablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDeliverablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutDeliverableInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutDeliverableInput, TaskUncheckedUpdateWithoutDeliverableInput>
    create: XOR<TaskCreateWithoutDeliverableInput, TaskUncheckedCreateWithoutDeliverableInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutDeliverableInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutDeliverableInput, TaskUncheckedUpdateWithoutDeliverableInput>
  }

  export type TaskUpdateManyWithWhereWithoutDeliverableInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutDeliverableInput>
  }

  export type ProjectCreateWithoutScopeHistoryInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutScopeHistoryInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutScopeHistoryInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutScopeHistoryInput, ProjectUncheckedCreateWithoutScopeHistoryInput>
  }

  export type ProjectUpsertWithoutScopeHistoryInput = {
    update: XOR<ProjectUpdateWithoutScopeHistoryInput, ProjectUncheckedUpdateWithoutScopeHistoryInput>
    create: XOR<ProjectCreateWithoutScopeHistoryInput, ProjectUncheckedCreateWithoutScopeHistoryInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutScopeHistoryInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutScopeHistoryInput, ProjectUncheckedUpdateWithoutScopeHistoryInput>
  }

  export type ProjectUpdateWithoutScopeHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutScopeHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutUploadedFilesInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedFilesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
  }

  export type TaskCreateWithoutAttachmentsInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    taskStatus?: TaskStatusCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutAttachmentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserUpsertWithoutUploadedFilesInput = {
    update: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>
  }

  export type UserUpdateWithoutUploadedFilesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskUpsertWithoutAttachmentsInput = {
    update: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TaskCreateWithoutAttachmentsInput, TaskUncheckedCreateWithoutAttachmentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAttachmentsInput, TaskUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TaskUpdateWithoutAttachmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type SettingsChangeLogCreateWithoutSettingInput = {
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsChangedInput
  }

  export type SettingsChangeLogUncheckedCreateWithoutSettingInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    userId: number
    createdAt?: Date | string
  }

  export type SettingsChangeLogCreateOrConnectWithoutSettingInput = {
    where: SettingsChangeLogWhereUniqueInput
    create: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type SettingsChangeLogCreateManySettingInputEnvelope = {
    data: SettingsChangeLogCreateManySettingInput | SettingsChangeLogCreateManySettingInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutUpdatedSettingsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedSettingsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
  }

  export type SettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput = {
    where: SettingsChangeLogWhereUniqueInput
    update: XOR<SettingsChangeLogUpdateWithoutSettingInput, SettingsChangeLogUncheckedUpdateWithoutSettingInput>
    create: XOR<SettingsChangeLogCreateWithoutSettingInput, SettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type SettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput = {
    where: SettingsChangeLogWhereUniqueInput
    data: XOR<SettingsChangeLogUpdateWithoutSettingInput, SettingsChangeLogUncheckedUpdateWithoutSettingInput>
  }

  export type SettingsChangeLogUpdateManyWithWhereWithoutSettingInput = {
    where: SettingsChangeLogScalarWhereInput
    data: XOR<SettingsChangeLogUpdateManyMutationInput, SettingsChangeLogUncheckedUpdateManyWithoutSettingInput>
  }

  export type UserUpsertWithoutUpdatedSettingsInput = {
    update: XOR<UserUpdateWithoutUpdatedSettingsInput, UserUncheckedUpdateWithoutUpdatedSettingsInput>
    create: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedSettingsInput, UserUncheckedUpdateWithoutUpdatedSettingsInput>
  }

  export type UserUpdateWithoutUpdatedSettingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SystemSettingCreateWithoutChangeLogsInput = {
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutUpdatedSettingsInput
  }

  export type SystemSettingUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
    updatedBy: number
  }

  export type SystemSettingCreateOrConnectWithoutChangeLogsInput = {
    where: SystemSettingWhereUniqueInput
    create: XOR<SystemSettingCreateWithoutChangeLogsInput, SystemSettingUncheckedCreateWithoutChangeLogsInput>
  }

  export type UserCreateWithoutSettingsChangedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsChangedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsChangedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsChangedInput, UserUncheckedCreateWithoutSettingsChangedInput>
  }

  export type SystemSettingUpsertWithoutChangeLogsInput = {
    update: XOR<SystemSettingUpdateWithoutChangeLogsInput, SystemSettingUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<SystemSettingCreateWithoutChangeLogsInput, SystemSettingUncheckedCreateWithoutChangeLogsInput>
    where?: SystemSettingWhereInput
  }

  export type SystemSettingUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: SystemSettingWhereInput
    data: XOR<SystemSettingUpdateWithoutChangeLogsInput, SystemSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type SystemSettingUpdateWithoutChangeLogsInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutUpdatedSettingsNestedInput
  }

  export type SystemSettingUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutSettingsChangedInput = {
    update: XOR<UserUpdateWithoutSettingsChangedInput, UserUncheckedUpdateWithoutSettingsChangedInput>
    create: XOR<UserCreateWithoutSettingsChangedInput, UserUncheckedCreateWithoutSettingsChangedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsChangedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsChangedInput, UserUncheckedUpdateWithoutSettingsChangedInput>
  }

  export type UserUpdateWithoutSettingsChangedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsChangedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProjectSettingsUpdatedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectSettingsUpdatedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectSettingsUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectSettingsUpdatedInput, UserUncheckedCreateWithoutProjectSettingsUpdatedInput>
  }

  export type ProjectCreateWithoutSettingsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSettingsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSettingsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSettingsInput, ProjectUncheckedCreateWithoutSettingsInput>
  }

  export type ProjectSettingsChangeLogCreateWithoutSettingInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    changer: UserCreateNestedOneWithoutProjectSettingsChangedInput
    project: ProjectCreateNestedOneWithoutSettingsLogsInput
  }

  export type ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogCreateOrConnectWithoutSettingInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    create: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type ProjectSettingsChangeLogCreateManySettingInputEnvelope = {
    data: ProjectSettingsChangeLogCreateManySettingInput | ProjectSettingsChangeLogCreateManySettingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectSettingsUpdatedInput = {
    update: XOR<UserUpdateWithoutProjectSettingsUpdatedInput, UserUncheckedUpdateWithoutProjectSettingsUpdatedInput>
    create: XOR<UserCreateWithoutProjectSettingsUpdatedInput, UserUncheckedCreateWithoutProjectSettingsUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectSettingsUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectSettingsUpdatedInput, UserUncheckedUpdateWithoutProjectSettingsUpdatedInput>
  }

  export type UserUpdateWithoutProjectSettingsUpdatedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectSettingsUpdatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutSettingsInput = {
    update: XOR<ProjectUpdateWithoutSettingsInput, ProjectUncheckedUpdateWithoutSettingsInput>
    create: XOR<ProjectCreateWithoutSettingsInput, ProjectUncheckedCreateWithoutSettingsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSettingsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSettingsInput, ProjectUncheckedUpdateWithoutSettingsInput>
  }

  export type ProjectUpdateWithoutSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    update: XOR<ProjectSettingsChangeLogUpdateWithoutSettingInput, ProjectSettingsChangeLogUncheckedUpdateWithoutSettingInput>
    create: XOR<ProjectSettingsChangeLogCreateWithoutSettingInput, ProjectSettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type ProjectSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput = {
    where: ProjectSettingsChangeLogWhereUniqueInput
    data: XOR<ProjectSettingsChangeLogUpdateWithoutSettingInput, ProjectSettingsChangeLogUncheckedUpdateWithoutSettingInput>
  }

  export type ProjectSettingsChangeLogUpdateManyWithWhereWithoutSettingInput = {
    where: ProjectSettingsChangeLogScalarWhereInput
    data: XOR<ProjectSettingsChangeLogUpdateManyMutationInput, ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingInput>
  }

  export type ProjectSettingCreateWithoutChangeLogsInput = {
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutProjectSettingsUpdatedInput
    project: ProjectCreateNestedOneWithoutSettingsInput
  }

  export type ProjectSettingUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    projectId: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ProjectSettingCreateOrConnectWithoutChangeLogsInput = {
    where: ProjectSettingWhereUniqueInput
    create: XOR<ProjectSettingCreateWithoutChangeLogsInput, ProjectSettingUncheckedCreateWithoutChangeLogsInput>
  }

  export type UserCreateWithoutProjectSettingsChangedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectSettingsChangedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectSettingsChangedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectSettingsChangedInput, UserUncheckedCreateWithoutProjectSettingsChangedInput>
  }

  export type ProjectCreateWithoutSettingsLogsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSettingsLogsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSettingsLogsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSettingsLogsInput, ProjectUncheckedCreateWithoutSettingsLogsInput>
  }

  export type ProjectSettingUpsertWithoutChangeLogsInput = {
    update: XOR<ProjectSettingUpdateWithoutChangeLogsInput, ProjectSettingUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<ProjectSettingCreateWithoutChangeLogsInput, ProjectSettingUncheckedCreateWithoutChangeLogsInput>
    where?: ProjectSettingWhereInput
  }

  export type ProjectSettingUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: ProjectSettingWhereInput
    data: XOR<ProjectSettingUpdateWithoutChangeLogsInput, ProjectSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ProjectSettingUpdateWithoutChangeLogsInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutProjectSettingsUpdatedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type ProjectSettingUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutProjectSettingsChangedInput = {
    update: XOR<UserUpdateWithoutProjectSettingsChangedInput, UserUncheckedUpdateWithoutProjectSettingsChangedInput>
    create: XOR<UserCreateWithoutProjectSettingsChangedInput, UserUncheckedCreateWithoutProjectSettingsChangedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectSettingsChangedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectSettingsChangedInput, UserUncheckedUpdateWithoutProjectSettingsChangedInput>
  }

  export type UserUpdateWithoutProjectSettingsChangedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectSettingsChangedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutSettingsLogsInput = {
    update: XOR<ProjectUpdateWithoutSettingsLogsInput, ProjectUncheckedUpdateWithoutSettingsLogsInput>
    create: XOR<ProjectCreateWithoutSettingsLogsInput, ProjectUncheckedCreateWithoutSettingsLogsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSettingsLogsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSettingsLogsInput, ProjectUncheckedUpdateWithoutSettingsLogsInput>
  }

  export type ProjectUpdateWithoutSettingsLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSettingsLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutUserSettingsUpdatedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsUpdatedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsUpdatedInput, UserUncheckedCreateWithoutUserSettingsUpdatedInput>
  }

  export type UserCreateWithoutUserSettingsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserSettingsChangeLogCreateWithoutSettingInput = {
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    createdAt?: Date | string
    changer: UserCreateNestedOneWithoutUserSettingsChangedInput
    user: UserCreateNestedOneWithoutUserSettingsChangeLogsInput
  }

  export type UserSettingsChangeLogUncheckedCreateWithoutSettingInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogCreateOrConnectWithoutSettingInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    create: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type UserSettingsChangeLogCreateManySettingInputEnvelope = {
    data: UserSettingsChangeLogCreateManySettingInput | UserSettingsChangeLogCreateManySettingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserSettingsUpdatedInput = {
    update: XOR<UserUpdateWithoutUserSettingsUpdatedInput, UserUncheckedUpdateWithoutUserSettingsUpdatedInput>
    create: XOR<UserCreateWithoutUserSettingsUpdatedInput, UserUncheckedCreateWithoutUserSettingsUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsUpdatedInput, UserUncheckedUpdateWithoutUserSettingsUpdatedInput>
  }

  export type UserUpdateWithoutUserSettingsUpdatedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsUpdatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSettingsChangeLogUpsertWithWhereUniqueWithoutSettingInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    update: XOR<UserSettingsChangeLogUpdateWithoutSettingInput, UserSettingsChangeLogUncheckedUpdateWithoutSettingInput>
    create: XOR<UserSettingsChangeLogCreateWithoutSettingInput, UserSettingsChangeLogUncheckedCreateWithoutSettingInput>
  }

  export type UserSettingsChangeLogUpdateWithWhereUniqueWithoutSettingInput = {
    where: UserSettingsChangeLogWhereUniqueInput
    data: XOR<UserSettingsChangeLogUpdateWithoutSettingInput, UserSettingsChangeLogUncheckedUpdateWithoutSettingInput>
  }

  export type UserSettingsChangeLogUpdateManyWithWhereWithoutSettingInput = {
    where: UserSettingsChangeLogScalarWhereInput
    data: XOR<UserSettingsChangeLogUpdateManyMutationInput, UserSettingsChangeLogUncheckedUpdateManyWithoutSettingInput>
  }

  export type UserSettingCreateWithoutChangeLogsInput = {
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updater: UserCreateNestedOneWithoutUserSettingsUpdatedInput
    user: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserSettingCreateOrConnectWithoutChangeLogsInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutChangeLogsInput, UserSettingUncheckedCreateWithoutChangeLogsInput>
  }

  export type UserCreateWithoutUserSettingsChangedInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsChangedInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsChangedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsChangedInput, UserUncheckedCreateWithoutUserSettingsChangedInput>
  }

  export type UserCreateWithoutUserSettingsChangeLogsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsChangeLogsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsChangeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsChangeLogsInput, UserUncheckedCreateWithoutUserSettingsChangeLogsInput>
  }

  export type UserSettingUpsertWithoutChangeLogsInput = {
    update: XOR<UserSettingUpdateWithoutChangeLogsInput, UserSettingUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<UserSettingCreateWithoutChangeLogsInput, UserSettingUncheckedCreateWithoutChangeLogsInput>
    where?: UserSettingWhereInput
  }

  export type UserSettingUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: UserSettingWhereInput
    data: XOR<UserSettingUpdateWithoutChangeLogsInput, UserSettingUncheckedUpdateWithoutChangeLogsInput>
  }

  export type UserSettingUpdateWithoutChangeLogsInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutUserSettingsUpdatedNestedInput
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutUserSettingsChangedInput = {
    update: XOR<UserUpdateWithoutUserSettingsChangedInput, UserUncheckedUpdateWithoutUserSettingsChangedInput>
    create: XOR<UserCreateWithoutUserSettingsChangedInput, UserUncheckedCreateWithoutUserSettingsChangedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsChangedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsChangedInput, UserUncheckedUpdateWithoutUserSettingsChangedInput>
  }

  export type UserUpdateWithoutUserSettingsChangedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsChangedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUserSettingsChangeLogsInput = {
    update: XOR<UserUpdateWithoutUserSettingsChangeLogsInput, UserUncheckedUpdateWithoutUserSettingsChangeLogsInput>
    create: XOR<UserCreateWithoutUserSettingsChangeLogsInput, UserUncheckedCreateWithoutUserSettingsChangeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsChangeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsChangeLogsInput, UserUncheckedUpdateWithoutUserSettingsChangeLogsInput>
  }

  export type UserUpdateWithoutUserSettingsChangeLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProjectNotificationsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectNotificationsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectNotificationsInput, UserUncheckedCreateWithoutProjectNotificationsInput>
  }

  export type ProjectCreateWithoutNotificationsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNotificationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNotificationsInput, ProjectUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutProjectNotificationsInput = {
    update: XOR<UserUpdateWithoutProjectNotificationsInput, UserUncheckedUpdateWithoutProjectNotificationsInput>
    create: XOR<UserCreateWithoutProjectNotificationsInput, UserUncheckedCreateWithoutProjectNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectNotificationsInput, UserUncheckedUpdateWithoutProjectNotificationsInput>
  }

  export type UserUpdateWithoutProjectNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutNotificationsInput = {
    update: XOR<ProjectUpdateWithoutNotificationsInput, ProjectUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProjectCreateWithoutNotificationsInput, ProjectUncheckedCreateWithoutNotificationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutNotificationsInput, ProjectUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProjectUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutUrgentAcknowledgmentsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUrgentAcknowledgmentsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUrgentAcknowledgmentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedCreateWithoutUrgentAcknowledgmentsInput>
  }

  export type UserCreateWithoutUrgentAcknowledgementsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
  }

  export type UserUncheckedCreateWithoutUrgentAcknowledgementsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
  }

  export type UserCreateOrConnectWithoutUrgentAcknowledgementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUrgentAcknowledgementsInput, UserUncheckedCreateWithoutUrgentAcknowledgementsInput>
  }

  export type ProjectUpsertWithoutUrgentAcknowledgmentsInput = {
    update: XOR<ProjectUpdateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedUpdateWithoutUrgentAcknowledgmentsInput>
    create: XOR<ProjectCreateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedCreateWithoutUrgentAcknowledgmentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUrgentAcknowledgmentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUrgentAcknowledgmentsInput, ProjectUncheckedUpdateWithoutUrgentAcknowledgmentsInput>
  }

  export type ProjectUpdateWithoutUrgentAcknowledgmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUrgentAcknowledgmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutUrgentAcknowledgementsInput = {
    update: XOR<UserUpdateWithoutUrgentAcknowledgementsInput, UserUncheckedUpdateWithoutUrgentAcknowledgementsInput>
    create: XOR<UserCreateWithoutUrgentAcknowledgementsInput, UserUncheckedCreateWithoutUrgentAcknowledgementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUrgentAcknowledgementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUrgentAcknowledgementsInput, UserUncheckedUpdateWithoutUrgentAcknowledgementsInput>
  }

  export type UserUpdateWithoutUrgentAcknowledgementsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
  }

  export type UserUncheckedUpdateWithoutUrgentAcknowledgementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
  }

  export type UserCreateWithoutProjectNotificationPreferencesInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectNotificationPreferencesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectNotificationPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectNotificationPreferencesInput, UserUncheckedCreateWithoutProjectNotificationPreferencesInput>
  }

  export type ProjectCreateWithoutNotificationPreferencesInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNotificationPreferencesInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNotificationPreferencesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNotificationPreferencesInput, ProjectUncheckedCreateWithoutNotificationPreferencesInput>
  }

  export type UserUpsertWithoutProjectNotificationPreferencesInput = {
    update: XOR<UserUpdateWithoutProjectNotificationPreferencesInput, UserUncheckedUpdateWithoutProjectNotificationPreferencesInput>
    create: XOR<UserCreateWithoutProjectNotificationPreferencesInput, UserUncheckedCreateWithoutProjectNotificationPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectNotificationPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectNotificationPreferencesInput, UserUncheckedUpdateWithoutProjectNotificationPreferencesInput>
  }

  export type UserUpdateWithoutProjectNotificationPreferencesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectNotificationPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutNotificationPreferencesInput = {
    update: XOR<ProjectUpdateWithoutNotificationPreferencesInput, ProjectUncheckedUpdateWithoutNotificationPreferencesInput>
    create: XOR<ProjectCreateWithoutNotificationPreferencesInput, ProjectUncheckedCreateWithoutNotificationPreferencesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutNotificationPreferencesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutNotificationPreferencesInput, ProjectUncheckedUpdateWithoutNotificationPreferencesInput>
  }

  export type ProjectUpdateWithoutNotificationPreferencesInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNotificationPreferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TeamCreateWithoutMembersInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutProjectTeamsInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectTeamsInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectTeamsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectTeamsInput, ProjectUncheckedCreateWithoutProjectTeamsInput>
  }

  export type TeamCreateWithoutProjectTeamsInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskCreateNestedManyWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamInput
    teamLead?: UserCreateNestedOneWithoutTeamsLedInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutProjectTeamsInput = {
    id?: number
    name: string
    description?: string | null
    teamLeadId?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: AutomationRuleUncheckedCreateNestedManyWithoutTeamInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutTeamInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutProjectTeamsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutProjectTeamsInput, TeamUncheckedCreateWithoutProjectTeamsInput>
  }

  export type ProjectUpsertWithoutProjectTeamsInput = {
    update: XOR<ProjectUpdateWithoutProjectTeamsInput, ProjectUncheckedUpdateWithoutProjectTeamsInput>
    create: XOR<ProjectCreateWithoutProjectTeamsInput, ProjectUncheckedCreateWithoutProjectTeamsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectTeamsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectTeamsInput, ProjectUncheckedUpdateWithoutProjectTeamsInput>
  }

  export type ProjectUpdateWithoutProjectTeamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TeamUpsertWithoutProjectTeamsInput = {
    update: XOR<TeamUpdateWithoutProjectTeamsInput, TeamUncheckedUpdateWithoutProjectTeamsInput>
    create: XOR<TeamCreateWithoutProjectTeamsInput, TeamUncheckedCreateWithoutProjectTeamsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutProjectTeamsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutProjectTeamsInput, TeamUncheckedUpdateWithoutProjectTeamsInput>
  }

  export type TeamUpdateWithoutProjectTeamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    teamLead?: UserUpdateOneWithoutTeamsLedNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutProjectTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teamLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type RolePermissionCreateWithoutRoleInput = {
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutRolesInput
    assigner?: UserCreateNestedOneWithoutAssignedRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    key: string
    name: string
    description?: string | null
    module: string
    category?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: number
    key: string
    name: string
    description?: string | null
    module: string
    category?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRolesInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignerInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: number
    name: string
    description?: string | null
    isSystemRole?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserCreateWithoutAssignedRolesInput = {
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogCreateNestedManyWithoutUserInput
    team?: TeamCreateNestedOneWithoutUsersInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedRolesInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
    avatarUrl?: string | null
    activityLogsPerformed?: ActivityLogUncheckedCreateNestedManyWithoutPerformedByInput
    activityLogsAffected?: ActivityLogUncheckedCreateNestedManyWithoutAffectedUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    uploadedFiles?: AttachmentUncheckedCreateNestedManyWithoutUploaderInput
    createdRules?: AutomationRuleUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentMentions?: CommentMentionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    projectNotifications?: ProjectNotificationUncheckedCreateNestedManyWithoutUserInput
    projectSettingsUpdated?: ProjectSettingUncheckedCreateNestedManyWithoutUpdaterInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    projectsManaged?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    projectsMarkedUrgent?: ProjectUncheckedCreateNestedManyWithoutUrgentMarkedByInput
    settingsChanged?: SettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    createdSubtasks?: SubtaskUncheckedCreateNestedManyWithoutCreatorInput
    assignedSubtasks?: SubtaskUncheckedCreateNestedManyWithoutAssignedToInput
    updatedSettings?: SystemSettingUncheckedCreateNestedManyWithoutUpdaterInput
    tasksCreated?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    userSettingsUpdated?: UserSettingUncheckedCreateNestedManyWithoutUpdaterInput
    userSettings?: UserSettingUncheckedCreateNestedManyWithoutUserInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutChangerInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedCreateNestedManyWithoutUserInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneesInput
    teamsLed?: TeamUncheckedCreateNestedManyWithoutTeamLeadInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystemRole?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutAssignedRolesInput = {
    update: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type UserUpdateWithoutAssignedRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutProjectTypeInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectStatus?: ProjectStatusCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectTypeInput = {
    id?: number
    name: string
    type: string
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput>
  }

  export type ProjectCreateManyProjectTypeInputEnvelope = {
    data: ProjectCreateManyProjectTypeInput | ProjectCreateManyProjectTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectTypeInput, ProjectUncheckedUpdateWithoutProjectTypeInput>
    create: XOR<ProjectCreateWithoutProjectTypeInput, ProjectUncheckedCreateWithoutProjectTypeInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectTypeInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectTypeInput, ProjectUncheckedUpdateWithoutProjectTypeInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectTypeInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectTypeInput>
  }

  export type ProjectCreateWithoutProjectStatusInput = {
    name: string
    type: string
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserCreateNestedManyWithoutProjectInput
    projectManager?: UserCreateNestedOneWithoutProjectsManagedInput
    urgentMarkedBy?: UserCreateNestedOneWithoutProjectsMarkedUrgentInput
    projectType?: ProjectTypeCreateNestedOneWithoutProjectsInput
    scopeHistory?: ScopeHistoryCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectStatusInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deliverables?: DeliverableUncheckedCreateNestedManyWithoutProjectInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedCreateNestedManyWithoutProjectInput
    notifications?: ProjectNotificationUncheckedCreateNestedManyWithoutProjectInput
    phases?: ProjectPhaseUncheckedCreateNestedManyWithoutProjectInput
    settings?: ProjectSettingUncheckedCreateNestedManyWithoutProjectInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedCreateNestedManyWithoutProjectInput
    projectUsers?: ProjectUserUncheckedCreateNestedManyWithoutProjectInput
    scopeHistory?: ScopeHistoryUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutProjectInput
    projectTeams?: ProjectTeamUncheckedCreateNestedManyWithoutProjectInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectStatusInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput>
  }

  export type ProjectCreateManyProjectStatusInputEnvelope = {
    data: ProjectCreateManyProjectStatusInput | ProjectCreateManyProjectStatusInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectStatusInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectStatusInput, ProjectUncheckedUpdateWithoutProjectStatusInput>
    create: XOR<ProjectCreateWithoutProjectStatusInput, ProjectUncheckedCreateWithoutProjectStatusInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectStatusInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectStatusInput, ProjectUncheckedUpdateWithoutProjectStatusInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectStatusInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectStatusInput>
  }

  export type TaskCreateWithoutTaskStatusInput = {
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentCreateNestedManyWithoutTaskInput
    comments?: CommentCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput
    labels?: TaskLabelCreateNestedManyWithoutTaskInput
    deliverable?: DeliverableCreateNestedOneWithoutTasksInput
    creator?: UserCreateNestedOneWithoutTasksCreatedInput
    team?: TeamCreateNestedOneWithoutTasksInput
    project: ProjectCreateNestedOneWithoutTasksInput
    timeLogs?: TimeLogCreateNestedManyWithoutTaskInput
    assignees?: UserCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskUncheckedCreateWithoutTaskStatusInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTaskInput
    comments?: CommentUncheckedCreateNestedManyWithoutTaskInput
    subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput
    dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnTaskInput
    dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput
    labels?: TaskLabelUncheckedCreateNestedManyWithoutTaskInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutTaskInput
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedTasksInput
  }

  export type TaskCreateOrConnectWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput>
  }

  export type TaskCreateManyTaskStatusInputEnvelope = {
    data: TaskCreateManyTaskStatusInput | TaskCreateManyTaskStatusInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTaskStatusInput, TaskUncheckedUpdateWithoutTaskStatusInput>
    create: XOR<TaskCreateWithoutTaskStatusInput, TaskUncheckedCreateWithoutTaskStatusInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTaskStatusInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTaskStatusInput, TaskUncheckedUpdateWithoutTaskStatusInput>
  }

  export type TaskUpdateManyWithWhereWithoutTaskStatusInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTaskStatusInput>
  }

  export type ActivityLogCreateManyPerformedByInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogCreateManyAffectedUserInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ActivityLogCreateManyUserInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    projectId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
  }

  export type AttachmentCreateManyUploaderInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    taskId?: number | null
  }

  export type AutomationRuleCreateManyCreatorInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    teamId?: number | null
  }

  export type CommentCreateManyAuthorInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
  }

  export type CommentMentionCreateManyUserInput = {
    id?: number
    commentId: number
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    message: string
    type?: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ProjectNotificationPreferenceCreateManyUserInput = {
    id?: number
    projectId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationCreateManyUserInput = {
    id?: number
    projectId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectSettingCreateManyUpdaterInput = {
    id?: number
    projectId: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
  }

  export type ProjectSettingsChangeLogCreateManyChangerInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectCreateManyProjectManagerInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyUrgentMarkedByInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsChangeLogCreateManyUserInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type SubtaskCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    teamId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtaskCreateManyAssignedToInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingCreateManyUpdaterInput = {
    id?: number
    key: string
    value: string
    category: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TimeLogCreateManyUserInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    taskId?: number | null
    subtaskId?: number | null
  }

  export type UserSettingCreateManyUpdaterInput = {
    id?: number
    userId: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
  }

  export type UserSettingCreateManyUserInput = {
    id?: number
    key: string
    value: string
    category: string
    updatedAt?: Date | string
    updatedBy: number
  }

  export type UserSettingsChangeLogCreateManyChangerInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    settingId: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogCreateManyUserInput = {
    id?: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type TeamCreateManyTeamLeadInput = {
    id?: number
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: number
    teamId: number
    role?: string
    joinedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type UserRoleCreateManyAssignerInput = {
    id?: number
    userId: number
    roleId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementCreateManyUserInput = {
    id?: number
    projectId: number
    acknowledgedAt?: Date | string
  }

  export type ActivityLogUpdateWithoutPerformedByInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUser?: UserUpdateOneWithoutActivityLogsAffectedNestedInput
    project?: ProjectUpdateOneWithoutActivityLogsNestedInput
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutPerformedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutPerformedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogUpdateWithoutAffectedUserInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: UserUpdateOneWithoutActivityLogsPerformedNestedInput
    project?: ProjectUpdateOneWithoutActivityLogsNestedInput
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutAffectedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutAffectedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogUpdateWithoutUserInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: UserUpdateOneWithoutActivityLogsPerformedNestedInput
    affectedUser?: UserUpdateOneWithoutActivityLogsAffectedNestedInput
    project?: ProjectUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentUpdateWithoutUploaderInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttachmentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationRuleUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutRulesNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AutomationRuleUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtask?: SubtaskUpdateOneWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
    mentions?: CommentMentionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    mentions?: CommentMentionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentMentionUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutMentionsNestedInput
  }

  export type CommentMentionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentMentionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceUpdateWithoutUserInput = {
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutNotificationPreferencesNestedInput
  }

  export type ProjectNotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type ProjectNotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingUpdateWithoutUpdaterInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSettingsNestedInput
    changeLogs?: ProjectSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogUpdateWithoutChangerInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: ProjectSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    project?: ProjectUpdateOneRequiredWithoutSettingsLogsNestedInput
  }

  export type ProjectSettingsChangeLogUncheckedUpdateWithoutChangerInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutProjectManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutUrgentMarkedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUrgentMarkedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUrgentMarkedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsChangeLogUpdateWithoutUserInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: SystemSettingUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type SettingsChangeLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskUpdateWithoutAssignedToInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUpdateWithoutUpdaterInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeLogs?: SettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type SystemSettingUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeLogs?: SettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeLogUpdateWithoutUserInput = {
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtask?: SubtaskUpdateOneWithoutTimeLogsNestedInput
    task?: TaskUpdateOneWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TimeLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSettingUpdateWithoutUpdaterInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
    changeLogs?: UserSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingUncheckedUpdateWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingUncheckedUpdateManyWithoutUpdaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutUserSettingsUpdatedNestedInput
    changeLogs?: UserSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    changeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type UserSettingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type UserSettingsChangeLogUpdateWithoutChangerInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: UserSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutUserSettingsChangeLogsNestedInput
  }

  export type UserSettingsChangeLogUncheckedUpdateWithoutChangerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutChangerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogUpdateWithoutUserInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: UserSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    changer?: UserUpdateOneRequiredWithoutUserSettingsChangedNestedInput
  }

  export type UserSettingsChangeLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutAssigneesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUpdateWithoutTeamLeadInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUpdateManyWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamLeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: AutomationRuleUncheckedUpdateManyWithoutTeamNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutTeamNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutTeamLeadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
    assigner?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleUpdateWithoutAssignerInput = {
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutAssignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementUpdateWithoutUserInput = {
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUrgentAcknowledgmentsNestedInput
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationRuleCreateManyTeamInput = {
    id?: number
    name: string
    description?: string | null
    triggerType: string
    triggerCondition?: string | null
    actionType: string
    actionConfig?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdById: number
  }

  export type SubtaskCreateManyTeamInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    parentTaskId: number
    assignedToId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyTeamInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type UserCreateManyTeamInput = {
    id?: number
    username: string
    email: string
    passwordHash: string
    role?: string
    isActive?: boolean
    createdAt?: Date | string
    avatarUrl?: string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: number
    userId: number
    role?: string
    joinedAt?: Date | string
  }

  export type ProjectTeamCreateManyTeamInput = {
    id?: number
    projectId: number
    assignedAt?: Date | string
  }

  export type AutomationRuleUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedRulesNestedInput
  }

  export type AutomationRuleUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type AutomationRuleUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerCondition?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type SubtaskUpdateWithoutTeamInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    parentTaskId?: IntFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutTeamInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutTeamInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneesNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamUpdateWithoutTeamInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectTeamsNestedInput
  }

  export type ProjectTeamUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliverableCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    acceptanceCriteria?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectNotificationPreferenceCreateManyProjectInput = {
    id?: number
    userId: number
    soundEnabled?: boolean
    taskNotifications?: boolean
    dependencyNotifications?: boolean
    todayTaskNotifications?: boolean
    projectAdminNotifications?: boolean
    updatedAt?: Date | string
  }

  export type ProjectNotificationCreateManyProjectInput = {
    id?: number
    userId: number
    type: string
    entityType: string
    entityId?: number | null
    title: string
    message: string
    isRead?: boolean
    soundRequired?: boolean
    isUrgent?: boolean
    requiresAcknowledgment?: boolean
    acknowledgedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProjectPhaseCreateManyProjectInput = {
    id?: number
    name: string
    description?: string | null
    sequenceOrder: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ProjectSettingCreateManyProjectInput = {
    id?: number
    key: string
    value: string
    category: string
    enabled?: boolean
    updatedAt?: Date | string
    updatedBy: number
  }

  export type ProjectSettingsChangeLogCreateManyProjectInput = {
    id?: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    settingId: number
    createdAt?: Date | string
  }

  export type ProjectUserCreateManyProjectInput = {
    id?: number
    userId: number
    role: string
    allocationPercentage?: number
    joinedAt: Date | string
    leftAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScopeHistoryCreateManyProjectInput = {
    id?: number
    scopeText: string
    changeReason?: string | null
    changedById: number
    createdAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ActivityLogCreateManyProjectInput = {
    id?: number
    actionType?: string | null
    actionCategory?: string | null
    actionSummary?: string | null
    actionDetails?: string | null
    performedById?: number | null
    affectedUserId?: number | null
    entityType?: string | null
    entityId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    action?: string | null
    description?: string | null
    userId?: number | null
  }

  export type ProjectTeamCreateManyProjectInput = {
    id?: number
    teamId: number
    assignedAt?: Date | string
  }

  export type UrgentProjectAcknowledgementCreateManyProjectInput = {
    id?: number
    userId: number
    acknowledgedAt?: Date | string
  }

  export type DeliverableUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutDeliverableNestedInput
  }

  export type DeliverableUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutDeliverableNestedInput
  }

  export type DeliverableUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceUpdateWithoutProjectInput = {
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectNotificationPreferencesNestedInput
  }

  export type ProjectNotificationPreferenceUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    taskNotifications?: BoolFieldUpdateOperationsInput | boolean
    dependencyNotifications?: BoolFieldUpdateOperationsInput | boolean
    todayTaskNotifications?: BoolFieldUpdateOperationsInput | boolean
    projectAdminNotifications?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationUpdateWithoutProjectInput = {
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectNotificationsNestedInput
  }

  export type ProjectNotificationUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectNotificationUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    soundRequired?: BoolFieldUpdateOperationsInput | boolean
    isUrgent?: BoolFieldUpdateOperationsInput | boolean
    requiresAcknowledgment?: BoolFieldUpdateOperationsInput | boolean
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectPhaseUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingUpdateWithoutProjectInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updater?: UserUpdateOneRequiredWithoutProjectSettingsUpdatedNestedInput
    changeLogs?: ProjectSettingsChangeLogUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
    changeLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingNestedInput
  }

  export type ProjectSettingUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectSettingsChangeLogUpdateWithoutProjectInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setting?: ProjectSettingUpdateOneRequiredWithoutChangeLogsNestedInput
    changer?: UserUpdateOneRequiredWithoutProjectSettingsChangedNestedInput
  }

  export type ProjectSettingsChangeLogUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    settingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUpdateWithoutProjectInput = {
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUserUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    allocationPercentage?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryUpdateWithoutProjectInput = {
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScopeHistoryUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    scopeText?: StringFieldUpdateOperationsInput | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUpdateWithoutProjectInput = {
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: UserUpdateOneWithoutActivityLogsPerformedNestedInput
    affectedUser?: UserUpdateOneWithoutActivityLogsAffectedNestedInput
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityLogUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionCategory?: NullableStringFieldUpdateOperationsInput | string | null
    actionSummary?: NullableStringFieldUpdateOperationsInput | string | null
    actionDetails?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableIntFieldUpdateOperationsInput | number | null
    affectedUserId?: NullableIntFieldUpdateOperationsInput | number | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectTeamUpdateWithoutProjectInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutProjectTeamsNestedInput
  }

  export type ProjectTeamUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTeamUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementUpdateWithoutProjectInput = {
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUrgentAcknowledgementsNestedInput
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    acknowledgedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyTaskInput = {
    id?: number
    fileName: string
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    uploadedAt?: Date | string
    uploadedById: number
  }

  export type CommentCreateManyTaskInput = {
    id?: number
    content: string
    createdAt?: Date | string
    subtaskId?: number | null
    userId: number
  }

  export type SubtaskCreateManyParentTaskInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    startDate?: Date | string | null
    dueDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    assignedToId?: number | null
    teamId?: number | null
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskDependencyCreateManyDependsOnTaskInput = {
    taskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskDependencyCreateManyTaskInput = {
    dependsOnTaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TaskLabelCreateManyTaskInput = {
    labelId: number
    createdAt?: Date | string
  }

  export type TimeLogCreateManyTaskInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    subtaskId?: number | null
  }

  export type AttachmentUpdateWithoutTaskInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type AttachmentUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutTaskInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    subtask?: SubtaskUpdateOneWithoutCommentsNestedInput
    mentions?: CommentMentionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    mentions?: CommentMentionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SubtaskUpdateWithoutParentTaskInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUpdateManyWithoutSubtaskNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedSubtasksNestedInput
    team?: TeamUpdateOneWithoutSubtasksNestedInput
    assignedTo?: UserUpdateOneWithoutAssignedSubtasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateWithoutParentTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSubtaskNestedInput
    dependencies?: SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskNestedInput
    dependents?: SubtaskDependencyUncheckedUpdateManyWithoutSubtaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSubtaskNestedInput
  }

  export type SubtaskUncheckedUpdateManyWithoutParentTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUpdateWithoutDependsOnTaskInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutDependsOnTaskInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUpdateWithoutTaskInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOnTask?: TaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type TaskDependencyUncheckedUpdateWithoutTaskInput = {
    dependsOnTaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskDependencyUncheckedUpdateManyWithoutTaskInput = {
    dependsOnTaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUpdateWithoutTaskInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    label?: LabelUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutTaskInput = {
    labelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutTaskInput = {
    labelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUpdateWithoutTaskInput = {
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtask?: SubtaskUpdateOneWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TimeLogUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    subtaskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUpdateManyWithoutUserNestedInput
    team?: TeamUpdateOneWithoutUsersNestedInput
    teamsLed?: TeamUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activityLogsPerformed?: ActivityLogUncheckedUpdateManyWithoutPerformedByNestedInput
    activityLogsAffected?: ActivityLogUncheckedUpdateManyWithoutAffectedUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedFiles?: AttachmentUncheckedUpdateManyWithoutUploaderNestedInput
    createdRules?: AutomationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentMentions?: CommentMentionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    projectNotificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    projectNotifications?: ProjectNotificationUncheckedUpdateManyWithoutUserNestedInput
    projectSettingsUpdated?: ProjectSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    projectSettingsChanged?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    projectsManaged?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    projectsMarkedUrgent?: ProjectUncheckedUpdateManyWithoutUrgentMarkedByNestedInput
    settingsChanged?: SettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    createdSubtasks?: SubtaskUncheckedUpdateManyWithoutCreatorNestedInput
    assignedSubtasks?: SubtaskUncheckedUpdateManyWithoutAssignedToNestedInput
    updatedSettings?: SystemSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    tasksCreated?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    userSettingsUpdated?: UserSettingUncheckedUpdateManyWithoutUpdaterNestedInput
    userSettings?: UserSettingUncheckedUpdateManyWithoutUserNestedInput
    userSettingsChanged?: UserSettingsChangeLogUncheckedUpdateManyWithoutChangerNestedInput
    userSettingsChangeLogs?: UserSettingsChangeLogUncheckedUpdateManyWithoutUserNestedInput
    teamsLed?: TeamUncheckedUpdateManyWithoutTeamLeadNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignerNestedInput
    urgentAcknowledgements?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManySubtaskInput = {
    id?: number
    content: string
    createdAt?: Date | string
    taskId?: number | null
    userId: number
  }

  export type SubtaskDependencyCreateManyDependsOnSubtaskInput = {
    subtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type SubtaskDependencyCreateManySubtaskInput = {
    dependsOnSubtaskId: number
    dependencyType?: string
    createdById: number
    createdAt?: Date | string
  }

  export type TimeLogCreateManySubtaskInput = {
    id?: number
    hoursLogged: number
    description?: string | null
    logDate: Date | string
    createdAt?: Date | string
    userId: number
    taskId?: number | null
  }

  export type CommentUpdateWithoutSubtaskInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    task?: TaskUpdateOneWithoutCommentsNestedInput
    mentions?: CommentMentionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutSubtaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    mentions?: CommentMentionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutSubtaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type SubtaskDependencyUpdateWithoutDependsOnSubtaskInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtask?: SubtaskUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type SubtaskDependencyUncheckedUpdateWithoutDependsOnSubtaskInput = {
    subtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyUncheckedUpdateManyWithoutDependsOnSubtaskInput = {
    subtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyUpdateWithoutSubtaskInput = {
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOnSubtask?: SubtaskUpdateOneRequiredWithoutDependenciesNestedInput
  }

  export type SubtaskDependencyUncheckedUpdateWithoutSubtaskInput = {
    dependsOnSubtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtaskDependencyUncheckedUpdateManyWithoutSubtaskInput = {
    dependsOnSubtaskId?: IntFieldUpdateOperationsInput | number
    dependencyType?: StringFieldUpdateOperationsInput | string
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUpdateWithoutSubtaskInput = {
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutSubtaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TimeLogUncheckedUpdateManyWithoutSubtaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    hoursLogged?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    taskId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentMentionCreateManyCommentInput = {
    id?: number
    userId: number
    createdAt?: Date | string
  }

  export type CommentMentionUpdateWithoutCommentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentMentionsNestedInput
  }

  export type CommentMentionUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentMentionUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelCreateManyLabelInput = {
    taskId: number
    createdAt?: Date | string
  }

  export type TaskLabelUpdateWithoutLabelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutLabelsNestedInput
  }

  export type TaskLabelUncheckedUpdateWithoutLabelInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLabelUncheckedUpdateManyWithoutLabelInput = {
    taskId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyDeliverableInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    taskStatusId?: number | null
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TaskUpdateWithoutDeliverableInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    taskStatus?: TaskStatusUpdateOneWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutDeliverableInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutDeliverableInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    taskStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SettingsChangeLogCreateManySettingInput = {
    id?: number
    settingKey: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    userId: number
    createdAt?: Date | string
  }

  export type SettingsChangeLogUpdateWithoutSettingInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsChangedNestedInput
  }

  export type SettingsChangeLogUncheckedUpdateWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsChangeLogUncheckedUpdateManyWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogCreateManySettingInput = {
    id?: number
    projectId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    createdAt?: Date | string
  }

  export type ProjectSettingsChangeLogUpdateWithoutSettingInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changer?: UserUpdateOneRequiredWithoutProjectSettingsChangedNestedInput
    project?: ProjectUpdateOneRequiredWithoutSettingsLogsNestedInput
  }

  export type ProjectSettingsChangeLogUncheckedUpdateWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectSettingsChangeLogUncheckedUpdateManyWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogCreateManySettingInput = {
    id?: number
    userId: number
    settingKey: string
    category: string
    oldValue?: string | null
    newValue: string
    reason?: string | null
    changedBy: number
    createdAt?: Date | string
  }

  export type UserSettingsChangeLogUpdateWithoutSettingInput = {
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changer?: UserUpdateOneRequiredWithoutUserSettingsChangedNestedInput
    user?: UserUpdateOneRequiredWithoutUserSettingsChangeLogsNestedInput
  }

  export type UserSettingsChangeLogUncheckedUpdateWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsChangeLogUncheckedUpdateManyWithoutSettingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    settingKey?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: number
    permissionId: number
    createdAt?: Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: number
    userId: number
    scopeType?: string | null
    scopeId?: number | null
    assignedAt?: Date | string
    assignedBy?: number | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    assigner?: UserUpdateOneWithoutAssignedRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    scopeType?: NullableStringFieldUpdateOperationsInput | string | null
    scopeId?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    roleId: number
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyProjectTypeInput = {
    id?: number
    name: string
    type: string
    projectStatusId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutProjectTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectStatus?: ProjectStatusUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyProjectStatusInput = {
    id?: number
    name: string
    type: string
    projectTypeId?: number | null
    description?: string | null
    scope?: string | null
    status?: string
    priority?: string
    urgentReason?: string | null
    urgentMarkedAt?: Date | string | null
    urgentMarkedById?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    projectManagerId?: number | null
    createdById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutProjectStatusInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUpdateManyWithoutProjectNestedInput
    projectManager?: UserUpdateOneWithoutProjectsManagedNestedInput
    urgentMarkedBy?: UserUpdateOneWithoutProjectsMarkedUrgentNestedInput
    projectType?: ProjectTypeUpdateOneWithoutProjectsNestedInput
    scopeHistory?: ScopeHistoryUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliverables?: DeliverableUncheckedUpdateManyWithoutProjectNestedInput
    notificationPreferences?: ProjectNotificationPreferenceUncheckedUpdateManyWithoutProjectNestedInput
    notifications?: ProjectNotificationUncheckedUpdateManyWithoutProjectNestedInput
    phases?: ProjectPhaseUncheckedUpdateManyWithoutProjectNestedInput
    settings?: ProjectSettingUncheckedUpdateManyWithoutProjectNestedInput
    settingsLogs?: ProjectSettingsChangeLogUncheckedUpdateManyWithoutProjectNestedInput
    projectUsers?: ProjectUserUncheckedUpdateManyWithoutProjectNestedInput
    scopeHistory?: ScopeHistoryUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutProjectNestedInput
    projectTeams?: ProjectTeamUncheckedUpdateManyWithoutProjectNestedInput
    urgentAcknowledgments?: UrgentProjectAcknowledgementUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    projectTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    urgentReason?: NullableStringFieldUpdateOperationsInput | string | null
    urgentMarkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    urgentMarkedById?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projectManagerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyTaskStatusInput = {
    id?: number
    title: string
    description?: string | null
    status?: string
    priority?: string
    dueDate?: Date | string | null
    plannedDate?: Date | string | null
    estimatedHours?: number
    actualHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    teamId?: number | null
    createdById?: number | null
    deliverableId?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type TaskUpdateWithoutTaskStatusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUpdateManyWithoutTaskNestedInput
    comments?: CommentUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUpdateManyWithoutTaskNestedInput
    deliverable?: DeliverableUpdateOneWithoutTasksNestedInput
    creator?: UserUpdateOneWithoutTasksCreatedNestedInput
    team?: TeamUpdateOneWithoutTasksNestedInput
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    timeLogs?: TimeLogUpdateManyWithoutTaskNestedInput
    assignees?: UserUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTaskStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutTaskNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTaskNestedInput
    subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput
    dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnTaskNestedInput
    dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput
    labels?: TaskLabelUncheckedUpdateManyWithoutTaskNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutTaskNestedInput
    assignees?: UserUncheckedUpdateManyWithoutAssignedTasksNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTaskStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedHours?: FloatFieldUpdateOperationsInput | number
    actualHours?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deliverableId?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtaskCountOutputTypeDefaultArgs instead
     */
    export type SubtaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabelCountOutputTypeDefaultArgs instead
     */
    export type LabelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliverableCountOutputTypeDefaultArgs instead
     */
    export type DeliverableCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliverableCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingCountOutputTypeDefaultArgs instead
     */
    export type SystemSettingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectSettingCountOutputTypeDefaultArgs instead
     */
    export type ProjectSettingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectSettingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingCountOutputTypeDefaultArgs instead
     */
    export type UserSettingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectTypeCountOutputTypeDefaultArgs instead
     */
    export type ProjectTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectStatusCountOutputTypeDefaultArgs instead
     */
    export type ProjectStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskStatusCountOutputTypeDefaultArgs instead
     */
    export type TaskStatusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskStatusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtaskDefaultArgs instead
     */
    export type SubtaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtaskDependencyDefaultArgs instead
     */
    export type SubtaskDependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtaskDependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentMentionDefaultArgs instead
     */
    export type CommentMentionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentMentionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabelDefaultArgs instead
     */
    export type LabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskLabelDefaultArgs instead
     */
    export type TaskLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskLabelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDependencyDefaultArgs instead
     */
    export type TaskDependencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDependencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeLogDefaultArgs instead
     */
    export type TimeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AutomationRuleDefaultArgs instead
     */
    export type AutomationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectUserDefaultArgs instead
     */
    export type ProjectUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectPhaseDefaultArgs instead
     */
    export type ProjectPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliverableDefaultArgs instead
     */
    export type DeliverableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliverableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScopeHistoryDefaultArgs instead
     */
    export type ScopeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScopeHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingDefaultArgs instead
     */
    export type SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingsChangeLogDefaultArgs instead
     */
    export type SettingsChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingsChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectSettingDefaultArgs instead
     */
    export type ProjectSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectSettingsChangeLogDefaultArgs instead
     */
    export type ProjectSettingsChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectSettingsChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingDefaultArgs instead
     */
    export type UserSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingsChangeLogDefaultArgs instead
     */
    export type UserSettingsChangeLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingsChangeLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectNotificationDefaultArgs instead
     */
    export type ProjectNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UrgentProjectAcknowledgementDefaultArgs instead
     */
    export type UrgentProjectAcknowledgementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UrgentProjectAcknowledgementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectNotificationPreferenceDefaultArgs instead
     */
    export type ProjectNotificationPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectNotificationPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectTeamDefaultArgs instead
     */
    export type ProjectTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectTeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectTypeDefaultArgs instead
     */
    export type ProjectTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectStatusDefaultArgs instead
     */
    export type ProjectStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskStatusDefaultArgs instead
     */
    export type TaskStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatSnapshotDefaultArgs instead
     */
    export type StatSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatSnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductivitySnapshotDefaultArgs instead
     */
    export type ProductivitySnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductivitySnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForecastSnapshotDefaultArgs instead
     */
    export type ForecastSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForecastSnapshotDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}