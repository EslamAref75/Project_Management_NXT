{"version":3,"sources":["../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/projects.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/constants.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/constructFrom.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/toDate.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/startOfDay.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/endOfDay.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/addDays.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/subDays.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/lib/stats.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/addWeeks.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/node_modules/date-fns/subWeeks.js","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/stats.ts"],"sourcesContent":["\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { z } from \"zod\"\r\nimport { revalidatePath } from \"next/cache\"\r\nimport { logActivity } from \"@/lib/activity-logger\"\r\nimport { hasPermissionWithoutRoleBypass, handleAuthorizationError } from \"@/lib/rbac-helpers\"\r\nimport { PERMISSIONS } from \"@/lib/permissions\"\r\nimport { selectPatterns } from \"@/lib/query-optimization\"\r\n\r\nconst projectSchema = z.object({\r\n    name: z.string().min(1, \"Name is required\"),\r\n    type: z.string().optional(), // Legacy field, kept for backward compatibility\r\n    projectTypeId: z.coerce.number().optional().nullable(),\r\n    projectStatusId: z.coerce.number().optional().nullable(),\r\n    description: z.string().optional(),\r\n    scope: z.string().optional(),\r\n    status: z.string().optional(), // Legacy field, kept for backward compatibility\r\n    startDate: z.string().optional(),\r\n    endDate: z.string().optional(),\r\n    projectManagerId: z.coerce.number().optional(),\r\n})\r\n\r\nexport async function getProjects() {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) throw new Error(\"Unauthorized\")\r\n\r\n    // ✅ OPTIMIZED: Use select pattern instead of fetching all columns\r\n    // Fetch only necessary fields to reduce data transfer\r\n    const projects = await prisma.project.findMany({\r\n        orderBy: { createdAt: \"desc\" },\r\n        select: {\r\n            id: true,\r\n            name: true,\r\n            description: true,\r\n            status: true,\r\n            type: true,\r\n            projectStatusId: true,\r\n            projectTypeId: true,\r\n            projectManagerId: true,\r\n            startDate: true,\r\n            endDate: true,\r\n            createdAt: true,\r\n            createdById: true,\r\n            projectManager: {\r\n                select: {\r\n                    id: true,\r\n                    username: true,\r\n                    email: true,\r\n                    avatarUrl: true,\r\n                },\r\n            },\r\n            _count: {\r\n                select: {\r\n                    tasks: true,\r\n                    projectUsers: true,\r\n                    notifications: true,\r\n                },\r\n            },\r\n        },\r\n    })\r\n\r\n    return projects\r\n}\r\n\r\nexport async function getProjectsWithFilters(params: {\r\n    search?: string\r\n    category?: string[]\r\n    status?: string[]\r\n    priority?: string[]\r\n    startDate?: string\r\n    endDate?: string\r\n    projectManager?: string\r\n    page?: number\r\n    limit?: number\r\n}) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { error: \"Unauthorized\" }\r\n\r\n    const {\r\n        search = \"\",\r\n        category = [],\r\n        status = [],\r\n        priority = [],\r\n        startDate,\r\n        endDate,\r\n        projectManager,\r\n        page = 1,\r\n        limit = 12,\r\n    } = params\r\n\r\n    try {\r\n        const where: any = {}\r\n\r\n        // Search filter\r\n        if (search) {\r\n            where.name = { contains: search }\r\n        }\r\n\r\n        // Category filter\r\n        if (category.length > 0) {\r\n            where.type = { in: category }\r\n        }\r\n\r\n        // Status filter - support both status IDs (for dynamic statuses) and legacy status names\r\n        if (status.length > 0) {\r\n            const statusIds: number[] = []\r\n            const statusNames: string[] = []\r\n\r\n            status.forEach(s => {\r\n                const id = parseInt(s)\r\n                if (!isNaN(id)) {\r\n                    statusIds.push(id)\r\n                } else {\r\n                    statusNames.push(s)\r\n                }\r\n            })\r\n\r\n            const statusConditions: any[] = []\r\n            if (statusIds.length > 0) {\r\n                statusConditions.push({ projectStatusId: { in: statusIds } })\r\n            }\r\n\r\n            // Handle specific named statuses (legacy)\r\n            const legacyStatusNames = statusNames.filter(s => s !== \"active\" && s !== \"completed\")\r\n            if (legacyStatusNames.length > 0) {\r\n                statusConditions.push({ status: { in: legacyStatusNames }, projectStatusId: null })\r\n            }\r\n\r\n            // Handle \"active\" meta-status (Legacy \"active\" OR Dynamic isActive=true)\r\n            if (statusNames.includes(\"active\")) {\r\n                statusConditions.push({ status: \"active\" })\r\n                statusConditions.push({ projectStatus: { isActive: true } })\r\n            }\r\n\r\n            // Handle \"completed\" meta-status (Legacy \"completed\" OR Dynamic isFinal=true)\r\n            if (statusNames.includes(\"completed\")) {\r\n                statusConditions.push({ status: \"completed\" })\r\n                statusConditions.push({ projectStatus: { isFinal: true } })\r\n            }\r\n\r\n            if (statusConditions.length > 0) {\r\n                where.OR = statusConditions\r\n            }\r\n\r\n            // Priority filter\r\n            if (priority.length > 0) {\r\n                where.priority = { in: priority }\r\n            }\r\n        }\r\n\r\n        // Date range filter\r\n        if (startDate || endDate) {\r\n            const dateConditions: any[] = []\r\n            if (startDate) {\r\n                dateConditions.push({ startDate: { gte: new Date(startDate) } })\r\n            }\r\n            if (endDate) {\r\n                dateConditions.push({ endDate: { lte: new Date(endDate) } })\r\n            }\r\n            if (dateConditions.length > 0) {\r\n                where.AND = [...(where.AND || []), ...dateConditions]\r\n            }\r\n        }\r\n\r\n        // Project Manager filter\r\n        if (projectManager) {\r\n            where.projectManagerId = parseInt(projectManager)\r\n        }\r\n\r\n        // Role-based filtering - Use RBAC instead of hardcoded roles\r\n        const canViewAllProjects = await hasPermissionWithoutRoleBypass(\r\n            parseInt(session.user.id),\r\n            \"project.viewAll\"\r\n        )\r\n\r\n        // If user doesn't have project.viewAll permission, restrict visibility\r\n        if (!canViewAllProjects) {\r\n            // For users without viewAll permission, show only projects they're assigned to\r\n            const userConditions = [\r\n                { projectManagerId: parseInt(session.user.id) },\r\n                { createdById: parseInt(session.user.id) },\r\n            ]\r\n\r\n            if (where.OR) {\r\n                where.AND = [\r\n                    ...(where.AND || []),\r\n                    { OR: [...where.OR, ...userConditions] }\r\n                ]\r\n                delete where.OR\r\n            } else {\r\n                where.OR = userConditions\r\n            }\r\n        }\r\n\r\n        const skip = (page - 1) * limit\r\n\r\n        const [projects, total] = await Promise.all([\r\n            prisma.project.findMany({\r\n                where,\r\n                skip,\r\n                take: limit,\r\n                orderBy: { createdAt: \"desc\" },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    description: true,\r\n                    status: true,\r\n                    type: true,\r\n                    projectStatusId: true,\r\n                    projectTypeId: true,\r\n                    projectManagerId: true,\r\n                    startDate: true,\r\n                    endDate: true,\r\n                    createdAt: true,\r\n                    createdById: true,\r\n                    projectManager: {\r\n                        select: {\r\n                            id: true,\r\n                            username: true,\r\n                            email: true,\r\n                            avatarUrl: true,\r\n                        },\r\n                    },\r\n                    _count: {\r\n                        select: {\r\n                            tasks: true,\r\n                            projectUsers: true,\r\n                            notifications: true,\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n            prisma.project.count({ where }),\r\n        ])\r\n\r\n        return {\r\n            success: true,\r\n            projects,\r\n            total,\r\n            page,\r\n            limit,\r\n        }\r\n    } catch (error: any) {\r\n        console.error(\"Error fetching projects with filters:\", error)\r\n        return {\r\n            error: error.message || \"Failed to fetch projects\",\r\n        }\r\n    }\r\n}\r\n\r\nexport async function createProject(formData: FormData) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { error: \"Unauthorized\" }\r\n\r\n    // Check permission using RBAC (no role-based bypass)\r\n    const hasPermission = await hasPermissionWithoutRoleBypass(\r\n        parseInt(session.user.id),\r\n        PERMISSIONS.PROJECT.CREATE\r\n    )\r\n\r\n    if (!hasPermission) {\r\n        return { error: \"Permission denied: You don't have permission to create projects\" }\r\n    }\r\n\r\n    const name = formData.get(\"name\") as string\r\n    const type = formData.get(\"type\") as string\r\n    const projectTypeId = formData.get(\"projectTypeId\")\r\n    const description = formData.get(\"description\") as string\r\n    const scope = formData.get(\"scope\") as string\r\n    const startDate = formData.get(\"startDate\") as string\r\n    const endDate = formData.get(\"endDate\") as string\r\n    const projectManagerId = formData.get(\"projectManagerId\")\r\n\r\n    // If projectTypeId is provided, get the type name from the ProjectType\r\n    let typeName = type || \"\"\r\n    if (projectTypeId) {\r\n        try {\r\n            const projectType = await prisma.projectType.findUnique({\r\n                where: { id: parseInt(projectTypeId as string) },\r\n                select: { name: true }\r\n            })\r\n            if (projectType) {\r\n                typeName = projectType.name\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error fetching project type:\", error)\r\n        }\r\n    }\r\n\r\n    const validated = projectSchema.safeParse({\r\n        name,\r\n        type: typeName || undefined,\r\n        projectTypeId: projectTypeId ? parseInt(projectTypeId as string) : null,\r\n        description,\r\n        scope,\r\n        startDate,\r\n        endDate,\r\n        projectManagerId\r\n    })\r\n\r\n    if (!validated.success) {\r\n        console.error(validated.error)\r\n        return { error: \"Validation failed\", details: validated.error.format() }\r\n    }\r\n\r\n    try {\r\n        const project = await prisma.project.create({\r\n            data: {\r\n                name: validated.data.name,\r\n                type: validated.data.type || \"\",\r\n                projectTypeId: validated.data.projectTypeId,\r\n                description: validated.data.description,\r\n                scope: validated.data.scope,\r\n                status: validated.data.status,\r\n                startDate: validated.data.startDate ? new Date(validated.data.startDate) : null,\r\n                endDate: validated.data.endDate ? new Date(validated.data.endDate) : null,\r\n                projectManagerId: (validated.data.projectManagerId && validated.data.projectManagerId > 0) ? validated.data.projectManagerId : null,\r\n                createdById: parseInt(session.user.id),\r\n            }\r\n        })\r\n\r\n        // Log activity\r\n        try {\r\n            await logActivity({\r\n                actionType: \"project_created\",\r\n                actionCategory: \"project\",\r\n                actionSummary: `Project \"${project.name}\" created`,\r\n                actionDetails: {\r\n                    projectId: project.id,\r\n                    projectName: project.name,\r\n                    projectType: project.type,\r\n                    status: project.status,\r\n                },\r\n                performedById: parseInt(session.user.id),\r\n                projectId: project.id,\r\n                entityType: \"project\",\r\n                entityId: project.id,\r\n            })\r\n            console.log(\"[Project Creation] Activity logging completed\")\r\n        } catch (logError) {\r\n            console.error(\"[Project Creation] Failed to log activity:\", logError)\r\n            // Don't fail the project creation if logging fails\r\n        }\r\n\r\n        revalidatePath(\"/dashboard/projects\")\r\n        revalidatePath(\"/dashboard\")\r\n        return { success: true }\r\n    } catch (e) {\r\n        console.error(e)\r\n        return { error: \"Failed to create project\" }\r\n    }\r\n}\r\n\r\nexport async function getProject(id: number) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) throw new Error(\"Unauthorized\")\r\n\r\n    // ✅ OPTIMIZED: Separate queries for different data needs\r\n    // Fetch project details, tasks, and team in parallel instead of nested includes\r\n    const [project, tasks, teams] = await Promise.all([\r\n        // Query 1: Project with basic relationships\r\n        prisma.project.findUnique({\r\n            where: { id },\r\n            select: {\r\n                id: true,\r\n                name: true,\r\n                description: true,\r\n                status: true,\r\n                type: true,\r\n                priority: true,\r\n                projectStatusId: true,\r\n                projectTypeId: true,\r\n                projectManagerId: true,\r\n                startDate: true,\r\n                endDate: true,\r\n                createdAt: true,\r\n                createdById: true,\r\n                // isUrgent: true, // Removed as it doesn't exist on Project model\r\n                urgentMarkedAt: true,\r\n                urgentMarkedById: true,\r\n                projectType: {\r\n                    select: { id: true, name: true }\r\n                },\r\n                projectStatus: {\r\n                    select: { id: true, name: true }\r\n                },\r\n                projectManager: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true,\r\n                        avatarUrl: true\r\n                    }\r\n                },\r\n                urgentMarkedBy: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true\r\n                    }\r\n                },\r\n                _count: {\r\n                    select: {\r\n                        tasks: true,\r\n                        projectUsers: true,\r\n                        projectTeams: true\r\n                    }\r\n                }\r\n            }\r\n        }),\r\n\r\n        // Query 2: Tasks with minimal dependencies\r\n        prisma.task.findMany({\r\n            where: { projectId: id },\r\n            orderBy: { createdAt: \"desc\" },\r\n            select: {\r\n                id: true,\r\n                title: true,\r\n                description: true,\r\n                status: true,\r\n                taskStatusId: true,\r\n                priority: true,\r\n                dueDate: true,\r\n                createdAt: true,\r\n                assignees: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true,\r\n                        avatarUrl: true\r\n                    }\r\n                },\r\n                attachments: {\r\n                    select: {\r\n                        id: true,\r\n                        fileName: true,\r\n                        fileUrl: true,\r\n                        fileType: true,\r\n                        fileSize: true\r\n                    }\r\n                },\r\n                dependencies: {\r\n                    select: {\r\n                        // id: true, // Removed as TaskDependency has composite key\r\n                        dependencyType: true,\r\n                        dependsOnTaskId: true,\r\n                        dependsOnTask: {\r\n                            select: {\r\n                                id: true,\r\n                                title: true,\r\n                                status: true,\r\n                                taskStatusId: true\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }),\r\n\r\n        // Query 3: Project teams with members\r\n        prisma.projectTeam.findMany({\r\n            where: { projectId: id },\r\n            select: {\r\n                id: true,\r\n                teamId: true,\r\n                team: {\r\n                    select: {\r\n                        id: true,\r\n                        name: true,\r\n                        description: true,\r\n                        teamLead: {\r\n                            select: {\r\n                                id: true,\r\n                                username: true,\r\n                                email: true,\r\n                                avatarUrl: true\r\n                            }\r\n                        },\r\n                        members: {\r\n                            select: {\r\n                                id: true,\r\n                                userId: true,\r\n                                user: {\r\n                                    select: {\r\n                                        id: true,\r\n                                        username: true,\r\n                                        email: true,\r\n                                        avatarUrl: true\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    ])\r\n\r\n    // Combine results\r\n    if (project) {\r\n        return {\r\n            ...project,\r\n            tasks,\r\n            projectTeams: teams\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport async function updateProject(id: number, formData: FormData) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { error: \"Unauthorized\" }\r\n\r\n    // Verify project exists and user has permission\r\n    const existingProject = await prisma.project.findUnique({\r\n        where: { id },\r\n        select: { id: true, createdById: true }\r\n    })\r\n\r\n    if (!existingProject) {\r\n        return { error: \"Project not found\" }\r\n    }\r\n\r\n    // Check permission using RBAC (no role-based bypass)\r\n    const hasPermission = await hasPermissionWithoutRoleBypass(\r\n        parseInt(session.user.id),\r\n        PERMISSIONS.PROJECT.UPDATE,\r\n        id // projectId for project-scoped permissions\r\n    )\r\n\r\n    // Also allow creator to update their own projects\r\n    const isCreator = existingProject.createdById === parseInt(session.user.id)\r\n\r\n    if (!hasPermission && !isCreator) {\r\n        return { error: \"Permission denied: You don't have permission to update this project\" }\r\n    }\r\n\r\n    const name = formData.get(\"name\") as string\r\n    const type = formData.get(\"type\") as string\r\n    const projectTypeId = formData.get(\"projectTypeId\")\r\n    const projectStatusId = formData.get(\"projectStatusId\")\r\n    const description = formData.get(\"description\") as string\r\n    const scope = formData.get(\"scope\") as string\r\n    const status = formData.get(\"status\") as string\r\n    const startDate = formData.get(\"startDate\") as string\r\n    const endDate = formData.get(\"endDate\") as string\r\n    const projectManagerId = formData.get(\"projectManagerId\")\r\n\r\n    // If projectTypeId is provided, get the type name from the ProjectType\r\n    let typeName = type || \"\"\r\n    if (projectTypeId) {\r\n        try {\r\n            const projectType = await prisma.projectType.findUnique({\r\n                where: { id: parseInt(projectTypeId as string) },\r\n                select: { name: true }\r\n            })\r\n            if (projectType) {\r\n                typeName = projectType.name\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error fetching project type:\", error)\r\n        }\r\n    }\r\n\r\n    // If projectStatusId is provided, get the status name from the ProjectStatus\r\n    let statusName = status || \"\"\r\n    if (projectStatusId && prisma.projectStatus) {\r\n        try {\r\n            const projectStatus = await prisma.projectStatus.findUnique({\r\n                where: { id: parseInt(projectStatusId as string) },\r\n                select: { name: true }\r\n            })\r\n            if (projectStatus) {\r\n                statusName = projectStatus.name\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Error fetching project status:\", error)\r\n        }\r\n    }\r\n\r\n    const validated = projectSchema.safeParse({\r\n        name,\r\n        type: typeName || undefined,\r\n        projectTypeId: projectTypeId ? parseInt(projectTypeId as string) : null,\r\n        projectStatusId: projectStatusId ? parseInt(projectStatusId as string) : null,\r\n        description,\r\n        scope,\r\n        status: statusName || undefined,\r\n        startDate,\r\n        endDate,\r\n        projectManagerId\r\n    })\r\n\r\n    if (!validated.success) {\r\n        console.error(validated.error)\r\n        return { error: \"Validation failed\", details: validated.error.format() }\r\n    }\r\n\r\n    try {\r\n        await prisma.project.update({\r\n            where: { id },\r\n            data: {\r\n                name: validated.data.name,\r\n                type: validated.data.type || \"\",\r\n                projectTypeId: validated.data.projectTypeId,\r\n                projectStatusId: validated.data.projectStatusId,\r\n                description: validated.data.description,\r\n                scope: validated.data.scope,\r\n                status: statusName || validated.data.status || \"\",\r\n                startDate: validated.data.startDate ? new Date(validated.data.startDate) : null,\r\n                endDate: validated.data.endDate ? new Date(validated.data.endDate) : null,\r\n                projectManagerId: (validated.data.projectManagerId && validated.data.projectManagerId > 0) ? validated.data.projectManagerId : null,\r\n            }\r\n        })\r\n        revalidatePath(\"/dashboard/projects\")\r\n        revalidatePath(`/dashboard/projects/${id}`)\r\n        revalidatePath(\"/dashboard\")\r\n        return { success: true }\r\n    } catch (e: any) {\r\n        console.error(e)\r\n        return { error: \"Failed to update project\", details: e.message }\r\n    }\r\n}\r\n\r\nexport async function deleteProject(id: number) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { error: \"Unauthorized\" }\r\n\r\n    // Verify project exists and user has permission\r\n    const project = await prisma.project.findUnique({\r\n        where: { id },\r\n        select: { id: true, createdById: true, name: true }\r\n    })\r\n\r\n    if (!project) {\r\n        return { error: \"Project not found\" }\r\n    }\r\n\r\n    // Check permission using RBAC (no role-based bypass)\r\n    const hasPermission = await hasPermissionWithoutRoleBypass(\r\n        parseInt(session.user.id),\r\n        PERMISSIONS.PROJECT.DELETE,\r\n        id // projectId for project-scoped permissions\r\n    )\r\n\r\n    // Also allow creator to delete their own projects\r\n    const isCreator = project.createdById === parseInt(session.user.id)\r\n\r\n    if (!hasPermission && !isCreator) {\r\n        return { error: \"Permission denied: You don't have permission to delete this project\" }\r\n    }\r\n\r\n    // Get task count for logging/notification purposes\r\n    const taskCount = await prisma.task.count({\r\n        where: { projectId: id }\r\n    })\r\n\r\n    try {\r\n        // Delete project - tasks will be automatically deleted due to cascade delete\r\n        await prisma.project.delete({\r\n            where: { id }\r\n        })\r\n\r\n        console.log(`Project ${id} deleted successfully${taskCount > 0 ? ` along with ${taskCount} task(s)` : \"\"}`)\r\n        revalidatePath(\"/dashboard/projects\")\r\n        revalidatePath(\"/dashboard\")\r\n        return { success: true }\r\n    } catch (e: any) {\r\n        console.error(e)\r\n        return { error: \"Failed to delete project\", details: e.message }\r\n    }\r\n}\r\n","/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n","import { constructFromSymbol } from \"./constants.js\";\n\n/**\n * @name constructFrom\n * @category Generic Helpers\n * @summary Constructs a date using the reference date and the value\n *\n * @description\n * The function constructs a new date using the constructor from the reference\n * date and the given value. It helps to build generic functions that accept\n * date extensions.\n *\n * It defaults to `Date` if the passed reference date is a number or a string.\n *\n * Starting from v3.7.0, it allows to construct a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The reference date to take constructor from\n * @param value - The value to create the date\n *\n * @returns Date initialized using the given date and value\n *\n * @example\n * import { constructFrom } from \"./constructFrom/date-fns\";\n *\n * // A function that clones a date preserving the original type\n * function cloneDate<DateType extends Date>(date: DateType): DateType {\n *   return constructFrom(\n *     date, // Use constructor from the given date\n *     date.getTime() // Use the date value to create a new date\n *   );\n * }\n */\nexport function constructFrom(date, value) {\n  if (typeof date === \"function\") return date(value);\n\n  if (date && typeof date === \"object\" && constructFromSymbol in date)\n    return date[constructFromSymbol](value);\n\n  if (date instanceof Date) return new date.constructor(value);\n\n  return new Date(value);\n}\n\n// Fallback for modularized imports:\nexport default constructFrom;\n","import { constructFrom } from \"./constructFrom.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate(argument, context) {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\n// Fallback for modularized imports:\nexport default toDate;\n","import { toDate } from \"./toDate.js\";\n\n/**\n * The {@link startOfDay} function options.\n */\n\n/**\n * @name startOfDay\n * @category Day Helpers\n * @summary Return the start of a day for the given date.\n *\n * @description\n * Return the start of a day for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The original date\n * @param options - The options\n *\n * @returns The start of a day\n *\n * @example\n * // The start of a day for 2 September 2014 11:55:00:\n * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 00:00:00\n */\nexport function startOfDay(date, options) {\n  const _date = toDate(date, options?.in);\n  _date.setHours(0, 0, 0, 0);\n  return _date;\n}\n\n// Fallback for modularized imports:\nexport default startOfDay;\n","import { toDate } from \"./toDate.js\";\n\n/**\n * The {@link endOfDay} function options.\n */\n\n/**\n * @name endOfDay\n * @category Day Helpers\n * @summary Return the end of a day for the given date.\n *\n * @description\n * Return the end of a day for the given date.\n * The result will be in the local timezone.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The original date\n * @param options - An object with options\n *\n * @returns The end of a day\n *\n * @example\n * // The end of a day for 2 September 2014 11:55:00:\n * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 23:59:59.999\n */\nexport function endOfDay(date, options) {\n  const _date = toDate(date, options?.in);\n  _date.setHours(23, 59, 59, 999);\n  return _date;\n}\n\n// Fallback for modularized imports:\nexport default endOfDay;\n","import { constructFrom } from \"./constructFrom.js\";\nimport { toDate } from \"./toDate.js\";\n\n/**\n * The {@link addDays} function options.\n */\n\n/**\n * @name addDays\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of days to be added.\n * @param options - An object with options\n *\n * @returns The new date with the days added\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * const result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\nexport function addDays(date, amount, options) {\n  const _date = toDate(date, options?.in);\n  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);\n\n  // If 0 days, no-op to avoid changing times in the hour before end of DST\n  if (!amount) return _date;\n\n  _date.setDate(_date.getDate() + amount);\n  return _date;\n}\n\n// Fallback for modularized imports:\nexport default addDays;\n","import { addDays } from \"./addDays.js\";\n\n/**\n * The {@link subDays} function options.\n */\n\n/**\n * @name subDays\n * @category Day Helpers\n * @summary Subtract the specified number of days from the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of days to be subtracted.\n * @param options - An object with options\n *\n * @returns The new date with the days subtracted\n *\n * @example\n * // Subtract 10 days from 1 September 2014:\n * const result = subDays(new Date(2014, 8, 1), 10)\n * //=> Fri Aug 22 2014 00:00:00\n */\nexport function subDays(date, amount, options) {\n  return addDays(date, -amount, options);\n}\n\n// Fallback for modularized imports:\nexport default subDays;\n","import { prisma } from \"@/lib/prisma\"\r\nimport { startOfDay, subDays, startOfWeek, subWeeks, endOfDay } from \"date-fns\"\r\n\r\nexport type TrendDirection = \"up\" | \"down\" | \"neutral\"\r\n\r\nexport interface StatTrend {\r\n    direction: TrendDirection\r\n    value: number // Percentage or absolute difference\r\n    percentage: number\r\n}\r\n\r\nexport interface StatWithTrend {\r\n    value: number\r\n    trend: StatTrend | null\r\n}\r\n\r\n/**\r\n * Ensures a snapshot exists for the current day for the given metric.\r\n * If not, it calculates it and saves it.\r\n * NOTE: For this simple implementation, we'll assume the 'value' passed is the current live value.\r\n * In a more complex system, this function might calculate the value itself.\r\n */\r\nexport async function captureDailySnapshot(\r\n    entityType: string,\r\n    entityId: number | null,\r\n    metricKey: string,\r\n    currentValue: number\r\n) {\r\n    const today = startOfDay(new Date())\r\n\r\n    // Check if snapshot exists for today\r\n    const existing = await prisma.statSnapshot.findFirst({\r\n        where: {\r\n            entityType,\r\n            entityId,\r\n            metricKey,\r\n            date: today,\r\n        },\r\n    })\r\n\r\n    if (!existing) {\r\n        await prisma.statSnapshot.create({\r\n            data: {\r\n                entityType,\r\n                entityId,\r\n                metricKey,\r\n                value: currentValue,\r\n                date: today,\r\n            },\r\n        })\r\n    } else if (existing.value !== currentValue) {\r\n        // Update if value changed today (optional, but good for accuracy)\r\n        await prisma.statSnapshot.update({\r\n            where: { id: existing.id },\r\n            data: { value: currentValue },\r\n        })\r\n    }\r\n}\r\n\r\n/**\r\n * Calculates trend based on current value and a previous snapshot.\r\n */\r\nexport async function getStatTrend(\r\n    entityType: string,\r\n    entityId: number | null,\r\n    metricKey: string,\r\n    currentValue: number,\r\n    period: \"daily\" | \"weekly\" = \"daily\"\r\n): Promise<StatTrend | null> {\r\n    const today = startOfDay(new Date())\r\n    let compareDate: Date\r\n\r\n    if (period === \"daily\") {\r\n        compareDate = subDays(today, 1) // Yesterday\r\n    } else {\r\n        compareDate = subWeeks(today, 1) // Last week\r\n    }\r\n\r\n    // Capture current state if needed (side effect, or separate job)\r\n    // We'll capture it here to ensure we have data for tomorrow\r\n    await captureDailySnapshot(entityType, entityId, metricKey, currentValue)\r\n\r\n    // Find the closest snapshot to the compare date\r\n    // We look for one created on that day\r\n    const snapshot = await prisma.statSnapshot.findFirst({\r\n        where: {\r\n            entityType,\r\n            entityId,\r\n            metricKey,\r\n            date: compareDate, // Precise match for day\r\n        },\r\n    })\r\n\r\n    if (!snapshot) {\r\n        // Try to find ANY snapshot before today if exact match fails\r\n        const lastSnapshot = await prisma.statSnapshot.findFirst({\r\n            where: {\r\n                entityType,\r\n                entityId,\r\n                metricKey,\r\n                date: { lt: today }\r\n            },\r\n            orderBy: { date: 'desc' }\r\n        })\r\n\r\n        if (!lastSnapshot) return null // No historical data\r\n\r\n        // Use the most recent prior snapshot for comparison if no exact match\r\n        // This handles gaps in data\r\n        return calculateTrend(currentValue, lastSnapshot.value)\r\n    }\r\n\r\n    return calculateTrend(currentValue, snapshot.value)\r\n}\r\n\r\nfunction calculateTrend(current: number, previous: number): StatTrend {\r\n    if (previous === 0) {\r\n        return {\r\n            direction: current > 0 ? \"up\" : \"neutral\",\r\n            value: current,\r\n            percentage: current > 0 ? 100 : 0\r\n        }\r\n    }\r\n\r\n    const diff = current - previous\r\n    const percentage = Math.round((diff / previous) * 100)\r\n\r\n    let direction: TrendDirection = \"neutral\"\r\n    if (diff > 0) direction = \"up\"\r\n    if (diff < 0) direction = \"down\"\r\n\r\n    return {\r\n        direction,\r\n        value: Math.abs(diff),\r\n        percentage: Math.abs(percentage),\r\n    }\r\n}\r\n","import { addDays } from \"./addDays.js\";\n\n/**\n * The {@link addWeeks} function options.\n */\n\n/**\n * @name addWeeks\n * @category Week Helpers\n * @summary Add the specified number of weeks to the given date.\n *\n * @description\n * Add the specified number of weeks to the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of weeks to be added.\n * @param options - An object with options\n *\n * @returns The new date with the weeks added\n *\n * @example\n * // Add 4 weeks to 1 September 2014:\n * const result = addWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Sep 29 2014 00:00:00\n */\nexport function addWeeks(date, amount, options) {\n  return addDays(date, amount * 7, options);\n}\n\n// Fallback for modularized imports:\nexport default addWeeks;\n","import { addWeeks } from \"./addWeeks.js\";\n\n/**\n * The {@link subWeeks} function options.\n */\n\n/**\n * @name subWeeks\n * @category Week Helpers\n * @summary Subtract the specified number of weeks from the given date.\n *\n * @description\n * Subtract the specified number of weeks from the given date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param date - The date to be changed\n * @param amount - The amount of weeks to be subtracted.\n * @param options - An object with options\n *\n * @returns The new date with the weeks subtracted\n *\n * @example\n * // Subtract 4 weeks from 1 September 2014:\n * const result = subWeeks(new Date(2014, 8, 1), 4)\n * //=> Mon Aug 04 2014 00:00:00\n */\nexport function subWeeks(date, amount, options) {\n  return addWeeks(date, -amount, options);\n}\n\n// Fallback for modularized imports:\nexport default subWeeks;\n","\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { startOfDay, endOfDay } from \"date-fns\"\r\nimport { hasPermissionWithoutRoleBypass } from \"@/lib/rbac-helpers\"\r\nimport { unstable_cache } from \"next/cache\"\r\n\r\nexport type ProjectStats = {\r\n    totalTasks: number\r\n    completedTasks: number\r\n    inProgressTasks: number\r\n    blockedTasks: number\r\n    overdueTasks: number\r\n    urgentTasks: number // Optional as per requirements, but good to have\r\n}\r\n\r\nexport type TaskStats = {\r\n    totalTasks: number\r\n    myTasks: number\r\n    todayTasks: number\r\n    blockedTasks: number\r\n    overdueTasks: number\r\n    completedToday: number\r\n    totalCompletedTasks: number\r\n}\r\n\r\n// Helper to get formatted date for debugging\r\nconst formatDate = (date: Date) => date.toISOString().split('T')[0]\r\n\r\n// EXTRACTED LOGIC FOR CACHING\r\nconst fetchProjectStats = async (projectId: number) => {\r\n    try {\r\n        // OPTIMIZED: Use single aggregation query instead of 6 separate count queries\r\n        const taskStats = await prisma.task.aggregate({\r\n            where: { projectId },\r\n            _count: {\r\n                id: true\r\n            }\r\n        })\r\n\r\n        const [\r\n            completedTasks,\r\n            inProgressTasks,\r\n            blockedTasks,\r\n            overdueTasks,\r\n            urgentTasks\r\n        ] = await Promise.all([\r\n            // Completed Tasks (Final Status or legacy \"completed\")\r\n            prisma.task.count({\r\n                where: {\r\n                    projectId,\r\n                    OR: [\r\n                        { taskStatus: { isFinal: true } },\r\n                        { status: \"completed\", taskStatusId: null }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // In Progress Tasks (Not pending, not completed/final)\r\n            prisma.task.count({\r\n                where: {\r\n                    projectId,\r\n                    OR: [\r\n                        // Logic: Active tasks that are not blocking or final\r\n                        {\r\n                            taskStatus: {\r\n                                isFinal: false,\r\n                                // Assuming \"In Progress\" implies it's started. \r\n                                // Alternatively, anything not final is \"active\". \r\n                                // Let's simplify: Anything NOT final and NOT legacy pending/completed\r\n                            }\r\n                        },\r\n                        { status: \"in_progress\", taskStatusId: null }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Blocked Tasks (Blocking Status or legacy \"waiting\")\r\n            prisma.task.count({\r\n                where: {\r\n                    projectId,\r\n                    OR: [\r\n                        { taskStatus: { isBlocking: true } },\r\n                        { status: \"waiting\", taskStatusId: null }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Overdue Tasks (Due date passed, not final)\r\n            prisma.task.count({\r\n                where: {\r\n                    projectId,\r\n                    dueDate: { lt: new Date() },\r\n                    OR: [\r\n                        { taskStatus: { isFinal: false } },\r\n                        { status: { not: \"completed\" }, taskStatusId: null }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Urgent Tasks (Priority is urgent or high)\r\n            prisma.task.count({\r\n                where: {\r\n                    projectId,\r\n                    priority: { in: [\"high\", \"urgent\"] },\r\n                    // Only active tasks\r\n                    OR: [\r\n                        { taskStatus: { isFinal: false } },\r\n                        { status: { not: \"completed\" }, taskStatusId: null }\r\n                    ]\r\n                }\r\n            }),\r\n        ])\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                totalTasks: taskStats._count.id,\r\n                completedTasks,\r\n                inProgressTasks,\r\n                blockedTasks,\r\n                overdueTasks,\r\n                urgentTasks\r\n            }\r\n        }\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Error fetching project stats:\", error)\r\n        return { success: false, error: error.message }\r\n    }\r\n}\r\n\r\n// Cache wrapper for specific project stats\r\nconst getCachedProjectStats = unstable_cache(\r\n    fetchProjectStats,\r\n    ['project-stats'],\r\n    { revalidate: 60, tags: ['project-stats'] }\r\n)\r\n\r\nexport async function getProjectStats(projectId: number): Promise<{ success: boolean; data?: ProjectStats; error?: string }> {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { success: false, error: \"Unauthorized\" }\r\n\r\n    // Use cached version\r\n    // We pass projectId as part of arguments which unstable_cache uses for key generation\r\n    return await getCachedProjectStats(projectId)\r\n}\r\n\r\n// EXTRACT LOGIC FOR ALL PROJECTS STATS\r\nconst fetchAllProjectsStats = async (userId: number, canViewAllProjects: boolean) => {\r\n    try {\r\n        const where: any = {}\r\n\r\n        // Permission Scope - Use RBAC instead of role check\r\n        if (!canViewAllProjects) {\r\n            where.OR = [\r\n                { projectManagerId: userId },\r\n                { createdById: userId },\r\n                { projectUsers: { some: { userId } } }\r\n            ]\r\n        }\r\n\r\n        // OPTIMIZED: Use groupBy aggregation to get all counts in 2 queries instead of 4\r\n        const [totalResult, statusCounts] = await Promise.all([\r\n            prisma.project.count({ where }),\r\n            prisma.project.groupBy({\r\n                by: ['status', 'projectStatusId'],\r\n                where,\r\n                _count: { id: true }\r\n            })\r\n        ])\r\n\r\n        let active = 0\r\n        let completed = 0\r\n        let urgent = 0\r\n\r\n        // Process status counts\r\n        for (const group of statusCounts) {\r\n            if (group.status === \"active\" || group.status === null) {\r\n                active += group._count.id\r\n            }\r\n            if (group.status === \"completed\") {\r\n                completed += group._count.id\r\n            }\r\n        }\r\n\r\n        // Count urgent projects separately\r\n        urgent = await prisma.project.count({\r\n            where: {\r\n                ...where,\r\n                priority: \"urgent\"\r\n            }\r\n        })\r\n\r\n        return {\r\n            success: true,\r\n            data: { total: totalResult, active, completed, urgent }\r\n        }\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Error fetching all projects stats:\", error)\r\n        return { success: false, error: error.message }\r\n    }\r\n}\r\n\r\n// Cache wrapper for all projects stats\r\n// We need to pivot on userId if they can't view all projects\r\n// If they can view all, we can theoretically share the cache if we used a constant key, \r\n// BUT 'canViewAllProjects' logic is user-dependent anyway. cache key should include userId if limited scope.\r\nconst getCachedAllProjectsStats = unstable_cache(\r\n    fetchAllProjectsStats,\r\n    ['all-projects-stats'],\r\n    { revalidate: 60, tags: ['projects-stats'] }\r\n)\r\n\r\nexport async function getAllProjectsStats(): Promise<{ success: boolean; data?: { total: number; active: number; completed: number; urgent: number }; error?: string }> {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { success: false, error: \"Unauthorized\" }\r\n\r\n    const userId = parseInt(session.user.id)\r\n    const canViewAllProjects = await hasPermissionWithoutRoleBypass(\r\n        userId,\r\n        \"project.viewAll\"\r\n    )\r\n\r\n    return await getCachedAllProjectsStats(userId, canViewAllProjects)\r\n}\r\n\r\nexport type TaskFilters = {\r\n    projectId?: string | number | string[] | number[]\r\n    statusId?: string | number | string[] | number[]\r\n    priority?: string | string[]\r\n    dateRange?: { from: Date; to: Date }\r\n    assigneeId?: string | number // For \"My Tasks\" context if needed explicitly\r\n    search?: string\r\n}\r\n\r\nconst fetchTaskStats = async (userId: number, isAdmin: boolean, filters: TaskFilters) => {\r\n    try {\r\n        const todayStart = startOfDay(new Date())\r\n        const todayEnd = endOfDay(new Date())\r\n\r\n        // Build generic where clause based on filters & permissions\r\n        const where: any = {}\r\n\r\n        // Permission Scope\r\n        if (!isAdmin) {\r\n            where.project = {\r\n                OR: [\r\n                    { projectManagerId: userId },\r\n                    { createdById: userId },\r\n                    { projectUsers: { some: { userId } } }\r\n                ]\r\n            }\r\n        }\r\n\r\n        // Apply Filters\r\n\r\n        // Project Filter\r\n        if (filters.projectId && filters.projectId !== \"all\") {\r\n            const projectIds = Array.isArray(filters.projectId)\r\n                ? filters.projectId.map(id => parseInt(id.toString()))\r\n                : [parseInt(filters.projectId.toString())]\r\n\r\n            if (projectIds.length > 0) {\r\n                where.projectId = { in: projectIds }\r\n            }\r\n        }\r\n\r\n        // RE-COMPUTING WHERE PROPERLY TO HANDLE MULTIPLE OR GROUPS (Status, Search)\r\n        // Resetting the dynamic parts\r\n        const baseWhere: any = { ...where }\r\n        delete baseWhere.OR\r\n        delete baseWhere.AND\r\n\r\n        const andConditions: any[] = []\r\n        if (where.project) andConditions.push({ project: where.project }) // Permissions\r\n        if (where.projectId) andConditions.push({ projectId: where.projectId })\r\n        if (where.priority) andConditions.push({ priority: where.priority })\r\n        if (where.dueDate) andConditions.push({ dueDate: where.dueDate })\r\n\r\n        // Priority Filter\r\n        if (filters.priority && filters.priority.length > 0) {\r\n            const priorities = Array.isArray(filters.priority) ? filters.priority : [filters.priority]\r\n            if (priorities.length > 0) {\r\n                andConditions.push({ priority: { in: priorities } })\r\n            }\r\n        }\r\n\r\n\r\n        // Status Group\r\n        if (filters.statusId && filters.statusId !== \"all\") {\r\n            const statuses = Array.isArray(filters.statusId) ? filters.statusId : [filters.statusId]\r\n            const statusIds: number[] = []\r\n            const legacyStatuses: string[] = []\r\n\r\n            statuses.forEach(s => {\r\n                if (s === \"legacy_active\") legacyStatuses.push(\"active\")\r\n                else if (s === \"legacy_on_hold\") legacyStatuses.push(\"on_hold\")\r\n                else if (typeof s === 'string' && isNaN(parseInt(s))) legacyStatuses.push(s)\r\n                else statusIds.push(parseInt(s.toString()))\r\n            })\r\n\r\n            const statusConditions: any[] = []\r\n            if (statusIds.length > 0) statusConditions.push({ taskStatusId: { in: statusIds } })\r\n            if (legacyStatuses.length > 0) statusConditions.push({ status: { in: legacyStatuses }, taskStatusId: null })\r\n\r\n            if (statusConditions.length > 0) {\r\n                andConditions.push({ OR: statusConditions })\r\n            }\r\n        }\r\n\r\n        // Search Group\r\n        if (filters.search) {\r\n            andConditions.push({\r\n                OR: [\r\n                    { title: { contains: filters.search } },\r\n                    { description: { contains: filters.search } }\r\n                ]\r\n            })\r\n        }\r\n\r\n        if (filters.dateRange) {\r\n            if (filters.dateRange.from || filters.dateRange.to) {\r\n                const dateCondition: any = {}\r\n                if (filters.dateRange.from) dateCondition.gte = filters.dateRange.from\r\n                if (filters.dateRange.to) dateCondition.lte = filters.dateRange.to\r\n                andConditions.push({ dueDate: dateCondition })\r\n            }\r\n        }\r\n\r\n        const finalWhere = {\r\n            AND: andConditions\r\n        }\r\n\r\n        const [\r\n            totalTasks,\r\n            myTasks,\r\n            todayTasks,\r\n            blockedTasks,\r\n            overdueTasks,\r\n            completedToday,\r\n            totalCompletedTasks\r\n        ] = await Promise.all([\r\n            // Total (Filtered)\r\n            prisma.task.count({ where: finalWhere }),\r\n\r\n            // My Tasks (Filtered + Assigned to Me)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        { assignees: { some: { id: userId } } }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Today's Tasks (Filtered + Planned for Today + Active)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        {\r\n                            plannedDate: {\r\n                                gte: todayStart,\r\n                                lte: todayEnd\r\n                            }\r\n                        },\r\n                        {\r\n                            OR: [\r\n                                { taskStatus: { isFinal: false } },\r\n                                { status: { not: \"completed\" }, taskStatusId: null }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Blocked Tasks (Filtered + Blocking status)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        {\r\n                            OR: [\r\n                                { taskStatus: { isBlocking: true } },\r\n                                { status: \"waiting\", taskStatusId: null }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Overdue Tasks (Filtered + Overdue + Active)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        { dueDate: { lt: new Date() } },\r\n                        {\r\n                            OR: [\r\n                                { taskStatus: { isFinal: false } },\r\n                                { status: { not: \"completed\" }, taskStatusId: null }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Completed Today (Filtered + Updated/Completed Today)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        {\r\n                            updatedAt: {\r\n                                gte: todayStart,\r\n                                lte: todayEnd\r\n                            }\r\n                        },\r\n                        {\r\n                            OR: [\r\n                                { taskStatus: { isFinal: true } },\r\n                                { status: \"completed\", taskStatusId: null }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            }),\r\n\r\n            // Total Completed Tasks (Filtered + Completed Status)\r\n            prisma.task.count({\r\n                where: {\r\n                    AND: [\r\n                        ...andConditions,\r\n                        {\r\n                            OR: [\r\n                                { taskStatus: { isFinal: true } },\r\n                                { status: \"completed\", taskStatusId: null }\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            })\r\n        ])\r\n\r\n        return {\r\n            success: true,\r\n            data: {\r\n                totalTasks,\r\n                myTasks,\r\n                todayTasks,\r\n                blockedTasks,\r\n                overdueTasks,\r\n                completedToday,\r\n                totalCompletedTasks\r\n            }\r\n        }\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Error fetching task stats:\", error)\r\n        return { success: false, error: error.message }\r\n    }\r\n}\r\n\r\n// NOTE: Caching generic task stats with filters is hard because filters can be anything.\r\n// We only cache if filters are empty or minimal to avoid exploding cache storage.\r\n// For now, we DO NOT cache getTaskStats when filters are involved, or we accept that it's live.\r\n// Only caching the \"base\" dashboard stats.\r\n// Actually, `getSummaryStatsWithTrends` uses this with filters. \r\n// If filters are complex, we might not want to cache. \r\n// Let's caching logic be smart: if filters is empty object, cache.\r\n\r\nexport async function getTaskStats(filters: TaskFilters = {}): Promise<{ success: boolean; data?: TaskStats; error?: string }> {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { success: false, error: \"Unauthorized\" }\r\n\r\n    const userId = parseInt(session.user.id)\r\n    const userRole = session.user.role || \"developer\"\r\n    const isAdmin = userRole === \"admin\"\r\n\r\n    // If filters are complex, skip cache for now to avoid stale search results\r\n    const hasSearchOrDate = filters.search || (filters.dateRange && (filters.dateRange.from || filters.dateRange.to));\r\n\r\n    if (hasSearchOrDate) {\r\n        return await fetchTaskStats(userId, isAdmin, filters);\r\n    }\r\n\r\n    // Use unstable_cache for filtered stats could key on JSON.stringify(filters)\r\n    // Be careful with object key order.\r\n    // Let's trust that identical filter objects produce identical strings if keys are stable.\r\n    // We can rely on 'unstable_cache' variadic args.\r\n\r\n    // We need to pass filters as arguments to cache function\r\n    // But filters object structure might vary. \r\n    // Let's create a specific key for 'basic' filters (project, status, priority)\r\n\r\n    const cacheKey = `task-stats-${JSON.stringify(filters)}`;\r\n\r\n    // Inline wrapper for this specific call with these filters\r\n    // This creates a NEW cache entry for every permutation.\r\n    // This is fine as long as permutations are reasonable (status buttons etc).\r\n    const cachedFetch = unstable_cache(\r\n        async (uid, admin, f) => fetchTaskStats(uid, admin, f),\r\n        ['task-stats-filtered'],\r\n        { revalidate: 30, tags: ['task-stats'] } // Short cache for filters\r\n    );\r\n\r\n    return await cachedFetch(userId, isAdmin, filters);\r\n}\r\n\r\nimport { getStatTrend, StatWithTrend } from \"@/lib/stats\"\r\n\r\nexport async function getSummaryStatsWithTrends(\r\n    filters: TaskFilters = {},\r\n    period: \"daily\" | \"weekly\" = \"daily\"\r\n): Promise<{ success: boolean; data?: Record<string, StatWithTrend>; error?: string }> {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { success: false, error: \"Unauthorized\" }\r\n\r\n    try {\r\n        const [projectStatsResult, taskStatsResult] = await Promise.all([\r\n            getAllProjectsStats(),\r\n            getTaskStats(filters)\r\n        ])\r\n\r\n        if (!projectStatsResult.success || !taskStatsResult.success) {\r\n            throw new Error(projectStatsResult.error || taskStatsResult.error || \"Failed to fetch stats\")\r\n        }\r\n\r\n        const projectData = projectStatsResult.data!\r\n        const taskData = taskStatsResult.data!\r\n\r\n        // Determine Entity Context for Snapshots\r\n        let entityType = \"global\"\r\n        let entityId: number | null = null\r\n\r\n        // Simple logic: if projectId filter is set, use it.\r\n        // Note: filters.projectId can be array or 'all'.\r\n        if (filters.projectId && filters.projectId !== \"all\" && !Array.isArray(filters.projectId)) {\r\n            // Check if it's a single ID\r\n            const pid = parseInt(filters.projectId.toString())\r\n            if (!isNaN(pid)) {\r\n                entityType = \"project\"\r\n                entityId = pid\r\n            }\r\n        }\r\n\r\n        // Metrics to track\r\n        const metrics = {\r\n            total_projects: projectData.total,\r\n            active_projects: projectData.active,\r\n            total_tasks: taskData.totalTasks,\r\n            completed_tasks: taskData.totalCompletedTasks,\r\n            overdue_tasks: taskData.overdueTasks,\r\n            blocked_tasks: taskData.blockedTasks\r\n        }\r\n\r\n        const trends: Record<string, StatWithTrend> = {}\r\n\r\n        for (const [key, value] of Object.entries(metrics)) {\r\n            // Only fetch trends if we have a valid context (Global or Single Project)\r\n            // If complex filters are applied (e.g. search, multiple projects), trends might be misleading if snapshots are not filtered similarly.\r\n            // For now, allow trends if entityType is explicitly defined.\r\n\r\n            // Note: If filters.statusId etc are set, 'value' is filtered, but 'snapshot' is likely global/project level.\r\n            // Comparison might be invalid: Filtered Value vs Unfiltered Snapshot.\r\n            // Constraint: Only show trends if filters are empty OR (only projectId is set).\r\n\r\n            const hasComplexFilters =\r\n                (filters.statusId && filters.statusId !== 'all') ||\r\n                filters.search ||\r\n                filters.priority ||\r\n                filters.dateRange;\r\n\r\n            let trend = null\r\n            if (!hasComplexFilters) {\r\n                trend = await getStatTrend(entityType, entityId, key, value, period)\r\n            }\r\n\r\n            trends[key] = {\r\n                value,\r\n                trend\r\n            }\r\n        }\r\n\r\n        return { success: true, data: trends }\r\n\r\n    } catch (error: any) {\r\n        console.error(\"Error fetching summary stats with trends:\", error)\r\n        return { success: false, error: error.message }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,9,10]}