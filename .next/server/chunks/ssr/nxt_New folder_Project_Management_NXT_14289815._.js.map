{"version":3,"sources":["../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/project-notifications.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/.next-internal/server/app/dashboard/projects/%5Bid%5D/notifications/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { revalidatePath } from \"next/cache\"\r\n\r\n// Get all notifications for a project (paginated)\r\nexport async function getProjectNotifications(\r\n  projectId: number,\r\n  filters?: {\r\n    type?: string\r\n    isRead?: boolean\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null, // User is still active in the project\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    const limit = filters?.limit || 20\r\n    const offset = filters?.offset || 0\r\n\r\n    const where: any = {\r\n      projectId,\r\n      userId,\r\n    }\r\n\r\n    if (filters?.type) {\r\n      where.type = filters.type\r\n    }\r\n\r\n    if (filters?.isRead !== undefined) {\r\n      where.isRead = filters.isRead\r\n    }\r\n\r\n    const [notifications, total] = await Promise.all([\r\n      prisma.projectNotification.findMany({\r\n        where,\r\n        orderBy: [\r\n          { isUrgent: \"desc\" },\r\n          { requiresAcknowledgment: \"desc\" },\r\n          { createdAt: \"desc\" }\r\n        ],\r\n        take: limit,\r\n        skip: offset,\r\n      }),\r\n      prisma.projectNotification.count({ where }),\r\n    ])\r\n\r\n    return {\r\n      success: true,\r\n      notifications,\r\n      total,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching project notifications:\", error)\r\n    return { success: false, error: \"Failed to fetch notifications\" }\r\n  }\r\n}\r\n\r\n// Get total unread notification count across all projects for a user\r\nexport async function getAllProjectsUnreadNotificationCount() {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Get all projects the user is part of OR has tasks assigned to\r\n    const projectUsers = await prisma.projectUser.findMany({\r\n      where: {\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n      select: { projectId: true },\r\n    })\r\n\r\n    // Also get projects where user has assigned tasks\r\n    let tasksWithProjects: { projectId: number }[] = []\r\n    try {\r\n      tasksWithProjects = await prisma.task.findMany({\r\n        where: {\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        },\r\n        select: {\r\n          projectId: true\r\n        }\r\n      })\r\n    } catch (error: any) {\r\n      // If task model is not available, just use projectUsers\r\n      console.warn(\"[Notifications] Could not fetch tasks, using only ProjectUser:\", error?.message)\r\n      tasksWithProjects = []\r\n    }\r\n\r\n    const projectIdsFromUsers = projectUsers.map((pu) => pu.projectId)\r\n    const projectIdsFromTasks = tasksWithProjects.map(t => t.projectId)\r\n    // Remove duplicates using Set\r\n    const allProjectIds = [...new Set([...projectIdsFromUsers, ...projectIdsFromTasks])]\r\n\r\n    if (allProjectIds.length === 0) {\r\n      return { success: true, count: 0 }\r\n    }\r\n\r\n    let count = 0\r\n    try {\r\n      count = await prisma.projectNotification.count({\r\n        where: {\r\n          projectId: { in: allProjectIds },\r\n          userId,\r\n          isRead: false,\r\n        },\r\n      })\r\n    } catch (error: any) {\r\n      // If ProjectNotification model is not available, return 0\r\n      console.error(\"[Notifications] ProjectNotification model not available. Please run 'npx prisma generate':\", error?.message)\r\n      return { success: true, count: 0 }\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      count,\r\n    }\r\n  } catch (error: any) {\r\n    console.error(\"Error fetching all projects unread count:\", error)\r\n    console.error(\"Error details:\", {\r\n      message: error?.message,\r\n      stack: error?.stack,\r\n      name: error?.name\r\n    })\r\n    return {\r\n      success: false,\r\n      error: error?.message || \"Failed to fetch unread count\",\r\n      details: error?.stack\r\n    }\r\n  }\r\n}\r\n\r\n// Get recent notifications across all projects for a user\r\nexport async function getAllProjectsNotifications(limit: number = 15) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Get all projects the user is part of OR has tasks assigned to\r\n    const projectUsers = await prisma.projectUser.findMany({\r\n      where: {\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n      select: { projectId: true },\r\n    })\r\n\r\n    // Also get projects where user has assigned tasks\r\n    let tasksWithProjects: { projectId: number }[] = []\r\n    try {\r\n      tasksWithProjects = await prisma.task.findMany({\r\n        where: {\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        },\r\n        select: {\r\n          projectId: true\r\n        }\r\n      })\r\n    } catch (error: any) {\r\n      // If task model is not available, just use projectUsers\r\n      console.warn(\"[Notifications] Could not fetch tasks, using only ProjectUser:\", error?.message)\r\n      tasksWithProjects = []\r\n    }\r\n\r\n    const projectIdsFromUsers = projectUsers.map((pu) => pu.projectId)\r\n    const projectIdsFromTasks = tasksWithProjects.map(t => t.projectId)\r\n    // Remove duplicates using Set\r\n    const allProjectIds = [...new Set([...projectIdsFromUsers, ...projectIdsFromTasks])]\r\n\r\n    console.log(`[Notifications] User ${userId} has access to projects:`, allProjectIds)\r\n\r\n    if (allProjectIds.length === 0) {\r\n      console.log(`[Notifications] No projects found for user ${userId}`)\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    // Check if ProjectNotification model exists\r\n    if (!prisma.projectNotification) {\r\n      console.error(\"[Notifications] ProjectNotification model not found. Please run 'npx prisma generate'\")\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    let notifications: any[] = []\r\n    try {\r\n      notifications = await prisma.projectNotification.findMany({\r\n        where: {\r\n          projectId: { in: allProjectIds },\r\n          userId,\r\n        },\r\n        include: {\r\n          project: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n        orderBy: { createdAt: \"desc\" },\r\n        take: limit,\r\n      })\r\n    } catch (error: any) {\r\n      // If ProjectNotification model is not available, return empty array\r\n      console.error(\"[Notifications] Error accessing ProjectNotification model. Please run 'npx prisma generate':\", error?.message)\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    console.log(`[Notifications] Found ${notifications.length} notifications for user ${userId}`)\r\n\r\n    return {\r\n      success: true,\r\n      notifications,\r\n    }\r\n  } catch (error: any) {\r\n    console.error(\"Error fetching all projects notifications:\", error)\r\n    console.error(\"Error details:\", {\r\n      message: error?.message,\r\n      stack: error?.stack,\r\n      name: error?.name\r\n    })\r\n    return {\r\n      success: false,\r\n      error: error?.message || \"Failed to fetch notifications\",\r\n      details: error?.stack\r\n    }\r\n  }\r\n}\r\n\r\n// Get unread notification count for a project\r\nexport async function getProjectUnreadNotificationCount(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    const count = await prisma.projectNotification.count({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        isRead: false,\r\n      },\r\n    })\r\n\r\n    return {\r\n      success: true,\r\n      count,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching unread count:\", error)\r\n    return { success: false, error: \"Failed to fetch unread count\" }\r\n  }\r\n}\r\n\r\n// Mark a notification as read\r\nexport async function markProjectNotificationAsRead(\r\n  projectId: number,\r\n  notificationId: number\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify notification belongs to user and project\r\n    const notification = await prisma.projectNotification.findFirst({\r\n      where: {\r\n        id: notificationId,\r\n        projectId,\r\n        userId,\r\n      },\r\n    })\r\n\r\n    if (!notification) {\r\n      return { success: false, error: \"Notification not found\" }\r\n    }\r\n\r\n    // Prevent marking urgent notifications that require acknowledgment as read\r\n    // They can only be marked as read after acknowledgment\r\n    if (notification.isUrgent && notification.requiresAcknowledgment && !notification.acknowledgedAt) {\r\n      return {\r\n        success: false,\r\n        error: \"Urgent notifications cannot be marked as read until acknowledged. Please acknowledge the urgent project first.\"\r\n      }\r\n    }\r\n\r\n    await prisma.projectNotification.update({\r\n      where: { id: notificationId },\r\n      data: { isRead: true },\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error marking notification as read:\", error)\r\n    return { success: false, error: \"Failed to mark notification as read\" }\r\n  }\r\n}\r\n\r\n// Mark all project notifications as read\r\nexport async function markAllProjectNotificationsAsRead(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    // Don't mark urgent notifications that require acknowledgment as read\r\n    await prisma.projectNotification.updateMany({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        isRead: false,\r\n        OR: [\r\n          { isUrgent: false },\r\n          { requiresAcknowledgment: false },\r\n          { acknowledgedAt: { not: null } }\r\n        ]\r\n      },\r\n      data: {\r\n        isRead: true,\r\n      },\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error marking all notifications as read:\", error)\r\n    return { success: false, error: \"Failed to mark all notifications as read\" }\r\n  }\r\n}\r\n\r\n// Get user's notification preferences for a project\r\nexport async function getProjectNotificationPreferences(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    let preferences = await prisma.projectNotificationPreference.findUnique({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n    })\r\n\r\n    // Create default preferences if they don't exist\r\n    if (!preferences) {\r\n      preferences = await prisma.projectNotificationPreference.create({\r\n        data: {\r\n          projectId,\r\n          userId,\r\n          soundEnabled: true,\r\n          taskNotifications: true,\r\n          dependencyNotifications: true,\r\n          todayTaskNotifications: true,\r\n          projectAdminNotifications: true,\r\n        },\r\n      })\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      preferences,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching notification preferences:\", error)\r\n    return { success: false, error: \"Failed to fetch preferences\" }\r\n  }\r\n}\r\n\r\n// Update user's notification preferences for a project\r\nexport async function updateProjectNotificationPreferences(\r\n  projectId: number,\r\n  preferences: {\r\n    soundEnabled?: boolean\r\n    taskNotifications?: boolean\r\n    dependencyNotifications?: boolean\r\n    todayTaskNotifications?: boolean\r\n    projectAdminNotifications?: boolean\r\n  }\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    await prisma.projectNotificationPreference.upsert({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n      create: {\r\n        projectId,\r\n        userId,\r\n        soundEnabled: preferences.soundEnabled ?? true,\r\n        taskNotifications: preferences.taskNotifications ?? true,\r\n        dependencyNotifications: preferences.dependencyNotifications ?? true,\r\n        todayTaskNotifications: preferences.todayTaskNotifications ?? true,\r\n        projectAdminNotifications: preferences.projectAdminNotifications ?? true,\r\n      },\r\n      update: preferences,\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error updating notification preferences:\", error)\r\n    return { success: false, error: \"Failed to update preferences\" }\r\n  }\r\n}\r\n\r\n// Create a project notification (internal use)\r\nexport async function createProjectNotification(\r\n  projectId: number,\r\n  userId: number,\r\n  options: {\r\n    type: string\r\n    entityType: string\r\n    entityId: number | null\r\n    title: string\r\n    message: string\r\n    soundRequired?: boolean\r\n    isUrgent?: boolean\r\n    requiresAcknowledgment?: boolean\r\n  }\r\n) {\r\n  const {\r\n    type,\r\n    entityType,\r\n    entityId,\r\n    title,\r\n    message,\r\n    soundRequired = false,\r\n    isUrgent = false,\r\n    requiresAcknowledgment = false\r\n  } = options\r\n  try {\r\n    // Verify user is part of the project OR assigned to a task in the project\r\n    let projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    // If user is not in ProjectUser, check if they're assigned to a task in this project\r\n    if (!projectUser && (entityType === \"task\" || entityType === \"comment_mention\") && entityId) {\r\n      const task = await prisma.task.findFirst({\r\n        where: {\r\n          id: entityId,\r\n          projectId,\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        }\r\n      })\r\n\r\n      if (task) {\r\n        // User is assigned to a task in this project, so they should receive notifications\r\n        // Optionally, we could auto-add them to ProjectUser here, but for now we'll just allow the notification\r\n        projectUser = null // We'll allow notification even without ProjectUser entry\r\n      } else {\r\n        // User is not assigned to this task and not in project\r\n        return { success: false, error: \"User not in project or assigned to task\" }\r\n      }\r\n    } else if (!projectUser && entityType === \"comment\" && entityId) {\r\n      // For comments, check if user is assigned to the task the comment is on\r\n      const comment = await prisma.comment.findUnique({\r\n        where: { id: entityId },\r\n        select: { taskId: true }\r\n      })\r\n\r\n      if (comment && comment.taskId) {\r\n        const task = await prisma.task.findFirst({\r\n          where: {\r\n            id: comment.taskId,\r\n            projectId,\r\n            assignees: {\r\n              some: { id: userId }\r\n            }\r\n          }\r\n        })\r\n\r\n        if (task) {\r\n          projectUser = null // Allow notification\r\n        } else {\r\n          return { success: false, error: \"User not assigned to the task related to this comment\" }\r\n        }\r\n      } else {\r\n        return { success: false, error: \"Comment or related task not found\" }\r\n      }\r\n    } else if (!projectUser) {\r\n      // For non-task/non-comment notifications, user must be in ProjectUser\r\n      return { success: false, error: \"User not in project\" }\r\n    }\r\n\r\n    // Check user's notification preferences\r\n    const preferences = await prisma.projectNotificationPreference.findUnique({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n    })\r\n\r\n    // Determine if notification should be created based on preferences\r\n    let shouldNotify = true\r\n\r\n    if (!soundRequired) {\r\n      // Non-critical notifications respect user preferences\r\n      switch (type) {\r\n        case \"task\":\r\n          if (preferences && !preferences.taskNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"dependency\":\r\n          if (preferences && !preferences.dependencyNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"today_task\":\r\n          if (preferences && !preferences.todayTaskNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"project_admin\":\r\n          if (preferences && !preferences.projectAdminNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n      }\r\n    }\r\n    // Critical notifications (soundRequired = true) always notify\r\n\r\n    if (!shouldNotify) {\r\n      return { success: true, skipped: true }\r\n    }\r\n\r\n    const notification = await prisma.projectNotification.create({\r\n      data: {\r\n        projectId,\r\n        userId,\r\n        type,\r\n        entityType,\r\n        entityId,\r\n        title,\r\n        message,\r\n        soundRequired,\r\n        isUrgent,\r\n        requiresAcknowledgment,\r\n      },\r\n    })\r\n\r\n    console.log(`[Notifications] Created notification for user ${userId} in project ${projectId}:`, {\r\n      id: notification.id,\r\n      type,\r\n      title,\r\n      soundRequired\r\n    })\r\n\r\n    // Revalidate project pages\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return {\r\n      success: true,\r\n      notification,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error creating project notification:\", error)\r\n    return { success: false, error: \"Failed to create notification\" }\r\n  }\r\n}\r\n\r\n","export {getPublicSystemSettings as '0033db22356cbf8845a3517099b63dfc38d1147299'} from 'ACTIONS_MODULE0'\nexport {getAllProjectsUnreadNotificationCount as '00686a7231b739e4fe9b8305b757bc0e83827b9865'} from 'ACTIONS_MODULE1'\nexport {getAllProjectsNotifications as '4004a0aae390e2c1aeb900c79065f312ac43d90f8d'} from 'ACTIONS_MODULE1'\nexport {markProjectNotificationAsRead as '60691655a7ad6aec29ab9691d8571a0d380be93da1'} from 'ACTIONS_MODULE1'\nexport {getProjectNotifications as '60e11d18f808d2843f4d06a35ea4ad9027dd8b4de1'} from 'ACTIONS_MODULE1'\nexport {markAllProjectNotificationsAsRead as '40c086aae8b4c1ddec14829c213410ee4c5d2ec0b4'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":"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"}