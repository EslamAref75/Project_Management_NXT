{"version":3,"sources":["turbopack:///[project]/nxt/New folder/Project_Management_NXT/node_modules/openid-client/package.json","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/lib/rbac-helpers.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/lib/rbac.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/settings.ts"],"sourcesContent":["{\"name\":\"openid-client\",\"version\":\"5.7.1\",\"description\":\"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs\",\"keywords\":[\"auth\",\"authentication\",\"basic\",\"certified\",\"client\",\"connect\",\"dynamic\",\"electron\",\"hybrid\",\"identity\",\"implicit\",\"oauth\",\"oauth2\",\"oidc\",\"openid\",\"passport\",\"relying party\",\"strategy\"],\"homepage\":\"https://github.com/panva/openid-client\",\"repository\":\"panva/openid-client\",\"funding\":{\"url\":\"https://github.com/sponsors/panva\"},\"license\":\"MIT\",\"author\":\"Filip Skokan <panva.ip@gmail.com>\",\"exports\":{\"types\":\"./types/index.d.ts\",\"import\":\"./lib/index.mjs\",\"require\":\"./lib/index.js\"},\"main\":\"./lib/index.js\",\"types\":\"./types/index.d.ts\",\"files\":[\"lib\",\"types/index.d.ts\"],\"scripts\":{\"format\":\"npx prettier --loglevel silent --write ./lib ./test ./certification ./types\",\"test\":\"mocha test/**/*.test.js\"},\"dependencies\":{\"jose\":\"^4.15.9\",\"lru-cache\":\"^6.0.0\",\"object-hash\":\"^2.2.0\",\"oidc-token-hash\":\"^5.0.3\"},\"devDependencies\":{\"@types/node\":\"^16.18.106\",\"@types/passport\":\"^1.0.16\",\"base64url\":\"^3.0.1\",\"chai\":\"^4.5.0\",\"mocha\":\"^10.7.3\",\"nock\":\"^13.5.5\",\"prettier\":\"^2.8.8\",\"readable-mock-req\":\"^0.2.2\",\"sinon\":\"^9.2.4\",\"timekeeper\":\"^2.3.1\"},\"standard-version\":{\"scripts\":{\"postchangelog\":\"sed -i '' -e 's/### \\\\[/## [/g' CHANGELOG.md\"},\"types\":[{\"type\":\"feat\",\"section\":\"Features\"},{\"type\":\"fix\",\"section\":\"Fixes\"},{\"type\":\"chore\",\"hidden\":true},{\"type\":\"docs\",\"hidden\":true},{\"type\":\"style\",\"hidden\":true},{\"type\":\"refactor\",\"section\":\"Refactor\",\"hidden\":false},{\"type\":\"perf\",\"section\":\"Performance\",\"hidden\":false},{\"type\":\"test\",\"hidden\":true}]}}","/**\r\n * RBAC Helper Functions - Proper Authorization Without Role Bypasses\r\n * \r\n * These functions ensure that all permission checks go through the RBAC system,\r\n * preventing authorization bypasses from legacy role-based checks.\r\n */\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { hasPermission, clearPermissionCache } from \"@/lib/rbac\"\r\n\r\n/**\r\n * Custom error classes for authorization\r\n */\r\nexport class UnauthorizedError extends Error {\r\n  constructor(message: string, public code: string = \"UNAUTHORIZED\") {\r\n    super(message)\r\n    this.name = \"UnauthorizedError\"\r\n  }\r\n}\r\n\r\nexport class ForbiddenError extends Error {\r\n  constructor(message: string, public code: string = \"FORBIDDEN\") {\r\n    super(message)\r\n    this.name = \"ForbiddenError\"\r\n  }\r\n}\r\n\r\nexport class NotFoundError extends Error {\r\n  constructor(message: string, public code: string = \"NOT_FOUND\") {\r\n    super(message)\r\n    this.name = \"NotFoundError\"\r\n  }\r\n}\r\n\r\n/**\r\n * Require specific permission - throws UnauthorizedError if denied\r\n * This is the ONLY way to check permissions - no role-based bypasses\r\n *\r\n * @param userId - User ID to check\r\n * @param permission - Permission key (e.g., \"project.delete\")\r\n * @param projectId - Optional project ID for resource-scoped permissions\r\n * @throws UnauthorizedError if permission denied\r\n *\r\n * @example\r\n * await requirePermission(userId, \"project.delete\", projectId)\r\n */\r\nexport async function requirePermission(\r\n  userId: number,\r\n  permission: string,\r\n  projectId?: number\r\n): Promise<void> {\r\n  // Check permission through RBAC system ONLY\r\n  // No role checks, no bypasses\r\n  const allowed = await hasPermissionWithoutRoleBypass(userId, permission, projectId)\r\n\r\n  if (!allowed) {\r\n    throw new UnauthorizedError(`Permission denied: ${permission}`, \"PERMISSION_DENIED\")\r\n  }\r\n}\r\n\r\n/**\r\n * Require any of multiple permissions\r\n * Throws error if user has none of them\r\n *\r\n * @param userId - User ID\r\n * @param permissions - Array of permission keys\r\n * @param projectId - Optional project ID\r\n * @throws UnauthorizedError if all permissions denied\r\n */\r\nexport async function requireAnyPermission(\r\n  userId: number,\r\n  permissions: string[],\r\n  projectId?: number\r\n): Promise<void> {\r\n  // Check if user has at least one permission\r\n  for (const permission of permissions) {\r\n    const allowed = await hasPermissionWithoutRoleBypass(userId, permission, projectId)\r\n    if (allowed) return\r\n  }\r\n\r\n  throw new UnauthorizedError(\r\n    `Permission denied: requires one of [${permissions.join(\", \")}]`,\r\n    \"PERMISSION_DENIED\"\r\n  )\r\n}\r\n\r\n/**\r\n * Check permission WITHOUT role-based bypasses\r\n * This is the core RBAC check - pure permission system\r\n *\r\n * @param userId - User ID\r\n * @param permission - Permission key\r\n * @param projectId - Optional project ID\r\n * @returns true if user has the permission\r\n */\r\nexport async function hasPermissionWithoutRoleBypass(\r\n  userId: number,\r\n  permission: string,\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  // Check through RBAC system only\r\n  // The old hasPermission() function had bypasses for admin role\r\n  // We use a pure RBAC check here\r\n\r\n  try {\r\n    // Get user's roles and their permissions\r\n    const userRoles = await prisma.userRole.findMany({\r\n      where: {\r\n        userId,\r\n        OR: [\r\n          { scopeType: null }, // Global roles\r\n          { scopeType: \"global\" },\r\n          ...(projectId ? [{ scopeType: \"project\", scopeId: projectId }] : []),\r\n        ],\r\n      },\r\n      include: {\r\n        role: {\r\n          include: {\r\n            permissions: {\r\n              include: {\r\n                permission: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    })\r\n\r\n    // Check if any role has the permission\r\n    for (const userRole of userRoles) {\r\n      for (const rolePermission of userRole.role.permissions) {\r\n        if (rolePermission.permission.key === permission) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n\r\n    return false\r\n  } catch (error) {\r\n    console.error(`Error checking permission ${permission} for user ${userId}:`, error)\r\n    // Fail secure - deny access on error\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Verify user can access a project with specific permission\r\n * Throws error if project doesn't exist or user lacks permission\r\n *\r\n * @param userId - User ID\r\n * @param projectId - Project ID\r\n * @param permission - Permission key (e.g., \"project.delete\")\r\n * @throws NotFoundError if project doesn't exist\r\n * @throws UnauthorizedError if permission denied\r\n */\r\nexport async function verifyProjectAccess(\r\n  userId: number,\r\n  projectId: number,\r\n  permission: string\r\n): Promise<void> {\r\n  // 1. Verify project exists\r\n  const project = await prisma.project.findUnique({\r\n    where: { id: projectId },\r\n    select: { id: true },\r\n  })\r\n\r\n  if (!project) {\r\n    throw new NotFoundError(`Project ${projectId} not found`)\r\n  }\r\n\r\n  // 2. Check permission through RBAC (no bypasses)\r\n  const allowed = await hasPermissionWithoutRoleBypass(userId, permission, projectId)\r\n\r\n  if (!allowed) {\r\n    throw new UnauthorizedError(\r\n      `You don't have permission to ${permission} on this project`,\r\n      \"PROJECT_ACCESS_DENIED\"\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Verify user can access a task with specific permission\r\n * Throws error if task doesn't exist or user lacks permission\r\n *\r\n * @param userId - User ID\r\n * @param taskId - Task ID\r\n * @param permission - Permission key (e.g., \"task.update\")\r\n * @throws NotFoundError if task doesn't exist\r\n * @throws UnauthorizedError if permission denied\r\n */\r\nexport async function verifyTaskAccess(\r\n  userId: number,\r\n  taskId: number,\r\n  permission: string\r\n): Promise<void> {\r\n  // 1. Get task and its project\r\n  const task = await prisma.task.findUnique({\r\n    where: { id: taskId },\r\n    select: {\r\n      id: true,\r\n      projectId: true,\r\n    },\r\n  })\r\n\r\n  if (!task) {\r\n    throw new NotFoundError(`Task ${taskId} not found`)\r\n  }\r\n\r\n  // 2. Check permission on the project\r\n  // Tasks are scoped to projects, so we check project-level permissions\r\n  const allowed = await hasPermissionWithoutRoleBypass(userId, permission, task.projectId)\r\n\r\n  if (!allowed) {\r\n    throw new UnauthorizedError(\r\n      `You don't have permission to ${permission} on this task`,\r\n      \"TASK_ACCESS_DENIED\"\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Verify user is project owner/creator\r\n * Used for operations that should only be available to the creator\r\n *\r\n * @param userId - User ID\r\n * @param projectId - Project ID\r\n * @throws NotFoundError if project doesn't exist\r\n * @throws UnauthorizedError if not the creator\r\n */\r\nexport async function verifyProjectOwner(userId: number, projectId: number): Promise<void> {\r\n  const project = await prisma.project.findUnique({\r\n    where: { id: projectId },\r\n    select: { id: true, createdById: true },\r\n  })\r\n\r\n  if (!project) {\r\n    throw new NotFoundError(`Project ${projectId} not found`)\r\n  }\r\n\r\n  if (project.createdById !== userId) {\r\n    throw new UnauthorizedError(`You are not the owner of this project`, \"NOT_OWNER\")\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user is admin through RBAC (has admin role in system)\r\n * Does NOT grant automatic permissions - must still check individual permissions\r\n *\r\n * @param userId - User ID\r\n * @returns true if user has the \"admin\" role\r\n * @deprecated - Use specific permission checks instead\r\n */\r\nexport async function isAdminUser(userId: number): Promise<boolean> {\r\n  const adminRole = await prisma.userRole.findFirst({\r\n    where: {\r\n      userId,\r\n      role: {\r\n        name: \"admin\",\r\n      },\r\n    },\r\n  })\r\n\r\n  return !!adminRole\r\n}\r\n\r\n/**\r\n * Clear permission cache when user roles change\r\n * Must be called after updating user permissions/roles\r\n *\r\n * @param userId - User ID whose cache to clear\r\n * @param projectId - Optional project ID for project-scoped changes\r\n */\r\nexport function invalidateUserPermissionCache(userId: number, projectId?: number): void {\r\n  clearPermissionCache(userId, projectId)\r\n}\r\n\r\n/**\r\n * Clear all permission caches (use sparingly)\r\n */\r\nexport function invalidateAllPermissionCaches(): void {\r\n  clearPermissionCache(0, undefined) // This clears all caches\r\n}\r\n\r\n/**\r\n * Handle authorization errors in server actions\r\n *\r\n * @param error - Error thrown during authorization\r\n * @returns Response object with error details\r\n *\r\n * @example\r\n * try {\r\n *   await requirePermission(userId, 'project.delete')\r\n * } catch (error) {\r\n *   return handleAuthorizationError(error)\r\n * }\r\n */\r\nexport function handleAuthorizationError(\r\n  error: unknown\r\n): { error: string; code: string; status: number; success: false } {\r\n  if (error instanceof UnauthorizedError) {\r\n    return { error: error.message, code: error.code, status: 403, success: false }\r\n  }\r\n\r\n  if (error instanceof ForbiddenError) {\r\n    return { error: error.message, code: error.code, status: 403, success: false }\r\n  }\r\n\r\n  if (error instanceof NotFoundError) {\r\n    return { error: error.message, code: error.code, status: 404, success: false }\r\n  }\r\n\r\n  console.error(\"Unknown authorization error:\", error)\r\n  return {\r\n    error: \"Authorization failed\",\r\n    code: \"AUTHORIZATION_ERROR\",\r\n    status: 500,\r\n    success: false\r\n  }\r\n}\r\n","/**\r\n * RBAC Permission Checking Utilities\r\n */\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { PERMISSIONS } from \"./permissions\"\r\n\r\n/**\r\n * Cache for user permissions (in-memory, can be replaced with Redis in production)\r\n */\r\nconst permissionCache = new Map<string, { permissions: string[], expiresAt: number }>()\r\n\r\nconst CACHE_TTL = 5 * 60 * 1000 // 5 minutes\r\n\r\n/**\r\n * Get all permissions for a user (with caching)\r\n */\r\nexport async function getUserPermissions(\r\n  userId: number,\r\n  projectId?: number\r\n): Promise<string[]> {\r\n  const cacheKey = `${userId}:${projectId || \"global\"}`\r\n  const cached = permissionCache.get(cacheKey)\r\n  \r\n  if (cached && cached.expiresAt > Date.now()) {\r\n    return cached.permissions\r\n  }\r\n\r\n  // Get all user roles (global and project-scoped)\r\n  const userRoles = await prisma.userRole.findMany({\r\n    where: {\r\n      userId,\r\n      OR: [\r\n        { scopeType: null }, // Global roles\r\n        { scopeType: \"global\" },\r\n        ...(projectId ? [{ scopeType: \"project\", scopeId: projectId }] : []),\r\n      ],\r\n    },\r\n    include: {\r\n      role: {\r\n        include: {\r\n          permissions: {\r\n            include: {\r\n              permission: true,\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  })\r\n\r\n  // Collect all unique permissions\r\n  const permissionSet = new Set<string>()\r\n  \r\n  for (const userRole of userRoles) {\r\n    for (const rolePermission of userRole.role.permissions) {\r\n      permissionSet.add(rolePermission.permission.key)\r\n    }\r\n  }\r\n\r\n  const permissions = Array.from(permissionSet)\r\n\r\n  // Cache the result\r\n  permissionCache.set(cacheKey, {\r\n    permissions,\r\n    expiresAt: Date.now() + CACHE_TTL,\r\n  })\r\n\r\n  return permissions\r\n}\r\n\r\n/**\r\n * Check if user has a specific permission\r\n * ⚠️ DEPRECATED - This function has role-based bypasses\r\n * Use hasPermissionWithoutRoleBypass() from rbac-helpers.ts instead\r\n * \r\n * @deprecated - Use hasPermissionWithoutRoleBypass() for new code\r\n */\r\nexport async function hasPermission(\r\n  userId: number,\r\n  permission: string,\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  // Legacy implementation with bypasses - kept for backward compatibility only\r\n  // DO NOT USE IN NEW CODE - this bypasses RBAC\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { role: true },\r\n  })\r\n\r\n  // ⚠️ LEGACY BYPASS - Should not exist in new code\r\n  if (user?.role === \"admin\" || user?.role === \"project_manager\") {\r\n    return true\r\n  }\r\n\r\n  // Check RBAC permissions\r\n  const permissions = await getUserPermissions(userId, projectId)\r\n  return permissions.includes(permission)\r\n}\r\n\r\n/**\r\n * ⛔ DEPRECATED - DO NOT USE\r\n * This function allows legacy role-based bypass of RBAC permissions\r\n * Use hasPermissionWithoutRoleBypass() from rbac-helpers.ts instead\r\n */\r\nexport async function hasPermissionOrRole(\r\n  userId: number,\r\n  permission: string,\r\n  allowedLegacyRoles: string[] = [\"admin\", \"project_manager\"],\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  console.warn(\r\n    \"[RBAC] DEPRECATED: hasPermissionOrRole() called. Use hasPermissionWithoutRoleBypass() instead.\"\r\n  )\r\n  throw new Error(\r\n    \"hasPermissionOrRole is deprecated and must be replaced with hasPermissionWithoutRoleBypass(). \" +\r\n    \"This function bypasses RBAC security controls. See rbac-helpers.ts for proper authorization.\"\r\n  )\r\n}\r\n\r\n/**\r\n * Check if user has any of the specified permissions\r\n */\r\nexport async function hasAnyPermission(\r\n  userId: number,\r\n  permissions: string[],\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  const userPermissions = await getUserPermissions(userId, projectId)\r\n  return permissions.some(perm => userPermissions.includes(perm))\r\n}\r\n\r\n/**\r\n * Check if user has all of the specified permissions\r\n */\r\nexport async function hasAllPermissions(\r\n  userId: number,\r\n  permissions: string[],\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  const userPermissions = await getUserPermissions(userId, projectId)\r\n  return permissions.every(perm => userPermissions.includes(perm))\r\n}\r\n\r\n/**\r\n * Get user roles\r\n */\r\nexport async function getUserRoles(\r\n  userId: number,\r\n  projectId?: number\r\n): Promise<Array<{ role: any, scopeType: string | null, scopeId: number | null }>> {\r\n  const userRoles = await prisma.userRole.findMany({\r\n    where: {\r\n      userId,\r\n      OR: [\r\n        { scopeType: null },\r\n        { scopeType: \"global\" },\r\n        ...(projectId ? [{ scopeType: \"project\", scopeId: projectId }] : []),\r\n      ],\r\n    },\r\n    include: {\r\n      role: true,\r\n    },\r\n  })\r\n\r\n  return userRoles.map(ur => ({\r\n    role: ur.role,\r\n    scopeType: ur.scopeType,\r\n    scopeId: ur.scopeId,\r\n  }))\r\n}\r\n\r\n/**\r\n * Check if user has a specific role\r\n */\r\nexport async function hasRole(\r\n  userId: number,\r\n  roleName: string,\r\n  projectId?: number\r\n): Promise<boolean> {\r\n  const roles = await getUserRoles(userId, projectId)\r\n  return roles.some(r => r.role.name === roleName)\r\n}\r\n\r\n/**\r\n * Clear permission cache for a user\r\n */\r\nexport function clearPermissionCache(userId: number, projectId?: number) {\r\n  const cacheKey = `${userId}:${projectId || \"global\"}`\r\n  permissionCache.delete(cacheKey)\r\n}\r\n\r\n/**\r\n * Clear all permission caches\r\n */\r\nexport function clearAllPermissionCaches() {\r\n  permissionCache.clear()\r\n}\r\n\r\n/**\r\n * Require permission - throws error if user doesn't have permission\r\n */\r\nexport async function requirePermission(\r\n  userId: number,\r\n  permission: string,\r\n  projectId?: number\r\n): Promise<void> {\r\n  const has = await hasPermission(userId, permission, projectId)\r\n  if (!has) {\r\n    throw new Error(`Permission denied: ${permission}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Require any permission - throws error if user doesn't have any of the permissions\r\n */\r\nexport async function requireAnyPermission(\r\n  userId: number,\r\n  permissions: string[],\r\n  projectId?: number\r\n): Promise<void> {\r\n  const has = await hasAnyPermission(userId, permissions, projectId)\r\n  if (!has) {\r\n    throw new Error(`Permission denied: requires one of [${permissions.join(\", \")}]`)\r\n  }\r\n}\r\n\r\n","\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { revalidatePath } from \"next/cache\"\r\nimport { unstable_noStore as noStore } from \"next/cache\"\r\nimport bcrypt from \"bcryptjs\"\r\nimport { hasPermissionWithoutRoleBypass } from \"@/lib/rbac-helpers\"\r\n\r\n// Check if user is system administrator\r\nasync function checkAdmin() {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) return { authorized: false, session: null }\r\n\r\n    const isAuthorized = await hasPermissionWithoutRoleBypass(\r\n        parseInt(session.user.id),\r\n        \"admin.access\"\r\n    )\r\n    return { authorized: isAuthorized, session }\r\n}\r\n\r\n// Get all system settings\r\nexport async function getAllSettings() {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized: Only system administrators can access settings\" }\r\n    }\r\n\r\n    try {\r\n        const settings = await prisma.systemSetting.findMany({\r\n            orderBy: [\r\n                { category: \"asc\" },\r\n                { key: \"asc\" }\r\n            ],\r\n            include: {\r\n                updater: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n        // Group settings by category\r\n        const grouped: Record<string, any[]> = {}\r\n        settings.forEach(setting => {\r\n            if (!grouped[setting.category]) {\r\n                grouped[setting.category] = []\r\n            }\r\n            grouped[setting.category].push({\r\n                id: setting.id,\r\n                key: setting.key,\r\n                value: JSON.parse(setting.value),\r\n                category: setting.category,\r\n                description: setting.description,\r\n                updatedAt: setting.updatedAt,\r\n                updatedBy: setting.updater\r\n            })\r\n        })\r\n\r\n        return { success: true, settings: grouped }\r\n    } catch (e: any) {\r\n        console.error(\"getAllSettings Error:\", e)\r\n        return { error: \"Failed to fetch settings\", details: e.message }\r\n    }\r\n\r\n}\r\n\r\n\r\n// Get public system settings (branding) - No auth required\r\nexport async function getPublicSystemSettings() {\r\n    noStore()\r\n    try {\r\n        const setting = await prisma.systemSetting.findUnique({\r\n            where: { key: \"general\" }\r\n        })\r\n\r\n        if (!setting) {\r\n            return {\r\n                success: true,\r\n                settings: {\r\n                    systemName: \"Qeema PMS\",\r\n                    systemLogo: \"/assets/logo.png\",\r\n                    allowRegistration: true\r\n                }\r\n            }\r\n        }\r\n\r\n        const value = JSON.parse(setting.value)\r\n        return {\r\n            success: true,\r\n            settings: {\r\n                systemName: value.systemName || \"Qeema PMS\",\r\n                systemLogo: value.systemLogo || \"/assets/logo.png\",\r\n                allowRegistration: value.allowRegistration !== undefined ? value.allowRegistration : true\r\n            }\r\n        }\r\n    } catch (e: any) {\r\n        console.error(\"getPublicSystemSettings Error:\", e)\r\n        // Return defaults on error to avoid breaking UI\r\n        return {\r\n            success: true,\r\n            settings: {\r\n                systemName: \"Qeema PMS\",\r\n                systemLogo: \"/assets/logo.png\",\r\n                allowRegistration: true\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Get a specific setting by key\r\nexport async function getSetting(key: string) {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const setting = await prisma.systemSetting.findUnique({\r\n            where: { key },\r\n            include: {\r\n                updater: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true\r\n                    }\r\n                }\r\n            }\r\n        })\r\n\r\n        if (!setting) {\r\n            return { error: \"Setting not found\" }\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            setting: {\r\n                id: setting.id,\r\n                key: setting.key,\r\n                value: JSON.parse(setting.value),\r\n                category: setting.category,\r\n                description: setting.description,\r\n                updatedAt: setting.updatedAt,\r\n                updatedBy: setting.updater\r\n            }\r\n        }\r\n    } catch (e: any) {\r\n        console.error(\"getSetting Error:\", e)\r\n        return { error: \"Failed to fetch setting\", details: e.message }\r\n    }\r\n}\r\n\r\n// Update a system setting\r\nexport async function updateSetting(\r\n    key: string,\r\n    value: any,\r\n    reason?: string,\r\n    category?: string // Optional category for auto-creation\r\n) {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        // Get existing setting\r\n        const existing = await prisma.systemSetting.findUnique({\r\n            where: { key }\r\n        })\r\n\r\n        if (!existing) {\r\n            if (category) {\r\n                // Auto-create if category is provided\r\n                return await createSetting(key, category, value, \"Auto-created via update\")\r\n            }\r\n            return { error: \"Setting not found\" }\r\n        }\r\n\r\n        const oldValue = existing.value\r\n        const newValue = JSON.stringify(value)\r\n\r\n        // Update setting\r\n        const updated = await prisma.systemSetting.update({\r\n            where: { key },\r\n            data: {\r\n                value: newValue,\r\n                updatedBy: parseInt(session.user.id)\r\n            }\r\n        })\r\n\r\n        // Log the change\r\n        await prisma.settingsChangeLog.create({\r\n            data: {\r\n                settingKey: key,\r\n                oldValue: oldValue,\r\n                newValue: newValue,\r\n                reason: reason || null,\r\n                userId: parseInt(session.user.id),\r\n                settingId: updated.id\r\n            }\r\n        })\r\n\r\n        revalidatePath(\"/\", \"layout\")\r\n        return { success: true, setting: updated }\r\n    } catch (e: any) {\r\n        console.error(\"updateSetting Error:\", e)\r\n        return { error: \"Failed to update setting\", details: e.message }\r\n    }\r\n}\r\n\r\n// Create a new system setting\r\nexport async function createSetting(\r\n    key: string,\r\n    category: string,\r\n    value: any,\r\n    description?: string\r\n) {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        // Check if setting already exists\r\n        const existing = await prisma.systemSetting.findUnique({\r\n            where: { key }\r\n        })\r\n\r\n        if (existing) {\r\n            return { error: \"Setting with this key already exists\" }\r\n        }\r\n\r\n        const newSetting = await prisma.systemSetting.create({\r\n            data: {\r\n                key,\r\n                category,\r\n                value: JSON.stringify(value),\r\n                description: description || null,\r\n                updatedBy: parseInt(session.user.id)\r\n            }\r\n        })\r\n\r\n        // Log the creation\r\n        await prisma.settingsChangeLog.create({\r\n            data: {\r\n                settingKey: key,\r\n                oldValue: null,\r\n                newValue: JSON.stringify(value),\r\n                reason: \"Setting created\",\r\n                userId: parseInt(session.user.id),\r\n                settingId: newSetting.id\r\n            }\r\n        })\r\n\r\n        revalidatePath(\"/dashboard/settings\")\r\n        return { success: true, setting: newSetting }\r\n    } catch (e: any) {\r\n        console.error(\"createSetting Error:\", e)\r\n        return { error: \"Failed to create setting\", details: e.message }\r\n    }\r\n}\r\n\r\n// Get settings change log\r\nexport async function getSettingsChangeLog(\r\n    settingKey?: string,\r\n    limit: number = 50,\r\n    offset: number = 0\r\n) {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const where = settingKey ? { settingKey } : {}\r\n\r\n        const logs = await prisma.settingsChangeLog.findMany({\r\n            where,\r\n            include: {\r\n                user: {\r\n                    select: {\r\n                        id: true,\r\n                        username: true,\r\n                        email: true\r\n                    }\r\n                },\r\n                setting: {\r\n                    select: {\r\n                        key: true,\r\n                        category: true\r\n                    }\r\n                }\r\n            },\r\n            orderBy: { createdAt: \"desc\" },\r\n            take: limit,\r\n            skip: offset\r\n        })\r\n\r\n        const total = await prisma.settingsChangeLog.count({ where })\r\n\r\n        return {\r\n            success: true,\r\n            logs: logs.map(log => ({\r\n                id: log.id,\r\n                settingKey: log.settingKey,\r\n                category: log.setting?.category,\r\n                oldValue: log.oldValue ? JSON.parse(log.oldValue) : null,\r\n                newValue: JSON.parse(log.newValue),\r\n                reason: log.reason,\r\n                changedBy: log.user,\r\n                createdAt: log.createdAt\r\n            })),\r\n            total,\r\n            limit,\r\n            offset\r\n        }\r\n    } catch (e: any) {\r\n        console.error(\"getSettingsChangeLog Error:\", e)\r\n        return { error: \"Failed to fetch change log\", details: e.message }\r\n    }\r\n}\r\n\r\n// Initialize default settings (run once on system setup)\r\nexport async function initializeDefaultSettings() {\r\n    const { authorized, session } = await checkAdmin()\r\n    if (!authorized || !session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const defaultSettings = [\r\n            {\r\n                key: \"general\",\r\n                category: \"general\",\r\n                value: {\r\n                    systemName: \"Project Management System\",\r\n                    systemLogo: \"/assets/logo.png\",\r\n                    defaultLanguage: \"en\",\r\n                    defaultTimezone: \"UTC\",\r\n                    workingDays: [1, 2, 3, 4, 5], // Monday to Friday\r\n                    defaultWorkingHours: {\r\n                        start: \"09:00\",\r\n                        end: \"17:00\"\r\n                    }\r\n                },\r\n                description: \"General system settings\"\r\n            },\r\n            {\r\n                key: \"tasks\",\r\n                category: \"tasks\",\r\n                value: {\r\n                    statuses: [\r\n                        {\r\n                            id: 1,\r\n                            name: \"Pending\",\r\n                            key: \"pending\",\r\n                            order: 1,\r\n                            color: \"#fbbf24\",\r\n                            isFinal: false,\r\n                            isDefault: true\r\n                        },\r\n                        {\r\n                            id: 2,\r\n                            name: \"Waiting\",\r\n                            key: \"waiting\",\r\n                            order: 2,\r\n                            color: \"#f97316\",\r\n                            isFinal: false,\r\n                            isDefault: false\r\n                        },\r\n                        {\r\n                            id: 3,\r\n                            name: \"In Progress\",\r\n                            key: \"in_progress\",\r\n                            order: 3,\r\n                            color: \"#3b82f6\",\r\n                            isFinal: false,\r\n                            isDefault: false\r\n                        },\r\n                        {\r\n                            id: 4,\r\n                            name: \"Review\",\r\n                            key: \"review\",\r\n                            order: 4,\r\n                            color: \"#a855f7\",\r\n                            isFinal: false,\r\n                            isDefault: false\r\n                        },\r\n                        {\r\n                            id: 5,\r\n                            name: \"Completed\",\r\n                            key: \"completed\",\r\n                            order: 5,\r\n                            color: \"#10b981\",\r\n                            isFinal: true,\r\n                            isDefault: false\r\n                        }\r\n                    ],\r\n                    priorities: [\r\n                        {\r\n                            id: 1,\r\n                            name: \"Low\",\r\n                            key: \"low\",\r\n                            weight: 1,\r\n                            color: \"#6b7280\",\r\n                            isDefault: false\r\n                        },\r\n                        {\r\n                            id: 2,\r\n                            name: \"Normal\",\r\n                            key: \"normal\",\r\n                            weight: 2,\r\n                            color: \"#3b82f6\",\r\n                            isDefault: true\r\n                        },\r\n                        {\r\n                            id: 3,\r\n                            name: \"High\",\r\n                            key: \"high\",\r\n                            weight: 3,\r\n                            color: \"#f59e0b\",\r\n                            isDefault: false\r\n                        },\r\n                        {\r\n                            id: 4,\r\n                            name: \"Urgent\",\r\n                            key: \"urgent\",\r\n                            weight: 4,\r\n                            color: \"#ef4444\",\r\n                            isDefault: false\r\n                        }\r\n                    ]\r\n                },\r\n                description: \"Task statuses and priority levels\"\r\n            },\r\n            {\r\n                key: \"today_tasks\",\r\n                category: \"today_tasks\",\r\n                value: {\r\n                    dailyResetTime: \"00:00\",\r\n                    resetTimezoneSource: \"system\",\r\n                    autoCarryOver: true,\r\n                    carryOverRules: {\r\n                        excludeBlocked: true,\r\n                        incompleteOnly: true,\r\n                        maxDays: 7\r\n                    },\r\n                    adminOverridePermissions: true\r\n                },\r\n                description: \"Today's Tasks configuration\"\r\n            },\r\n            {\r\n                key: \"dependencies\",\r\n                category: \"dependencies\",\r\n                value: {\r\n                    allowMultipleDependencies: true,\r\n                    allowCrossTeamDependencies: true,\r\n                    allowCrossProjectDependencies: false,\r\n                    autoBlockTasks: true,\r\n                    allowAdminManualUnblock: true\r\n                },\r\n                description: \"Task dependency rules\"\r\n            },\r\n            {\r\n                key: \"permissions\",\r\n                category: \"permissions\",\r\n                value: {\r\n                    admin: {\r\n                        taskCreation: true,\r\n                        taskAssignment: true,\r\n                        todayTasksManagement: true,\r\n                        dependencyManagement: true,\r\n                        projectCreation: true,\r\n                        userManagement: true\r\n                    },\r\n                    team_lead: {\r\n                        taskCreation: true,\r\n                        taskAssignment: true,\r\n                        todayTasksManagement: true,\r\n                        dependencyManagement: true,\r\n                        projectCreation: false,\r\n                        userManagement: false\r\n                    },\r\n                    developer: {\r\n                        taskCreation: false,\r\n                        taskAssignment: false,\r\n                        todayTasksManagement: false,\r\n                        dependencyManagement: false,\r\n                        projectCreation: false,\r\n                        userManagement: false\r\n                    }\r\n                },\r\n                description: \"Default permissions by role\"\r\n            },\r\n            {\r\n                key: \"notifications\",\r\n                category: \"notifications\",\r\n                value: {\r\n                    notifyOnTodayTaskAssignment: true,\r\n                    notifyOnTaskBlocked: true,\r\n                    notifyOnDependencyCompleted: true,\r\n                    notifyOnTaskOverdue: true,\r\n                    notifyOnStatusChange: false\r\n                },\r\n                description: \"System-wide notification preferences\"\r\n            },\r\n            {\r\n                key: \"audit\",\r\n                category: \"audit\",\r\n                value: {\r\n                    enableSettingsChangeLogs: true,\r\n                    enableOverrideLogs: true,\r\n                    logRetentionPolicy: {\r\n                        retentionDays: 365,\r\n                        archiveAfterDays: 90,\r\n                        maxLogSizeMB: 100\r\n                    }\r\n                },\r\n                description: \"Audit and logging configuration\"\r\n            }\r\n        ]\r\n\r\n        const created = []\r\n        for (const setting of defaultSettings) {\r\n            const existing = await prisma.systemSetting.findUnique({\r\n                where: { key: setting.key }\r\n            })\r\n\r\n            if (!existing) {\r\n                const newSetting = await prisma.systemSetting.create({\r\n                    data: {\r\n                        key: setting.key,\r\n                        category: setting.category,\r\n                        value: JSON.stringify(setting.value),\r\n                        description: setting.description,\r\n                        updatedBy: parseInt(session.user.id)\r\n                    }\r\n                })\r\n                created.push(newSetting)\r\n            }\r\n        }\r\n\r\n        return { success: true, created: created.length, message: `Initialized ${created.length} default settings` }\r\n    } catch (e: any) {\r\n        console.error(\"initializeDefaultSettings Error:\", e)\r\n        return { error: \"Failed to initialize settings\", details: e.message }\r\n    }\r\n}\r\n\r\n// Update user profile\r\nexport async function updateProfile(formData: FormData) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const username = formData.get(\"username\") as string\r\n        const email = formData.get(\"email\") as string\r\n\r\n        if (!username || !email) {\r\n            return { error: \"Username and email are required\" }\r\n        }\r\n\r\n        const userId = parseInt(session.user.id)\r\n\r\n        // Check if username or email is already taken by another user\r\n        const existingUser = await prisma.user.findFirst({\r\n            where: {\r\n                AND: [\r\n                    { id: { not: userId } },\r\n                    {\r\n                        OR: [\r\n                            { username },\r\n                            { email }\r\n                        ]\r\n                    }\r\n                ]\r\n            }\r\n        })\r\n\r\n        if (existingUser) {\r\n            return { error: \"Username or email already taken\" }\r\n        }\r\n\r\n        // Update user profile\r\n        await prisma.user.update({\r\n            where: { id: userId },\r\n            data: {\r\n                username,\r\n                email\r\n            }\r\n        })\r\n\r\n        // Log activity\r\n        try {\r\n            await prisma.activityLog.create({\r\n                data: {\r\n                    userId: userId,\r\n                    action: \"update_profile\",\r\n                    description: \"User updated their profile\",\r\n                    entityType: \"user\",\r\n                    entityId: userId\r\n                }\r\n            })\r\n        } catch (logError) {\r\n            console.error(\"Failed to log activity:\", logError)\r\n            // Don't fail the operation if logging fails\r\n        }\r\n\r\n        revalidatePath(\"/dashboard/settings\")\r\n        return { success: true, message: \"Profile updated successfully\" }\r\n    } catch (e: any) {\r\n        console.error(\"updateProfile Error:\", e)\r\n        return { error: \"Failed to update profile\", details: e.message }\r\n    }\r\n}\r\n\r\n// Change user password\r\nexport async function changePassword(formData: FormData) {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session) {\r\n        return { error: \"Unauthorized\" }\r\n    }\r\n\r\n    try {\r\n        const currentPassword = formData.get(\"currentPassword\") as string\r\n        const newPassword = formData.get(\"newPassword\") as string\r\n\r\n        if (!currentPassword || !newPassword) {\r\n            return { error: \"Current password and new password are required\" }\r\n        }\r\n\r\n        if (newPassword.length < 6) {\r\n            return { error: \"New password must be at least 6 characters long\" }\r\n        }\r\n\r\n        const userId = parseInt(session.user.id)\r\n\r\n        // Get user with password hash\r\n        const user = await prisma.user.findUnique({\r\n            where: { id: userId },\r\n            select: { id: true, passwordHash: true }\r\n        })\r\n\r\n        if (!user) {\r\n            return { error: \"User not found\" }\r\n        }\r\n\r\n        // Verify current password\r\n        const isValidPassword = await bcrypt.compare(currentPassword, user.passwordHash)\r\n        if (!isValidPassword) {\r\n            return { error: \"Current password is incorrect\" }\r\n        }\r\n\r\n        // Hash new password\r\n        const hashedPassword = await bcrypt.hash(newPassword, 10)\r\n\r\n        // Update password\r\n        await prisma.user.update({\r\n            where: { id: userId },\r\n            data: { passwordHash: hashedPassword }\r\n        })\r\n\r\n        // Log activity\r\n        try {\r\n            await prisma.activityLog.create({\r\n                data: {\r\n                    userId: userId,\r\n                    action: \"change_password\",\r\n                    description: \"User changed their password\",\r\n                    entityType: \"user\",\r\n                    entityId: userId\r\n                }\r\n            })\r\n        } catch (logError) {\r\n            console.error(\"Failed to log activity:\", logError)\r\n            // Don't fail the operation if logging fails\r\n        }\r\n\r\n        return { success: true, message: \"Password changed successfully\" }\r\n    } catch (e: any) {\r\n        console.error(\"changePassword Error:\", e)\r\n        return { error: \"Failed to change password\", details: e.message }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}