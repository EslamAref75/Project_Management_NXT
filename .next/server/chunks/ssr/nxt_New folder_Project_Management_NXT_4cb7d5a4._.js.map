{"version":3,"sources":["../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/project-notifications.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/src/app/actions/users.ts","../../../../../../../nxt/New%20folder/Project_Management_NXT/.next-internal/server/app/dashboard/users/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { revalidatePath } from \"next/cache\"\r\n\r\n// Get all notifications for a project (paginated)\r\nexport async function getProjectNotifications(\r\n  projectId: number,\r\n  filters?: {\r\n    type?: string\r\n    isRead?: boolean\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null, // User is still active in the project\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    const limit = filters?.limit || 20\r\n    const offset = filters?.offset || 0\r\n\r\n    const where: any = {\r\n      projectId,\r\n      userId,\r\n    }\r\n\r\n    if (filters?.type) {\r\n      where.type = filters.type\r\n    }\r\n\r\n    if (filters?.isRead !== undefined) {\r\n      where.isRead = filters.isRead\r\n    }\r\n\r\n    const [notifications, total] = await Promise.all([\r\n      prisma.projectNotification.findMany({\r\n        where,\r\n        orderBy: [\r\n          { isUrgent: \"desc\" },\r\n          { requiresAcknowledgment: \"desc\" },\r\n          { createdAt: \"desc\" }\r\n        ],\r\n        take: limit,\r\n        skip: offset,\r\n      }),\r\n      prisma.projectNotification.count({ where }),\r\n    ])\r\n\r\n    return {\r\n      success: true,\r\n      notifications,\r\n      total,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching project notifications:\", error)\r\n    return { success: false, error: \"Failed to fetch notifications\" }\r\n  }\r\n}\r\n\r\n// Get total unread notification count across all projects for a user\r\nexport async function getAllProjectsUnreadNotificationCount() {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Get all projects the user is part of OR has tasks assigned to\r\n    const projectUsers = await prisma.projectUser.findMany({\r\n      where: {\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n      select: { projectId: true },\r\n    })\r\n\r\n    // Also get projects where user has assigned tasks\r\n    let tasksWithProjects: { projectId: number }[] = []\r\n    try {\r\n      tasksWithProjects = await prisma.task.findMany({\r\n        where: {\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        },\r\n        select: {\r\n          projectId: true\r\n        }\r\n      })\r\n    } catch (error: any) {\r\n      // If task model is not available, just use projectUsers\r\n      console.warn(\"[Notifications] Could not fetch tasks, using only ProjectUser:\", error?.message)\r\n      tasksWithProjects = []\r\n    }\r\n\r\n    const projectIdsFromUsers = projectUsers.map((pu) => pu.projectId)\r\n    const projectIdsFromTasks = tasksWithProjects.map(t => t.projectId)\r\n    // Remove duplicates using Set\r\n    const allProjectIds = [...new Set([...projectIdsFromUsers, ...projectIdsFromTasks])]\r\n\r\n    if (allProjectIds.length === 0) {\r\n      return { success: true, count: 0 }\r\n    }\r\n\r\n    let count = 0\r\n    try {\r\n      count = await prisma.projectNotification.count({\r\n        where: {\r\n          projectId: { in: allProjectIds },\r\n          userId,\r\n          isRead: false,\r\n        },\r\n      })\r\n    } catch (error: any) {\r\n      // If ProjectNotification model is not available, return 0\r\n      console.error(\"[Notifications] ProjectNotification model not available. Please run 'npx prisma generate':\", error?.message)\r\n      return { success: true, count: 0 }\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      count,\r\n    }\r\n  } catch (error: any) {\r\n    console.error(\"Error fetching all projects unread count:\", error)\r\n    console.error(\"Error details:\", {\r\n      message: error?.message,\r\n      stack: error?.stack,\r\n      name: error?.name\r\n    })\r\n    return {\r\n      success: false,\r\n      error: error?.message || \"Failed to fetch unread count\",\r\n      details: error?.stack\r\n    }\r\n  }\r\n}\r\n\r\n// Get recent notifications across all projects for a user\r\nexport async function getAllProjectsNotifications(limit: number = 15) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Get all projects the user is part of OR has tasks assigned to\r\n    const projectUsers = await prisma.projectUser.findMany({\r\n      where: {\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n      select: { projectId: true },\r\n    })\r\n\r\n    // Also get projects where user has assigned tasks\r\n    let tasksWithProjects: { projectId: number }[] = []\r\n    try {\r\n      tasksWithProjects = await prisma.task.findMany({\r\n        where: {\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        },\r\n        select: {\r\n          projectId: true\r\n        }\r\n      })\r\n    } catch (error: any) {\r\n      // If task model is not available, just use projectUsers\r\n      console.warn(\"[Notifications] Could not fetch tasks, using only ProjectUser:\", error?.message)\r\n      tasksWithProjects = []\r\n    }\r\n\r\n    const projectIdsFromUsers = projectUsers.map((pu) => pu.projectId)\r\n    const projectIdsFromTasks = tasksWithProjects.map(t => t.projectId)\r\n    // Remove duplicates using Set\r\n    const allProjectIds = [...new Set([...projectIdsFromUsers, ...projectIdsFromTasks])]\r\n\r\n    console.log(`[Notifications] User ${userId} has access to projects:`, allProjectIds)\r\n\r\n    if (allProjectIds.length === 0) {\r\n      console.log(`[Notifications] No projects found for user ${userId}`)\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    // Check if ProjectNotification model exists\r\n    if (!prisma.projectNotification) {\r\n      console.error(\"[Notifications] ProjectNotification model not found. Please run 'npx prisma generate'\")\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    let notifications: any[] = []\r\n    try {\r\n      notifications = await prisma.projectNotification.findMany({\r\n        where: {\r\n          projectId: { in: allProjectIds },\r\n          userId,\r\n        },\r\n        include: {\r\n          project: {\r\n            select: { id: true, name: true },\r\n          },\r\n        },\r\n        orderBy: { createdAt: \"desc\" },\r\n        take: limit,\r\n      })\r\n    } catch (error: any) {\r\n      // If ProjectNotification model is not available, return empty array\r\n      console.error(\"[Notifications] Error accessing ProjectNotification model. Please run 'npx prisma generate':\", error?.message)\r\n      return { success: true, notifications: [] }\r\n    }\r\n\r\n    console.log(`[Notifications] Found ${notifications.length} notifications for user ${userId}`)\r\n\r\n    return {\r\n      success: true,\r\n      notifications,\r\n    }\r\n  } catch (error: any) {\r\n    console.error(\"Error fetching all projects notifications:\", error)\r\n    console.error(\"Error details:\", {\r\n      message: error?.message,\r\n      stack: error?.stack,\r\n      name: error?.name\r\n    })\r\n    return {\r\n      success: false,\r\n      error: error?.message || \"Failed to fetch notifications\",\r\n      details: error?.stack\r\n    }\r\n  }\r\n}\r\n\r\n// Get unread notification count for a project\r\nexport async function getProjectUnreadNotificationCount(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    const count = await prisma.projectNotification.count({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        isRead: false,\r\n      },\r\n    })\r\n\r\n    return {\r\n      success: true,\r\n      count,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching unread count:\", error)\r\n    return { success: false, error: \"Failed to fetch unread count\" }\r\n  }\r\n}\r\n\r\n// Mark a notification as read\r\nexport async function markProjectNotificationAsRead(\r\n  projectId: number,\r\n  notificationId: number\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify notification belongs to user and project\r\n    const notification = await prisma.projectNotification.findFirst({\r\n      where: {\r\n        id: notificationId,\r\n        projectId,\r\n        userId,\r\n      },\r\n    })\r\n\r\n    if (!notification) {\r\n      return { success: false, error: \"Notification not found\" }\r\n    }\r\n\r\n    // Prevent marking urgent notifications that require acknowledgment as read\r\n    // They can only be marked as read after acknowledgment\r\n    if (notification.isUrgent && notification.requiresAcknowledgment && !notification.acknowledgedAt) {\r\n      return {\r\n        success: false,\r\n        error: \"Urgent notifications cannot be marked as read until acknowledged. Please acknowledge the urgent project first.\"\r\n      }\r\n    }\r\n\r\n    await prisma.projectNotification.update({\r\n      where: { id: notificationId },\r\n      data: { isRead: true },\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error marking notification as read:\", error)\r\n    return { success: false, error: \"Failed to mark notification as read\" }\r\n  }\r\n}\r\n\r\n// Mark all project notifications as read\r\nexport async function markAllProjectNotificationsAsRead(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    // Don't mark urgent notifications that require acknowledgment as read\r\n    await prisma.projectNotification.updateMany({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        isRead: false,\r\n        OR: [\r\n          { isUrgent: false },\r\n          { requiresAcknowledgment: false },\r\n          { acknowledgedAt: { not: null } }\r\n        ]\r\n      },\r\n      data: {\r\n        isRead: true,\r\n      },\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error marking all notifications as read:\", error)\r\n    return { success: false, error: \"Failed to mark all notifications as read\" }\r\n  }\r\n}\r\n\r\n// Get user's notification preferences for a project\r\nexport async function getProjectNotificationPreferences(projectId: number) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    let preferences = await prisma.projectNotificationPreference.findUnique({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n    })\r\n\r\n    // Create default preferences if they don't exist\r\n    if (!preferences) {\r\n      preferences = await prisma.projectNotificationPreference.create({\r\n        data: {\r\n          projectId,\r\n          userId,\r\n          soundEnabled: true,\r\n          taskNotifications: true,\r\n          dependencyNotifications: true,\r\n          todayTaskNotifications: true,\r\n          projectAdminNotifications: true,\r\n        },\r\n      })\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      preferences,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching notification preferences:\", error)\r\n    return { success: false, error: \"Failed to fetch preferences\" }\r\n  }\r\n}\r\n\r\n// Update user's notification preferences for a project\r\nexport async function updateProjectNotificationPreferences(\r\n  projectId: number,\r\n  preferences: {\r\n    soundEnabled?: boolean\r\n    taskNotifications?: boolean\r\n    dependencyNotifications?: boolean\r\n    todayTaskNotifications?: boolean\r\n    projectAdminNotifications?: boolean\r\n  }\r\n) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return { success: false, error: \"Unauthorized\" }\r\n    }\r\n\r\n    const userId = parseInt(session.user.id)\r\n\r\n    // Verify user has access to the project\r\n    const projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    if (!projectUser) {\r\n      return { success: false, error: \"Access denied to this project\" }\r\n    }\r\n\r\n    await prisma.projectNotificationPreference.upsert({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n      create: {\r\n        projectId,\r\n        userId,\r\n        soundEnabled: preferences.soundEnabled ?? true,\r\n        taskNotifications: preferences.taskNotifications ?? true,\r\n        dependencyNotifications: preferences.dependencyNotifications ?? true,\r\n        todayTaskNotifications: preferences.todayTaskNotifications ?? true,\r\n        projectAdminNotifications: preferences.projectAdminNotifications ?? true,\r\n      },\r\n      update: preferences,\r\n    })\r\n\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return { success: true }\r\n  } catch (error) {\r\n    console.error(\"Error updating notification preferences:\", error)\r\n    return { success: false, error: \"Failed to update preferences\" }\r\n  }\r\n}\r\n\r\n// Create a project notification (internal use)\r\nexport async function createProjectNotification(\r\n  projectId: number,\r\n  userId: number,\r\n  options: {\r\n    type: string\r\n    entityType: string\r\n    entityId: number | null\r\n    title: string\r\n    message: string\r\n    soundRequired?: boolean\r\n    isUrgent?: boolean\r\n    requiresAcknowledgment?: boolean\r\n  }\r\n) {\r\n  const {\r\n    type,\r\n    entityType,\r\n    entityId,\r\n    title,\r\n    message,\r\n    soundRequired = false,\r\n    isUrgent = false,\r\n    requiresAcknowledgment = false\r\n  } = options\r\n  try {\r\n    // Verify user is part of the project OR assigned to a task in the project\r\n    let projectUser = await prisma.projectUser.findFirst({\r\n      where: {\r\n        projectId,\r\n        userId,\r\n        leftAt: null,\r\n      },\r\n    })\r\n\r\n    // If user is not in ProjectUser, check if they're assigned to a task in this project\r\n    if (!projectUser && (entityType === \"task\" || entityType === \"comment_mention\") && entityId) {\r\n      const task = await prisma.task.findFirst({\r\n        where: {\r\n          id: entityId,\r\n          projectId,\r\n          assignees: {\r\n            some: { id: userId }\r\n          }\r\n        }\r\n      })\r\n\r\n      if (task) {\r\n        // User is assigned to a task in this project, so they should receive notifications\r\n        // Optionally, we could auto-add them to ProjectUser here, but for now we'll just allow the notification\r\n        projectUser = null // We'll allow notification even without ProjectUser entry\r\n      } else {\r\n        // User is not assigned to this task and not in project\r\n        return { success: false, error: \"User not in project or assigned to task\" }\r\n      }\r\n    } else if (!projectUser && entityType === \"comment\" && entityId) {\r\n      // For comments, check if user is assigned to the task the comment is on\r\n      const comment = await prisma.comment.findUnique({\r\n        where: { id: entityId },\r\n        select: { taskId: true }\r\n      })\r\n\r\n      if (comment && comment.taskId) {\r\n        const task = await prisma.task.findFirst({\r\n          where: {\r\n            id: comment.taskId,\r\n            projectId,\r\n            assignees: {\r\n              some: { id: userId }\r\n            }\r\n          }\r\n        })\r\n\r\n        if (task) {\r\n          projectUser = null // Allow notification\r\n        } else {\r\n          return { success: false, error: \"User not assigned to the task related to this comment\" }\r\n        }\r\n      } else {\r\n        return { success: false, error: \"Comment or related task not found\" }\r\n      }\r\n    } else if (!projectUser) {\r\n      // For non-task/non-comment notifications, user must be in ProjectUser\r\n      return { success: false, error: \"User not in project\" }\r\n    }\r\n\r\n    // Check user's notification preferences\r\n    const preferences = await prisma.projectNotificationPreference.findUnique({\r\n      where: {\r\n        projectId_userId: {\r\n          projectId,\r\n          userId,\r\n        },\r\n      },\r\n    })\r\n\r\n    // Determine if notification should be created based on preferences\r\n    let shouldNotify = true\r\n\r\n    if (!soundRequired) {\r\n      // Non-critical notifications respect user preferences\r\n      switch (type) {\r\n        case \"task\":\r\n          if (preferences && !preferences.taskNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"dependency\":\r\n          if (preferences && !preferences.dependencyNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"today_task\":\r\n          if (preferences && !preferences.todayTaskNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n        case \"project_admin\":\r\n          if (preferences && !preferences.projectAdminNotifications) {\r\n            shouldNotify = false\r\n          }\r\n          break\r\n      }\r\n    }\r\n    // Critical notifications (soundRequired = true) always notify\r\n\r\n    if (!shouldNotify) {\r\n      return { success: true, skipped: true }\r\n    }\r\n\r\n    const notification = await prisma.projectNotification.create({\r\n      data: {\r\n        projectId,\r\n        userId,\r\n        type,\r\n        entityType,\r\n        entityId,\r\n        title,\r\n        message,\r\n        soundRequired,\r\n        isUrgent,\r\n        requiresAcknowledgment,\r\n      },\r\n    })\r\n\r\n    console.log(`[Notifications] Created notification for user ${userId} in project ${projectId}:`, {\r\n      id: notification.id,\r\n      type,\r\n      title,\r\n      soundRequired\r\n    })\r\n\r\n    // Revalidate project pages\r\n    revalidatePath(`/dashboard/projects/${projectId}`)\r\n    revalidatePath(`/dashboard/projects/${projectId}/notifications`)\r\n\r\n    return {\r\n      success: true,\r\n      notification,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error creating project notification:\", error)\r\n    return { success: false, error: \"Failed to create notification\" }\r\n  }\r\n}\r\n\r\n","\"use server\"\r\n\r\nimport { prisma } from \"@/lib/prisma\"\r\nimport { getServerSession } from \"next-auth\"\r\nimport { authOptions } from \"@/lib/auth\"\r\nimport { z } from \"zod\"\r\nimport { revalidatePath, unstable_cache } from \"next/cache\"\r\nimport bcrypt from \"bcryptjs\"\r\nimport {\r\n  requirePermission,\r\n  handleAuthorizationError,\r\n  ForbiddenError,\r\n} from \"@/lib/rbac-helpers\"\r\n\r\n\r\nconst createUserSchema = z.object({\r\n  username: z.string().min(3, \"Username must be at least 3 characters\"),\r\n  email: z.string().email(\"Invalid email\"),\r\n  password: z.string().min(6, \"Password must be at least 6 characters\"),\r\n  role: z.string().default(\"developer\"),\r\n  teamId: z.coerce.number().optional()\r\n})\r\n\r\n// EXTRACT LOGIC FOR USERS LIST\r\nconst fetchUsers = async () => {\r\n  return await prisma.user.findMany({\r\n    include: {\r\n      team: { select: { id: true, name: true } }\r\n    },\r\n    orderBy: { username: \"asc\" }\r\n  })\r\n}\r\n\r\n// Cache the user list - it's relatively static\r\nconst getCachedUsers = unstable_cache(\r\n  fetchUsers,\r\n  ['all-users'],\r\n  { revalidate: 300, tags: ['users'] } // 5 minutes cache\r\n)\r\n\r\nexport async function getUsers() {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) throw new Error(\"Unauthorized\")\r\n\r\n  return await getCachedUsers()\r\n}\r\n\r\nexport async function getUser(id: number) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) throw new Error(\"Unauthorized\")\r\n\r\n  const user = await prisma.user.findUnique({\r\n    where: { id },\r\n    include: {\r\n      team: { select: { id: true, name: true } },\r\n      roles: {\r\n        include: {\r\n          role: true\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  return user\r\n}\r\n\r\nexport async function createUser(formData: FormData) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) return { error: \"Unauthorized\", code: \"UNAUTHORIZED\" }\r\n\r\n  try {\r\n    // Use RBAC permission check (not role-based bypass)\r\n    await requirePermission(parseInt(session.user.id), \"user.create\")\r\n  } catch (error: any) {\r\n    return handleAuthorizationError(error)\r\n  }\r\n\r\n  const username = formData.get(\"username\")\r\n  const email = formData.get(\"email\")\r\n  const password = formData.get(\"password\")\r\n  const roleName = formData.get(\"role\")\r\n  const teamId = formData.get(\"teamId\")\r\n\r\n  const validated = createUserSchema.safeParse({\r\n    username,\r\n    email,\r\n    password,\r\n    role: roleName,\r\n    teamId: teamId ? parseInt(teamId as string) : undefined,\r\n  })\r\n\r\n  if (!validated.success) {\r\n    return { error: \"Validation failed\", code: \"VALIDATION_FAILED\" }\r\n  }\r\n\r\n  try {\r\n    const hashedPassword = await bcrypt.hash(validated.data.password, 10)\r\n\r\n    // 1. Check if the role exists in the roles table\r\n    const rbacRole = await prisma.role.findUnique({\r\n      where: { name: validated.data.role },\r\n    })\r\n\r\n    // 2. Create the user\r\n    const newUser = await prisma.user.create({\r\n      data: {\r\n        username: validated.data.username,\r\n        email: validated.data.email,\r\n        role: validated.data.role, // Keep legacy field in sync for now\r\n        passwordHash: hashedPassword,\r\n        teamId: validated.data.teamId,\r\n      },\r\n    })\r\n\r\n    // 3. If RBAC role exists, assign it to the user\r\n    if (rbacRole) {\r\n      await prisma.userRole.create({\r\n        data: {\r\n          userId: newUser.id,\r\n          roleId: rbacRole.id,\r\n          scopeType: \"global\", // Defaulting to global scope for dashboard creation\r\n          scopeId: 0,\r\n        },\r\n      })\r\n    }\r\n\r\n    // Log activity\r\n    console.log(\r\n      `[RBAC] User ${session.user.name || session.user.email} created user ${newUser.username}`\r\n    )\r\n\r\n    // Pass cache tag to revalidate cache if using tag-based revalidation (unstable_cache support tags)\r\n    // Note: manual revalidateTag is available in next/cache\r\n    revalidatePath(\"/dashboard/users\")\r\n    revalidatePath(\"/dashboard/teams\")\r\n\r\n    // Ideally we also invalidate specific cache tags but Path revalidation might not clear unstable_cache depending on nextjs version\r\n    // For now we rely on time-based expiration (5 mins) or explicit path revalidation if it works.\r\n\r\n    return { success: true, code: \"USER_CREATED\" }\r\n  } catch (e) {\r\n    console.error(\"Create User Error:\", e)\r\n    return {\r\n      error: \"Failed to create user (Email/Username might be taken)\",\r\n      code: \"CREATE_FAILED\",\r\n    }\r\n  }\r\n}\r\n\r\n\r\nexport async function updateUser(id: number, formData: FormData) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) return { error: \"Unauthorized\", code: \"UNAUTHORIZED\" }\r\n\r\n  try {\r\n    // Check permission to update users (RBAC, not role)\r\n    await requirePermission(parseInt(session.user.id), \"user.update\")\r\n  } catch (error: any) {\r\n    return handleAuthorizationError(error)\r\n  }\r\n\r\n  // Logic to update user (excluding password for now unless requested)\r\n  const role = formData.get(\"role\") as string\r\n  const teamId = formData.get(\"teamId\") ? parseInt(formData.get(\"teamId\") as string) : null\r\n\r\n  try {\r\n    await prisma.user.update({\r\n      where: { id },\r\n      data: { role, teamId },\r\n    })\r\n\r\n    console.log(`[RBAC] User ${session.user.name || session.user.email} updated user ${id}`)\r\n\r\n    revalidatePath(\"/dashboard/users\")\r\n    return { success: true, code: \"USER_UPDATED\" }\r\n  } catch (e) {\r\n    return { error: \"Failed to update user\", code: \"UPDATE_FAILED\" }\r\n  }\r\n}\r\n\r\n\r\nexport async function deleteUser(id: number) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) return { error: \"Unauthorized\", code: \"UNAUTHORIZED\" }\r\n\r\n  try {\r\n    // Check permission to delete users (RBAC, not role)\r\n    await requirePermission(parseInt(session.user.id), \"user.delete\")\r\n  } catch (error: any) {\r\n    return handleAuthorizationError(error)\r\n  }\r\n\r\n  // Prevent self-deletion\r\n  if (parseInt(session.user.id) === id) {\r\n    return { error: \"Cannot delete your own account\", code: \"SELF_DELETE\" }\r\n  }\r\n\r\n  try {\r\n    // Check for blocking dependencies\r\n    const user = await prisma.user.findUnique({\r\n      where: { id },\r\n      include: {\r\n        projectsManaged: {\r\n          where: {\r\n            NOT: { status: \"completed\" }\r\n          },\r\n          select: { id: true, name: true }\r\n        },\r\n        teamsLed: {\r\n          select: { id: true, name: true }\r\n        },\r\n        timeLogs: { select: { id: true }, take: 1 },\r\n        comments: { select: { id: true }, take: 1 },\r\n        uploadedFiles: { select: { id: true }, take: 1 },\r\n      }\r\n    })\r\n\r\n    if (!user) {\r\n      return { error: \"User not found\", code: \"NOT_FOUND\" }\r\n    }\r\n\r\n    // Check if user is managing active projects\r\n    if (user.projectsManaged.length > 0) {\r\n      const projectNames = user.projectsManaged.map(p => p.name).join(\", \")\r\n      return {\r\n        error: `Cannot delete: User is managing ${user.projectsManaged.length} active project(s) (${projectNames}). Please reassign the project manager first.`,\r\n        code: \"HAS_ACTIVE_PROJECTS\"\r\n      }\r\n    }\r\n\r\n    // Check if user is leading teams\r\n    if (user.teamsLed.length > 0) {\r\n      const teamNames = user.teamsLed.map(t => t.name).join(\", \")\r\n      return {\r\n        error: `Cannot delete: User is leading ${user.teamsLed.length} team(s) (${teamNames}). Please reassign the team lead first.`,\r\n        code: \"IS_TEAM_LEAD\"\r\n      }\r\n    }\r\n\r\n    // Check for critical history that blocks deletion\r\n    if (user.timeLogs.length > 0 || user.comments.length > 0 || user.uploadedFiles.length > 0) {\r\n      return {\r\n        error: \"Cannot delete: User has associated history (Time Logs, Comments, or Files). Please deactivate the user instead to preserve data integrity.\",\r\n        code: \"HAS_HISTORY\"\r\n      }\r\n    }\r\n\r\n    // Perform deletion with cleanup in a transaction\r\n    await prisma.$transaction(async (tx) => {\r\n      // 1. Resolve optional links (ActivityLog) - these don't strictly require user existence\r\n      await tx.activityLog.updateMany({\r\n        where: { performedById: id },\r\n        data: { performedById: null }\r\n      })\r\n\r\n      await tx.activityLog.updateMany({\r\n        where: { affectedUserId: id },\r\n        data: { affectedUserId: null }\r\n      })\r\n\r\n      // 2. Nullify creator references for projects\r\n      await tx.project.updateMany({\r\n        where: { createdById: id },\r\n        data: { createdById: null }\r\n      })\r\n\r\n      // 3. Nullify creator references for tasks\r\n      await tx.task.updateMany({\r\n        where: { createdById: id },\r\n        data: { createdById: null }\r\n      })\r\n\r\n      // 4. Disconnect user from assigned tasks (many-to-many)\r\n      const assignedTasks = await tx.task.findMany({\r\n        where: {\r\n          assignees: {\r\n            some: { id }\r\n          }\r\n        },\r\n        select: { id: true }\r\n      })\r\n\r\n      for (const task of assignedTasks) {\r\n        await tx.task.update({\r\n          where: { id: task.id },\r\n          data: {\r\n            assignees: {\r\n              disconnect: { id }\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      // 5. Clean up other many-to-many or cleanup-safe relations\r\n      // Remove from teams\r\n      await tx.teamMember.deleteMany({\r\n        where: { userId: id }\r\n      })\r\n\r\n      // Remove from project teams\r\n      await tx.projectUser.deleteMany({\r\n        where: { userId: id }\r\n      })\r\n\r\n      // 6. Delete the user\r\n      await tx.user.delete({ where: { id } })\r\n    })\r\n\r\n    console.log(`[RBAC] User ${id} deleted by ${session.user.name || session.user.email}`)\r\n\r\n    revalidatePath(\"/dashboard/users\")\r\n    revalidatePath(\"/dashboard/teams\")\r\n\r\n    return { success: true, code: \"USER_DELETED\" }\r\n  } catch (e: any) {\r\n    console.error(\"Delete user error:\", e)\r\n    // Check for foreign key constraint violation\r\n    if (e.code === 'P2003') {\r\n      return {\r\n        error: \"Cannot delete user due to existing database dependencies (Foreign Key). Please deactivate instead.\",\r\n        code: \"HAS_HISTORY\" // Treat as history blocking\r\n      }\r\n    }\r\n\r\n    return {\r\n      error: `Failed to delete user: ${e.message || \"Unknown error\"}`,\r\n      code: \"DELETE_FAILED\"\r\n    }\r\n  }\r\n}\r\n\r\nexport async function toggleUserStatus(id: number, isActive: boolean) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) return { error: \"Unauthorized\", code: \"UNAUTHORIZED\" }\r\n\r\n  try {\r\n    await requirePermission(parseInt(session.user.id), \"user.update\")\r\n  } catch (error: any) {\r\n    return handleAuthorizationError(error)\r\n  }\r\n\r\n  // Prevent self-deactivation\r\n  if (parseInt(session.user.id) === id && !isActive) {\r\n    return { error: \"Cannot deactivate your own account\", code: \"SELF_DEACTIVATE\" }\r\n  }\r\n\r\n  try {\r\n    const user = await prisma.user.update({\r\n      where: { id },\r\n      data: { isActive },\r\n    })\r\n\r\n    console.log(\r\n      `[RBAC] User ${session.user.name || session.user.email} ${isActive ? \"activated\" : \"deactivated\"} user ${user.username}`\r\n    )\r\n\r\n    revalidatePath(\"/dashboard/users\")\r\n    return { success: true, code: isActive ? \"USER_ACTIVATED\" : \"USER_DEACTIVATED\" }\r\n  } catch (e) {\r\n    console.error(\"Toggle status error:\", e)\r\n    return { error: \"Failed to update user status\", code: \"UPDATE_FAILED\" }\r\n  }\r\n}\r\n\r\n\r\nexport async function updateUserTeam(userId: number, teamId: number | null) {\r\n  const session = await getServerSession(authOptions)\r\n  if (!session) return { error: \"Unauthorized\" }\r\n\r\n  try {\r\n    await prisma.user.update({\r\n      where: { id: userId },\r\n      data: { teamId: teamId }\r\n    })\r\n    revalidatePath(\"/dashboard/users\")\r\n    return { success: true }\r\n  } catch (e) {\r\n    return { error: \"Failed to update user team\" }\r\n  }\r\n}\r\n","export {getPublicSystemSettings as '0033db22356cbf8845a3517099b63dfc38d1147299'} from 'ACTIONS_MODULE0'\nexport {getAllProjectsUnreadNotificationCount as '00686a7231b739e4fe9b8305b757bc0e83827b9865'} from 'ACTIONS_MODULE1'\nexport {getAllProjectsNotifications as '4004a0aae390e2c1aeb900c79065f312ac43d90f8d'} from 'ACTIONS_MODULE1'\nexport {markProjectNotificationAsRead as '60691655a7ad6aec29ab9691d8571a0d380be93da1'} from 'ACTIONS_MODULE1'\nexport {getUsers as '0078a5996050e1da89a66893bd05780e75185392cb'} from 'ACTIONS_MODULE2'\nexport {createUser as '401fc4e21517ebfbd3eebabb3ac6ad3bf2fb7443a7'} from 'ACTIONS_MODULE2'\nexport {getUser as '406fd270e8a350e38c78e4b79321560707aa26fd1a'} from 'ACTIONS_MODULE2'\nexport {deleteUser as '40abdcd9a05b7e5b6a27a4efd7412defa3f340c60c'} from 'ACTIONS_MODULE2'\nexport {updateUserTeam as '6020ac488ab0f44300111f3a8024b04b647106d187'} from 'ACTIONS_MODULE2'\nexport {toggleUserStatus as '60b33fdd6fc55215f2569d47e96e5d33d33f4f707f'} from 'ACTIONS_MODULE2'\nexport {updateUser as '60e1fb0fb657783a6424ba7525af9dca8a6316a12b'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":"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"}